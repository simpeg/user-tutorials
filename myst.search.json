{"version":"1","records":[{"hierarchy":{"lvl1":"SimPEG User Tutorials"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"SimPEG User Tutorials"},"content":"SimPEG user tutorials is the place for those who have \n\ninstalled SimPEG, and want to begin using the code base to practice simulating and inverting geophysical data. On this page, we answer the following questions:\n\nwhat are user tutorials?\n\nwhat can I learn from user tutorial?\n\nhow do I access user tutorials?\n\nCaution\n\nThese user tutorials are meant to be run with SimPEG v0.25.\nPlease, make sure you have this version installed.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What are user tutorials?"},"type":"lvl2","url":"/#what-are-user-tutorials","position":2},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What are user tutorials?"},"content":"The SimPEG user tutorials are a library of \n\nJupyter Notebooks that have been published as a website using \n\nMyST. Each webpage corresponds to a Jupyter notebook where SimPEG has been used to simulate or invert geophysical data for a specific application. In addition to providing the code used to produce computational results, we add \n\nMarkdown text to thoroughly explain each step. By publishing our tutorials using MyST, users have the ability read, download, run and alter any tutorial. Our aim is to make learning SimPEG as painless as possible and ensure efficacy amongst our users.\n\n","type":"content","url":"/#what-are-user-tutorials","position":3},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What can I learn from user tutorials?"},"type":"lvl2","url":"/#what-can-i-learn-from-user-tutorials","position":4},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What can I learn from user tutorials?"},"content":"SimPEG user tutorials provide a learning resource beyond a simple set of reproducible examples. The material presented in each tutorial addresses 4 learning objectives: 1) what SimPEG objects represent, 2) creating SimPEG objects, 3) using SimPEG objects, and 4) suitable input parameters. Successful completion of all learning objectives is strongly urged for anyone who wishes to get the most out of SimPEG.\n\n\n\n1. What SimPEG objects represent: All of the components required to perform forward simulations and inversions with SimPEG (e.g. transmitters, receivers, meshes, regularizations) are defined as objects within the SimPEG framework. When defining new objects within each tutorial, we aim to provide some detail as to what component of the forward simulation or inversion was created.\n\n2. Creating objects in SimPEG: A multitude of required and optional input arguments are set when creating objects within SimPEG. The proper syntax for setting input arguments is provided. The user will also learn the order in which objects are generally created for standard forward modeling and inversion.# Defining a receiver that measures total magnetic intensity data at (100, 0, 100).\nimport simpeg.potential_fields.magnetics as mag\nmy_receiver = mag.receivers.Point(np.c_[10., 0., 0.], components=\"tmi\")\n\n3. Using SimPEG Objects: SimPEG objects have a variety of uses. Some objects can be used to extract information about the forward simulation or inversion (e.g. total number of data, number of mesh cells, target data misfit). And some objects are combined create new objects; e.g. a mesh, a survey and a mapping object are used to create a simulation object. Within each tutorial, we aim to demonstrate the various uses of SimPEG objects.\n\n4. Suitable input parameters: The numerical algorithms responsible for performing forward simulations and inversions within SimPEG are non-trivial. And in order to ensure reasonable results, the set of input parameters (e.g. mesh discretization, data uncertainties, regularization parameters) must be suitable for the problem. To ensure efficacy amongst our users, common approaches for choosing suitable input parameter values are provided within each tutorial.","type":"content","url":"/#what-can-i-learn-from-user-tutorials","position":5},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"How do I access user tutorials?"},"type":"lvl2","url":"/#how-do-i-access-user-tutorials","position":6},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"How do I access user tutorials?"},"content":"Organization: Tutorials can be accessed through the menu on the left-hand side of the screen. Tutorials are generally organized by geophysical method; e.g. magnetics, DC/IP, time-domain electromagnetics. And within these sections, the user will have access to a standard set of forward simulation and inversion tutorials. Tutorials that involve multiple geophysical methods or focus on advanced algorithms (e.g. joint inversion, petrophysically guided inversion) are organized separately.\n\nDownloading: To download the Jupyter notebook used to generate the tutorial, simply scroll to the top of the page and click the download icon (pictured below) in the top-right corner.\n\n","type":"content","url":"/#how-do-i-access-user-tutorials","position":7},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What tutorials should I start with?"},"type":"lvl2","url":"/#what-tutorials-should-i-start-with","position":8},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What tutorials should I start with?"},"content":"User tutorials cover introductory, intermediate and advanced topics within the SimPEG framework. We advise new users to start with introductory tutorials before working their way towards those that are more advanced. For most geophysical methods (e.g. gravity, magnetics, DC resistivity), there is an introductory level tutorial. At the beginning of each tutorial page, one of the following admonitions is used to state the difficulty level and suggested minimum proficiency with SimPEG.\n\nIntroductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nIntermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nAdvanced notebook\n\nThis tutorial focusses on advanced functionality within SimPEG. Basic and intermediate level functionality are not discussed in detail, as we assume the user is already an experienced SimPEG user.","type":"content","url":"/#what-tutorials-should-i-start-with","position":9},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What are the computational requirements?"},"type":"lvl2","url":"/#what-are-the-computational-requirements","position":10},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"What are the computational requirements?"},"content":"Some notebooks can be run in the background on standard laptops, while others can only be run with the help of cluster computing environments. At the beginning of each tutorial page, one of the following admonitions is used to state the computation requirements for running the notebook.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nMedium-weight notebook\n\nRequires moderate computational resources. Run-times may exceed several minutes and require up to 8 GB of available RAM.\n\nComputationally intensive notebook\n\nThe computational resources required to execute this notebook exceed those provided by standard laptop computers. To execute the notebook, please deploy to a cluster computing environment.","type":"content","url":"/#what-are-the-computational-requirements","position":11},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"Want to Add a Tutorial?"},"type":"lvl2","url":"/#want-to-add-a-tutorial","position":12},{"hierarchy":{"lvl1":"SimPEG User Tutorials","lvl2":"Want to Add a Tutorial?"},"content":"Please visit the \n\nContributing to User Tutorials page to find out how you can add a tutorial.","type":"content","url":"/#want-to-add-a-tutorial","position":13},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data"},"type":"lvl1","url":"/fwd-gravity-anomaly-3d","position":0},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: gravity survey, gravity anomaly, forward simulation, integral formulation, tensor mesh.\n\nSummary: Here we use the module \n\nsimpeg​.potential​_fields​.gravity to simulate gravity anomaly data for a synthetic density contrast model. We use the \n\n3D integral formulation and carry out the forward simulation on a tensor mesh.\n\nLearning Objectives:\n\nHow to simulate gravity data for 3D structures with SimPEG.\n\nHow to create gravity surveys.\n\nHow to design a tensor mesh for gravity simulation using the integral solution.\n\nHow to predict gravity anomaly data for a density contrast model.\n\nHow to include surface topography in the forward simulation.\n\nWhat are the units of the density contrast model and resulting data.\n\n","type":"content","url":"/fwd-gravity-anomaly-3d","position":1},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to simulating gravity data are imported from \n\nsimpeg​.potential​_fields​.gravity. We also import some useful utility functions from \n\nsimpeg.utils. To simulate gravity data, we need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we used the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.potential_fields import gravity\nfrom simpeg.utils import plot2Ddata, model_builder\nfrom simpeg import maps\n\n# discretize functionality\nfrom discretize import TensorMesh\nfrom discretize.utils import mkvc, active_from_xyz\n\n# Common Python functionality\nimport numpy as np\nfrom scipy.interpolate import LinearNDInterpolator\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport os\n\nmpl.rcParams.update({\"font.size\": 14})\n\nsave_output = False  # Optional\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#define-the-topography","position":4},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Topography"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray for 3D simulations.\nHere, we create basic topography for the forward simulation.\nFor user-specific simulations, you may load topography from an XYZ file.\n\n[x_topo, y_topo] = np.meshgrid(np.linspace(-200, 200, 41), np.linspace(-200, 200, 41))\n\nrng = np.random.default_rng(seed=737)\nz_topo = (\n    -15 * np.exp(-(x_topo**2 + y_topo**2) / 80**2)\n    + 100.0\n    + rng.uniform(low=0.0, high=0.5, size=x_topo.shape)\n)\n\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([z_topo.max() - 40, z_topo.max()])\nax.plot_surface(x_topo, y_topo, z_topo, color=\"r\", edgecolor=\"k\", linewidth=0.5)\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=20.0)\n\nx_topo, y_topo, z_topo = mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)\ntopo_xyz = np.c_[x_topo, y_topo, z_topo]\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#define-the-topography","position":5},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Survey"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#define-the-survey","position":6},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Survey"},"content":"Surveys within SimPEG generally require the user to create and connect three types of objects:\n\nreceivers: which define the locations of field measurements and type of data being measured.\n\nsources: the passive or active sources responsible for generating geophysical responses, and their associated receivers.\n\nsurvey: the object which stores and organizes all of the sources and receivers.\n\nHere, we define the survey that will be used for the forward simulation. Gravity\nsurveys are simple to create. The user only needs an (N, 3) \n\nnumpy.ndarray to define\nthe xyz locations of the observation locations, and a list of field components\nwhich are to be measured. For the tutorial simulation, the receivers are located 5 m\nabove the surface topography and spaced 10 m apart.\n\n# Define the observation locations as an (N, 3) numpy array or load them from a file.\nx = np.linspace(-80.0, 80.0, 17)\ny = np.linspace(-80.0, 80.0, 17)\nx, y = np.meshgrid(x, y)\nx, y = mkvc(x.T), mkvc(y.T)\nfun_interp = LinearNDInterpolator(np.c_[x_topo, y_topo], z_topo)\nz = fun_interp(np.c_[x, y]) + 5.0\nreceiver_locations = np.c_[x, y, z]\n\n# Define the component(s) of the field we want to simulate as strings within\n# a list. Here we simulate only the vertical component of the gravity anomaly.\ncomponents = [\"gz\"]\n\n# Use the observation locations and components to define receivers for the entire survey\n# in one step. The set of receivers, even if it's only 1, are organized within a list.\nreceiver_list = gravity.receivers.Point(receiver_locations, components=components)\nreceiver_list = [receiver_list]\n\n# Defining the source. For gravity surveys, we simply need to specific the list of\n# receivers associated with the source field.\nsource_field = gravity.sources.SourceField(receiver_list=receiver_list)\n\n# Defining the survey.\nsurvey = gravity.survey.Survey(source_field)\n\nIf desired, we can extract various objects and properties from the objects used to generate the survey. E.g.\n\nprint(\"# of data: {}\".format(survey.nD))  # number of data that will be simulated\nprint(survey.source_field)  # the source field object\nprint(survey.source_field.receiver_list[0])  # the receiver object\nprint(receiver_list[0].locations[:5, :])  # the first 5 receiver locations\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#define-the-survey","position":7},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Design a (Tensor) Mesh"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#design-a-tensor-mesh","position":8},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Design a (Tensor) Mesh"},"content":"Meshes are designed using the \n\ndiscretize package. See the \n\ndiscretize user tutorials to learn more about creating meshes.\nHere, the forward simulation is computed for a \n\ntensor mesh. If you wanted to generate a \n\ntree mesh instead, you can use the code snippet from the \n\n3D Forward Simulation of Gravity Gradiometry Data tutorial.\n\nThe integral formulation for gravity essentially sums the independent gravity anomaly contribution for every voxel cell in the mesh. Since the kernel function that computes the contribution for a single cell is an analytic solution, small cells are not required to accurately compute the contributions from coarse structures with constant density (e.g. a rectangular prism). For complex structures however, or to define surface topography more accurately, finer cells may be needed. Furthermore, cells do not need to be cubic.\n\nHere, a core cell width of 5 m is used within our survey region. Padding is used to extend the mesh outside the immediate survey area. The mesh will be plotted after we define our density contrast model.\n\n# Generate tensor mesh with top at z = 0 m\ndh = 5.0\nhx = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhy = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhz = [(dh, 5, -1.3), (dh, 15)]\nmesh = TensorMesh([hx, hy, hz], \"CCN\")\n\n# Shift vertically to top same as maximum topography\nmesh.origin += np.r_[0.0, 0.0, z_topo.max()]\n\nIf desired, we can extract various properties of the mesh. E.g.\n\nprint(\"# of cells: {}\".format(mesh.n_cells))  # Number of cells\nprint(\"# of x-faces: {}\".format(mesh.n_faces_x))  # Number of x-faces\nprint(\"Origin: {}\".format(mesh.origin))  # bottom-southewest corner\nprint(\"Max cell volume: {}\".format(mesh.cell_volumes.max()))  # Largest cell size\nprint(mesh.cell_centers[0:5, :])  # Cell center locations\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#design-a-tensor-mesh","position":9},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Active Cells"},"content":"Whereas cells below the Earth’s surface contribute towards the simulated gravity anomaly, air cells do not.\nThe set of mesh cells used in the forward simulation are referred to as ‘active cells’. Unused cells (air cells) are ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Mapping from the Model to Active Cells"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#mapping-from-the-model-to-active-cells","position":12},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Mapping from the Model to Active Cells"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For example, the model may be defined as the logarithms of the physical property values, or be parameters defining a layered Earth. When simulating gravity anomaly data using the integral formulation, we must define a mapping from the set of model parameters to the active cells in the mesh. Mappings are created using the \n\nsimpeg.maps module. For the tutorial exercise, the model is the density contrast values for all active cells. As such, our mapping is an identity mapping, whose dimensions are equal to the number of active cells.\n\n# Define mapping from model to active cells. The model consists of a density\n# contrast value for each cell below the Earth's surface.\nn_active = int(active_cells.sum())\nmodel_map = maps.IdentityMap(nP=n_active)\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#mapping-from-the-model-to-active-cells","position":13},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Model"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#define-the-model","position":14},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Model"},"content":"Here, we create the model that will be used to predict gravity anomaly data.\nRecall that our model is the density constrast values for all active mesh cells.\nSo the model is a 1D \n\nnumpy.ndarray whose length is\nequal to the number of model parameters.\nIn SimPEG, density contrast values are defined in units of g/cc.\nHere, the model consists of a less dense block and a more dense sphere.\nWe plot the model using the \n\nplot_slice method.\n\n# Define density contrast values for each unit in g/cc\nbackground_density = 0.0\nblock_density = -0.2\nsphere_density = 0.2\n\n# Instantiate a vector array.\nmodel = background_density * np.ones(n_active)\n\n# You could find the indicies of specific cells within the model and change their\n# values to add structures.\nind_block = (\n    (mesh.cell_centers[active_cells, 0] > -50.0)\n    & (mesh.cell_centers[active_cells, 0] < -20.0)\n    & (mesh.cell_centers[active_cells, 1] > -15.0)\n    & (mesh.cell_centers[active_cells, 1] < 15.0)\n    & (mesh.cell_centers[active_cells, 2] > 50.0)\n    & (mesh.cell_centers[active_cells, 2] < 70.0)\n)\nmodel[ind_block] = block_density\n\n# You can also use SimPEG utilities to add structures to the model more concisely\nind_sphere = model_builder.get_indices_sphere(\n    np.r_[35.0, 0.0, 60.0], 14.0, mesh.cell_centers\n)\nind_sphere = ind_sphere[active_cells]\nmodel[ind_sphere] = sphere_density\n\n# Map for ignoring inactive cells when plotting\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\n# Plot Density Contrast Model\nfig = plt.figure(figsize=(8, 3.5))\n\nax1 = fig.add_axes([0.1, 0.12, 0.73, 0.78])\nmesh.plot_slice(\n    plotting_map * model,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(mesh.shape_cells[1] / 2),\n    grid=True,\n    clim=(np.min(model), np.max(model)),\n    pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_title(\"Model slice at y = 0 m\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.85, 0.12, 0.03, 0.78])\nnorm = mpl.colors.Normalize(vmin=np.min(model), vmax=np.max(model))\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(\"$g/cm^3$\", rotation=270, labelpad=15, size=16)\n\nplt.show()\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#define-the-model","position":15},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#define-the-forward-simulation","position":16},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Define the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class.\nIn this case, we use the simulation class for the \n\n3D integral formulation. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe mesh\n\nthe indices of the active cells\n\nthe mapping from the model to the active cells\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object.\nAdditional keyword arguments can also be set which impact the forward simulation.\nBecause we are only simulating data for a single model, there is no benefit to storing the sensitivities for the forward simulation. As a result, we set the store_sensitivities property to ‘forward_only’.\n\nsimulation = gravity.simulation.Simulation3DIntegral(\n    survey=survey,\n    mesh=mesh,\n    rhoMap=model_map,\n    active_cells=active_cells,\n    store_sensitivities=\"forward_only\",\n    engine=\"choclo\",\n)\n\nTip\n\nBy choosing engine=\"choclo\" we can make our simulation to run the faster and more memory efficient implementation of the gravity forward that uses \n\nNumba and \n\nChoclo under the hood. To do so, we need to have \n\nChoclo installed.\n\n","type":"content","url":"/fwd-gravity-anomaly-3d#define-the-forward-simulation","position":17},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Simulate Gravity Anomaly Data"},"type":"lvl2","url":"/fwd-gravity-anomaly-3d#simulate-gravity-anomaly-data","position":18},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Anomaly Data","lvl2":"Simulate Gravity Anomaly Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. SimPEG uses a right-handed coordinate system to simulate gravity anomaly data where Z is positive upward!!! Please be aware of this when using gravity anomaly data to infer the locations of more and less dense structures. E.g. above a more dense block, a negative gravity anomaly is observed because gravity is stronger in the -ve Z direction. In SimPEG, gravity anomaly values are in units mGal.\n\ndpred = simulation.dpred(model)\n\nfig = plt.figure(figsize=(7, 5))\nax1 = fig.add_axes([0.1, 0.1, 0.75, 0.85])\n\nnorm = mpl.colors.Normalize(vmin=-np.max(np.abs(dpred)), vmax=np.max(np.abs(dpred)))\nplot2Ddata(\n    receiver_list[0].locations,\n    dpred,\n    ax=ax1,\n    ncontour=40,\n    contourOpts={\"cmap\": mpl.cm.bwr, \"norm\": norm},\n)\nax1.set_title(\"Gravity Anomaly (Z-component)\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\n\nax2 = fig.add_axes([0.81, 0.1, 0.04, 0.85])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.bwr\n)\ncbar.set_label(\"$mGal$\", rotation=270, labelpad=20, size=16)\n\nplt.show()\n\nOptional: Exporting the data and topography.\n\nif save_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_gravity_anomaly_3d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    fname = dir_path + \"gravity_topo.txt\"\n    np.savetxt(fname, np.c_[topo_xyz], fmt=\"%.4e\")\n\n    rng = np.random.default_rng(seed=737)\n    maximum_anomaly = np.max(np.abs(dpred))\n    noise = rng.normal(scale=0.02 * maximum_anomaly, size=len(dpred))\n    fname = dir_path + \"gravity_data.obs\"\n    np.savetxt(fname, np.c_[receiver_locations, dpred + noise], fmt=\"%.4e\")","type":"content","url":"/fwd-gravity-anomaly-3d#simulate-gravity-anomaly-data","position":19},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data"},"type":"lvl1","url":"/fwd-gravity-gradiometry-3d","position":0},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: gravity anomaly, forward simulation, integral formulation, tree mesh.\n\nSummary: Here we use the module \n\nsimpeg​.potential​_fields​.gravity to simulate gravity gradiometry data for a synthetic density contrast model. We use the \n\n3D integral formulation and carry out the forward simulation on a tree mesh.\n\nLearning Objectives:\n\nHow to simulate gravity data for 3D structures with SimPEG.\n\nHow to create gravity gradiometry surveys and manage multiple data components.\n\nHow to design a tree mesh for gravity simulation (integral solution).\n\nHow to predict gravity gradiometry data for a density contrast model.\n\nHow to include surface topography in the forward simulation.\n\nWhat are the units of the density contrast model and resulting data.\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d","position":1},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to simulating gravity data are imported from \n\nsimpeg​.potential​_fields​.gravity.\nWe also import some useful utility functions from SimPEG. To simulate gravity data,\nwe need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we used the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.potential_fields import gravity\nfrom simpeg.utils import plot2Ddata, model_builder\nfrom simpeg import maps\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import mkvc, active_from_xyz\n\n# Common Python functionality\nimport numpy as np\nfrom scipy.interpolate import LinearNDInterpolator\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.rcParams.update({\"font.size\": 14})\n\nsave_output = False  # Optional\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#define-the-topography","position":4},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Topography"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray for 3D simulations.\nHere, we create basic topography for the forward simulation.\nFor user-specific simulations, you may load topography from an XYZ file.\n\n[x_topo, y_topo] = np.meshgrid(np.linspace(-200, 200, 41), np.linspace(-200, 200, 41))\nrng = np.random.default_rng(seed=737)\nz_topo = (\n    -15 * np.exp(-(x_topo**2 + y_topo**2) / 80**2)\n    + 100.0\n    + rng.uniform(low=0.0, high=0.5, size=x_topo.shape)\n)\n\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([z_topo.max() - 40, z_topo.max()])\nax.plot_surface(x_topo, y_topo, z_topo, color=\"r\", edgecolor=\"k\", linewidth=0.5)\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=20.0)\n\nx_topo, y_topo, z_topo = mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)\ntopo_xyz = np.c_[x_topo, y_topo, z_topo]\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#define-the-topography","position":5},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Survey"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#define-the-survey","position":6},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Survey"},"content":"Surveys within SimPEG generally require the user to create and connect three types of objects:\n\nreceivers: which define the locations of field measurements and type of data being measured.\n\nsources: the passive or active sources responsible for generating geophysical responses, and their associated receivers.\n\nsurvey: the object which stores and organizes all of the sources and receivers.\n\nHere, we define the survey that will be used for the forward simulation. Gravity\nsurveys are simple to create. The user only needs an (N, 3) \n\nnumpy.ndarray to define\nthe xyz locations of the observation locations, and a list of field components\nwhich are to be measured. For the tutorial simulation, the receivers are located 5 m\nabove the surface topography and spaced 10 m apart.\n\n# Define the observation locations as an (N, 3) numpy array or load them from a file.\nx = np.linspace(-80.0, 80.0, 17)\ny = np.linspace(-80.0, 80.0, 17)\nx, y = np.meshgrid(x, y)\nx, y = mkvc(x.T), mkvc(y.T)\nfun_interp = LinearNDInterpolator(np.c_[x_topo, y_topo], z_topo)\nz = fun_interp(np.c_[x, y]) + 5.0\nreceiver_locations = np.c_[x, y, z]\n\n# Define the component(s) of the field we want to simulate as strings within\n# a list. Here we measure the x, y and z derivatives of the vertical gravity\n# anomaly at each observation location.\ncomponents = [\"gxz\", \"gyz\", \"gzz\"]\n\n# Use the observation locations and components to define receivers for the entire survey\n# in one step. The set of receivers, even if it's only 1, are organized within a list.\nreceiver_list = gravity.receivers.Point(receiver_locations, components=components)\nreceiver_list = [receiver_list]\n\n# Defining the source. For gravity surveys, we simply need to specific the list of\n# receivers associated with the source field.\nsource_field = gravity.sources.SourceField(receiver_list=receiver_list)\n\n# Defining the survey.\nsurvey = gravity.survey.Survey(source_field)\n\nIf desired, we can extract various objects and properties from the objects used to generate the survey. E.g.\n\nprint(\"# of locations: {}\".format(survey.nRx))  # number of receiver locations\nprint(\"# of data: {}\".format(survey.nD))  # number of data that will be simulated\nprint(survey.source_field)  # the source field object\nprint(survey.source_field.receiver_list[0])  # the receiver object\nprint(receiver_list[0].locations[:5, :])  # the first 5 receiver locations\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#define-the-survey","position":7},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#design-a-tree-mesh","position":8},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Design a (Tree) Mesh"},"content":"Meshes are designed using the \n\ndiscretize package. See the \n\ndiscretize user tutorials to learn more about creating meshes.\nHere, the forward simulation is computed for a \n\ntree mesh. If you wanted to generate a \n\ntensor mesh instead, you can use the code snippet from the \n\n3D Forward Simulation of Gravity Anomaly Data tutorial.\n\nThe integral formulation for gravity essentially sums the independent contribution for every voxel cell in the mesh. Since the kernel function that computes the contribution for a single cell is an analytic solution, small cells are not required to accurately compute the contributions from coarse structures with constant density (e.g. a rectangular prism). For complex structures however, or to define surface topography more accurately, finer cells may be needed. Furthermore, cells do not need to be cubic.\n\nHere, a minimum cell width of 5 m is used within our survey region. In this tutorial, we discretize finely along the surface topography, and within our region of interest. However, a multitude of refinement methods can be applied when generating tree meshes.\n\ndx = 5  # minimum cell width (base mesh cell width) in x\ndy = 5  # minimum cell width (base mesh cell width) in y\ndz = 5  # minimum cell width (base mesh cell width) in z\n\nx_length = 240.0  # domain width in x\ny_length = 240.0  # domain width in y\nz_length = 120.0  # domain width in z\n\n# Compute number of base mesh cells required in x and y\nnbcx = 2 ** int(np.round(np.log(x_length / dx) / np.log(2.0)))\nnbcy = 2 ** int(np.round(np.log(y_length / dy) / np.log(2.0)))\nnbcz = 2 ** int(np.round(np.log(z_length / dz) / np.log(2.0)))\n\n# Define the base mesh. Top defined at z = 0 m.\nhx = [(dx, nbcx)]\nhy = [(dy, nbcy)]\nhz = [(dz, nbcz)]\nmesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift vertically to top same as maximum topography\nmesh.origin += np.r_[0.0, 0.0, z_topo.max()]\n\n# Refine based on surface topography\nmesh.refine_surface(topo_xyz, padding_cells_by_level=[2, 2], finalize=False)\n\n# Refine box based on region of interest\nwsb_corner = np.c_[-100, -100, 20]\nent_corner = np.c_[100, 100, 100]\n# Note -1 is a flag for smallest cell size\nmesh.refine_box(wsb_corner, ent_corner, levels=[-1], finalize=False)\n\nmesh.finalize()\n\nIf desired, we can extract various properties of the mesh. E.g.\n\nprint(\"# of cells: {}\".format(mesh.n_cells))  # Number of cells\nprint(\"# of x-faces: {}\".format(mesh.n_faces_x))  # Number of x-faces\nprint(\"Origin: {}\".format(mesh.origin))  # bottom-southewest corner\nprint(\"Max cell volume: {}\".format(mesh.cell_volumes.max()))  # Largest cell size\nprint(mesh.cell_centers[0:5, :])  # Cell center locations\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#design-a-tree-mesh","position":9},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Active Cells"},"content":"Whereas cells below the Earth’s surface contribute towards the simulated gravity anomaly, air cells do not.\nThe set of mesh cells used in the forward simulation are referred to as ‘active cells’. Unused cells (air cells) are ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Mapping from the Model to Active Cells"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#mapping-from-the-model-to-active-cells","position":12},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Mapping from the Model to Active Cells"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For example, the model may be defined as the logarithms of the physical property values, or be parameters defining a layered Earth. When simulating gravity anomaly data using the integral formulation, we must define a mapping from the set of model parameters to the active cells in the mesh. Mappings are created using the \n\nsimpeg.maps module. For the tutorial exercise, the model is the density contrast values for all active cells. As such, our mapping is an identity mapping, whose dimensions are equal to the number of active cells.\n\n# Define mapping from model to active cells. The model consists of a density\n# contrast value for each cell below the Earth's surface.\nn_active = int(active_cells.sum())\nmodel_map = maps.IdentityMap(nP=n_active)\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#mapping-from-the-model-to-active-cells","position":13},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Model"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#define-the-model","position":14},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Model"},"content":"Here, we create the model that will be used to predict gravity anomaly data.\nRecall that our model is the density constrast values for all active mesh cells.\nSo the model is a 1D \n\nnumpy.ndarray whose length is\nequal to the number of model parameters.\nIn SimPEG, density contrast values are defined in units of g/cc.\nHere, the model consists of a less dense block and a more dense sphere.\nWe plot the model using the \n\nplot_slice method.\n\n# Define density contrast values for each unit in g/cc\nbackground_density = 0.0\nblock_density = -0.2\nsphere_density = 0.2\n\n# Instantiate a vector array. Models in SimPEG are vector arrays.\nmodel = background_density * np.ones(n_active)\n\n# You could find the indicies of specific cells within the model and change their\n# values to add structures.\nind_block = (\n    (mesh.cell_centers[active_cells, 0] > -50.0)\n    & (mesh.cell_centers[active_cells, 0] < -20.0)\n    & (mesh.cell_centers[active_cells, 1] > -15.0)\n    & (mesh.cell_centers[active_cells, 1] < 15.0)\n    & (mesh.cell_centers[active_cells, 2] > 50.0)\n    & (mesh.cell_centers[active_cells, 2] < 70.0)\n)\nmodel[ind_block] = block_density\n\n# You can also use SimPEG utilities to add structures to the model more concisely\nind_sphere = model_builder.get_indices_sphere(\n    np.r_[35.0, 0.0, 60.0], 14.0, mesh.cell_centers\n)\nind_sphere = ind_sphere[active_cells]\nmodel[ind_sphere] = sphere_density\n\n# Map for ignoring inactive cells when plotting\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\n# Plot Density Contrast Model\nfig = plt.figure(figsize=(8, 3.5))\nax1 = fig.add_axes([0.1, 0.12, 0.73, 0.78])\n\nnorm = mpl.colors.Normalize(vmin=np.min(model), vmax=np.max(model))\n\nmesh.plot_slice(\n    plotting_map * model,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(mesh.shape_cells[1] / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": norm},\n)\nax1.set_title(\"Model slice at y = 0 m\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.85, 0.12, 0.03, 0.78])\n\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(\"$g/cm^3$\", rotation=270, labelpad=15, size=16)\n\nplt.show()\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#define-the-model","position":15},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#define-the-forward-simulation","position":16},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Define the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class.\nIn this case, the simulation class corresponds to a \n\n3D integral formulation. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe mesh\n\nthe indices of the active cells\n\nthe mapping from the model to the active cells\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object.\nAdditional keyword arguments can also be set which impact the forward simulation.\nBecause we are only simulating data for a single model, there is no benefit to storing the sensitivities for the forward simulation. As a result, we set the store_sensitivities property to “forward_only”.\n\nsimulation = gravity.simulation.Simulation3DIntegral(\n    survey=survey,\n    mesh=mesh,\n    rhoMap=model_map,\n    active_cells=active_cells,\n    store_sensitivities=\"forward_only\",\n    engine=\"choclo\",\n)\n\nTip\n\nBy choosing engine=\"choclo\" we can make our simulation to run the faster and more memory efficient implementation of the gravity forward that uses \n\nNumba and \n\nChoclo under the hood. To do so, we need to have \n\nChoclo installed.\n\n","type":"content","url":"/fwd-gravity-gradiometry-3d#define-the-forward-simulation","position":17},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Simulate Gravity Gradiometry Data"},"type":"lvl2","url":"/fwd-gravity-gradiometry-3d#simulate-gravity-gradiometry-data","position":18},{"hierarchy":{"lvl1":"3D Forward Simulation of Gravity Gradiometry Data","lvl2":"Simulate Gravity Gradiometry Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. SimPEG uses a right-handed coordinate system to simulate gravity gradiometry data where Z is positive upward!!! Please be aware of this when using gravity gradiometry data to infer the locations of more and less dense structures. In SimPEG, gravity gradiometry values are in units Eotvos, where 1 E = 10^{-9} \\; s^{-2} = \n\n10-4 mGal/m.\n\ndpred = simulation.dpred(model)\n\nData are ordered by component, then by location. Here, we reshape the predicted data vector into an array for easier plotting.\n\nn_loc = survey.nRx  # Number of receiver locations\nn_comp = len(components)  # Number of data components\ndpred_plotting = np.reshape(dpred, (n_loc, n_comp))\n\n# Plot\nfig = plt.figure(figsize=(10, 3))\nv_max = np.max(np.abs(dpred))\n\nax = 3 * [None]\ncplot = 3 * [None]\ncomp_list = [\"x\", \"y\", \"z\"]\n\nnorm = mpl.colors.Normalize(vmin=-v_max, vmax=v_max)\n\nfor ii in range(0, 3):\n    ax[ii] = fig.add_axes([0.1 + ii * 0.26, 0.15, 0.25, 0.78])\n    cplot[ii] = plot2Ddata(\n        receiver_locations,\n        dpred_plotting[:, ii],\n        ax=ax[ii],\n        ncontour=30,\n        contourOpts={\"cmap\": \"bwr\", \"norm\": norm},\n    )\n    ax[ii].set_title(r\"$\\partial g_z /\\partial {}$\".format(comp_list[ii]))\n    ax[ii].set_xlabel(\"x (m)\")\n    if ii == 0:\n        ax[ii].set_ylabel(\"y (m)\")\n    else:\n        ax[ii].set_yticks([])\n\ncx = fig.add_axes([0.89, 0.13, 0.02, 0.79])\ncbar = mpl.colorbar.ColorbarBase(cx, norm=norm, orientation=\"vertical\", cmap=mpl.cm.bwr)\ncbar.set_label(\"$Eotvos$\", rotation=270, labelpad=10, size=12)\n\nplt.show()","type":"content","url":"/fwd-gravity-gradiometry-3d#simulate-gravity-gradiometry-data","position":19},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data"},"type":"lvl1","url":"/inv-gravity-anomaly-3d","position":0},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: gravity anomaly, integral formulation, inversion, sparse norm, tensor mesh, tree mesh.\n\nSummary: Here we invert gravity anomaly data to recover a density contrast model. We demonstrate two approaches for recovering a density contrast model:\n\nWeighted least-squares inversion for a tensor mesh\n\nIteratively re-weighted least-squares (IRLS) inversion for a tree mesh\n\nThe weighted least-squares approach is a great introduction to geophysical inversion with SimPEG. One drawback however, is that it recovers smooth structures which may not be representative of the true model. To recover sparse and/or blocky structures, we also demonstrate the iteratively re-weighted least-squares approach. Because this tutorial focusses primarily on inversion-related functionality, we urge the reader to become familiar with functionality explained in the \n\n3D Forward Simulation of Gravity Anomaly Data tutorial before working through this one.\n\nLearning Objectives:\n\nHow geophysical inversion is carried out using SimPEG.\n\nHow to assign appropriate uncertainties to gravity anomaly data.\n\nHow to design a suitable mesh for gravity inversion when using the integral formulation.\n\nHow to choose and set parameters for the inversion.\n\nHow to define directives that are applied and updated throughout the inversion.\n\nHow to applying the sensitivity weighting generally used in 3D gravity inversion.\n\nHow to invert data using weighted least-squares and sparse-norm regularization.\n\nHow to analyse inversion results.\n\nAlthough we consider gravity anomaly data in this tutorial, the same approach\ncan be used to invert gravity gradiometry data.\n\n","type":"content","url":"/inv-gravity-anomaly-3d","position":1},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Import Modules"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to the forward simulation of gravity data are imported from the \n\nsimpeg​.potential​_fields​.gravity module. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.potential_fields import gravity\nfrom simpeg.utils import plot2Ddata, model_builder, download\nfrom simpeg import (\n    maps,\n    data,\n    data_misfit,\n    inverse_problem,\n    regularization,\n    optimization,\n    directives,\n    inversion,\n)\n\n# discretize functionality\nfrom discretize import TensorMesh, TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Common Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport tarfile\n\nmpl.rcParams.update({\"font.size\": 14})\n\n","type":"content","url":"/inv-gravity-anomaly-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Load Tutorial Files"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#load-tutorial-files","position":4},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Load Tutorial Files"},"content":"For most geophysical inversion projects, a reasonable inversion result can be obtained so long as the practitioner has observed data and topography. For this tutorial, the observed data and topography files are provided. Here, we download and import the observed data and topography into the SimPEG framework.\n\n# URL to download from repository assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/03-gravity/inv_gravity_anomaly_3d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"gravity_topo.txt\"\ndata_filename = dir_path + \"gravity_data.obs\"\n\nFor this tutorial, the data are organized within basic XYZ files. However, SimPEG does allow the user to import UBC-GIF formatted gravity data files; see \n\nread_grav3d_ubc.\n\n# Load topography (xyz file)\ntopo_xyz = np.loadtxt(str(topo_filename))\n\n# Load field data (xyz file)\ndobs = np.loadtxt(str(data_filename))\n\n","type":"content","url":"/inv-gravity-anomaly-3d#load-tutorial-files","position":5},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Plot Observed Data and Topography"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#plot-observed-data-and-topography","position":6},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Plot Observed Data and Topography"},"content":"Here we plot the synthetic gravity anomaly data and local topography.\n\n# Define receiver locations and observed data\nreceiver_locations = dobs[:, 0:3]\ndobs = dobs[:, -1]\n\nfig = plt.figure(figsize=(9, 5))\n\nax1 = fig.add_axes([0.05, 0.35, 0.35, 0.6])\nplot2Ddata(\n    receiver_locations,\n    dobs,\n    ax=ax1,\n    dataloc=True,\n    ncontour=40,\n    contourOpts={\"cmap\": \"bwr\"},\n)\nax1.set_title(\"Gravity Anomaly\", pad=15)\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\n\ncx1 = fig.add_axes([0.05, 0.18, 0.35, 0.04])\nnorm1 = mpl.colors.Normalize(vmin=-np.max(np.abs(dobs)), vmax=np.max(np.abs(dobs)))\ncbar1 = mpl.colorbar.ColorbarBase(\n    cx1, norm=norm1, orientation=\"horizontal\", cmap=mpl.cm.bwr\n)\ncbar1.set_label(\"$mGal$\", size=16)\n\nax2 = fig.add_axes([0.55, 0.35, 0.35, 0.6])\nplot2Ddata(\n    topo_xyz[:, 0:2],\n    topo_xyz[:, -1],\n    ax=ax2,\n    ncontour=50,\n    contourOpts={\"cmap\": \"gist_earth\"},\n)\nax2.set_title(\"Topography\", pad=15)\nax2.set_xlabel(\"x (m)\")\nax2.set_ylabel(\"y (m)\")\n\ncx2 = fig.add_axes([0.55, 0.18, 0.35, 0.04])\nnorm2 = mpl.colors.Normalize(vmin=np.min(topo_xyz[:, -1]), vmax=np.max(topo_xyz[:, -1]))\ncbar2 = mpl.colorbar.ColorbarBase(\n    cx2, norm=norm2, orientation=\"horizontal\", cmap=mpl.cm.gist_earth\n)\ncbar2.set_label(\"$m$\", size=16)\n\nplt.show()\n\n","type":"content","url":"/inv-gravity-anomaly-3d#plot-observed-data-and-topography","position":7},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#assign-uncertainties","position":8},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor gravity anomaly data, a constant floor value is generally applied to all data. We usually avoid assigning percent uncertainties because the inversion would prioritize fitting the background over fitting anomalies. The floor value for the uncertainties may be chosen based on some knowledge of the instrument error, or it may be chosen as some fraction of the largest anomaly value. For this tutorial, the floor uncertainty assigned to all data is 2.5% of the maximum observed gravity anomaly value. For gravity gradiometry data, you may choose to assign a different floor value to each data component.\n\nmaximum_anomaly = np.max(np.abs(dobs))\nfloor_uncertainty = 0.02 * maximum_anomaly\nuncertainties = floor_uncertainty * np.ones(np.shape(dobs))\nprint(\"Floor uncertainty: {}\".format(floor_uncertainty))\n\n","type":"content","url":"/inv-gravity-anomaly-3d#assign-uncertainties","position":9},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Define the Survey"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#define-the-survey","position":10},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Define the Survey"},"content":"Here, we define the survey geometry. The survey consists of a 160 m x 160 m grid of equally spaced receivers located 5 m\nabove the surface topography. For a more comprehensive description of constructing gravity surveys in SimPEG, see the \n\n3D Forward Simulation of Gravity Anomaly Data tutorial.\n\n# Define the receivers. The data consist of vertical gravity anomaly measurements.\n# The set of receivers must be defined as a list.\nreceiver_list = gravity.receivers.Point(receiver_locations, components=\"gz\")\nreceiver_list = [receiver_list]\n\n# Define the source field\nsource_field = gravity.sources.SourceField(receiver_list=receiver_list)\n\n# Define the survey\nsurvey = gravity.survey.Survey(source_field)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-survey","position":11},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Define the Data"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#define-the-data","position":12},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Define the Data"},"content":"The SimPEG \n\nData class is required for inversion and connects the observed data, uncertainties and survey geometry.\n\ndata_object = data.Data(survey, dobs=dobs, standard_deviation=uncertainties)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-data","position":13},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#weighted-least-squares-inversion-on-a-tensor-mesh","position":14},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Here, we provide a step-by-step best-practices approach for weighted least-squares inversion of gravity anomaly data.\n\n","type":"content","url":"/inv-gravity-anomaly-3d#weighted-least-squares-inversion-on-a-tensor-mesh","position":15},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Design a (Tensor) Mesh","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#design-a-tensor-mesh","position":16},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Design a (Tensor) Mesh","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Meshes are designed using the \n\ndiscretize package. Here, we design a \n\ntensor mesh. See the \n\ndiscretize user tutorials to learn more about creating meshes. When designing a mesh for gravity inversion, we must consider the spatial wavelengths of the signals contained within the data. If the data spacing is large and/or the signals present in the data are smooth, larger cells can be used to construct the mesh. If the data spacing is smaller and compact anomalies are observed, smaller cells are needed to characterize the structures responsible. And smaller cells are required when the effects of surface topography are significant.\n\nGeneral rule of thumb: The minimum cell size in each direction is at most 0.5 - 1 times the station spacing. And the thickness of the padding is at least 1 - 2 times the width of the survey region.\n\n# Generate tensor mesh with top at z = 0 m\ndh = 5.0  # minimum cell size\nhx = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]  # discretization along x\nhy = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]  # discretization along y\nhz = [(dh, 5, -1.3), (dh, 15)]  # discretization along z\ntensor_mesh = TensorMesh([hx, hy, hz], \"CCN\")\n\n# Shift vertically to top same as maximum topography\ntensor_mesh.origin += np.r_[0.0, 0.0, topo_xyz[:, -1].max()]\n\n","type":"content","url":"/inv-gravity-anomaly-3d#design-a-tensor-mesh","position":17},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-active-cells","position":18},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Whereas cells below the Earth’s surface contribute towards the simulated gravity anomaly, air cells do not.\nThe set of mesh cells used in the forward simulation are referred to as ‘active cells’. Unused cells (air cells) are ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\nactive_tensor_cells = active_from_xyz(tensor_mesh, topo_xyz)\nn_tensor_active = int(active_tensor_cells.sum())\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-active-cells","position":19},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Mapping from the Model to Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#mapping-from-the-model-to-active-cells","position":20},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Mapping from the Model to Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For whatever model we choose, we must define a mapping from the set of model parameters (a \n\n1D numpy.ndarray) to the active cells in the mesh. Mappings are created using the \n\nsimpeg.maps module. For the tutorial exercise, the model is the density contrast values for all active cells. As such, our mapping is an identity mapping, whose dimensions are equal to the number of active cells.\n\ntensor_model_map = maps.IdentityMap(nP=n_tensor_active)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#mapping-from-the-model-to-active-cells","position":21},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#starting-reference-models","position":22},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"The starting model defines a reasonable starting point for the inversion and does not necessarily represent an initial estimate of the true model. Because the integral formulation used to solve the gravity forward simulation is linear, the optimization problem we must solve is a linear least-squares problem, making the choice in starting model insignificant. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration. For gravity inversion, the starting model is frequently a constant vector with a very small value.\n\nThe reference model is used to include a-prior information. The impact of the reference model on the inversion will be discussed in another tutorial. Assuming the contribution from all background structures has been removed from the gravity anomaly data, and assuming we have not a-priori information, the reference model for basic inversion of gravity data is zero.\n\nNotice that the length of the starting and reference models is equal to the number of active mesh cells!!!\n\nstarting_tensor_model = 1e-6 * np.ones(n_tensor_active)\nreference_tensor_model = np.zeros_like(starting_tensor_model)\n\n# Map for ignoring inactive cells when plotting\ntensor_plotting_map = maps.InjectActiveCells(tensor_mesh, active_tensor_cells, np.nan)\n\nfig = plt.figure(figsize=(7, 3))\nax1 = fig.add_axes([0.1, 0.1, 0.73, 0.8])\n\nnorm = mpl.colors.Normalize(vmin=-0.1, vmax=0.1)\ntensor_mesh.plot_slice(\n    tensor_plotting_map * starting_tensor_model,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(tensor_mesh.shape_cells[1] / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": norm},\n)\nax1.set_title(\"Starting Model (slice at y = 0 m)\")\n\nax2 = fig.add_axes([0.85, 0.1, 0.03, 0.8])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(\"$g/cm^3$\", rotation=270, labelpad=15, size=16)\n\nplt.show()\n\n","type":"content","url":"/inv-gravity-anomaly-3d#starting-reference-models","position":23},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-forward-simulation","position":24},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for gravity anomaly data was discussed in the \n\n3D Forward Simulation of Gravity Anomaly Data tutorial. Here, we use the \n\n3D integral formulation.\n\nsimulation_L2 = gravity.simulation.Simulation3DIntegral(\n    survey=survey,\n    mesh=tensor_mesh,\n    rhoMap=tensor_model_map,\n    active_cells=active_tensor_cells,\n    engine=\"choclo\",\n)\n\nTip\n\nBy choosing engine=\"choclo\" we can make our simulation to run the faster and more memory efficient implementation of the gravity forward that uses \n\nNumba and \n\nChoclo under the hood. To do so, we need to have \n\nChoclo installed.\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-forward-simulation","position":25},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-data-misfit","position":26},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(data=data_object, simulation=simulation_L2)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-data-misfit","position":27},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-regularization","position":28},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource. Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Here, length scales along x, y and z are used to balance the smallness and smoothness terms. And the reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    tensor_mesh,\n    active_cells=active_tensor_cells,\n    length_scale_x=1.0,\n    length_scale_y=1.0,\n    length_scale_z=1.0,\n    reference_model=reference_tensor_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-regularization","position":29},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-optimization-algorithm","position":30},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Here, we use the \n\nInexactGaussNewton class to solve the optimization problem using inexact Gauss-Newton. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches.\n\nopt_L2 = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=10, tolCG=1e-2\n)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-optimization-algorithm","position":31},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-inverse-problem","position":32},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-inverse-problem","position":33},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#provide-inversion-directives","position":34},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Directives represent operations that are carried out during the inversion. Here, we apply common directives for weighted least-squares inversion of gravity data and describe their roles. These are:\n\nUpdateSensitivityWeights: Apply sensitivity weighting to counteract the natural tendancy of potential field inversion to cluster recovered structures near the receivers. Because the 3D integral formulation is linear, the sensitivity weighting is independent of the model and does not need to be updated throughout the inversion, so we set every_iteration=False.\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nsensitivity_weights = directives.UpdateSensitivityWeights(every_iteration=False)\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=10)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=1)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [\n    sensitivity_weights,\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-gravity-anomaly-3d#provide-inversion-directives","position":35},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-and-run-the-inversion","position":36},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run inversion\nrecovered_tensor_model = inv_L2.run(starting_tensor_model)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-and-run-the-inversion","position":37},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#plot-the-data-misfit","position":38},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"This step is necessary for determining whether the recovered model accurately reproduces observed anomalies. Here, we plot the observed data, predicted data for the recovered model, and the misfit. As we can see, the predicted data fits the background somewhat better than the anomalies. As a result, you may reassign smaller uncertainties in these areas and re-run the inversion in order to better fit the anomalies. We will do this for the iteratively reweighted least-squares inversion.\n\n# Predicted data with final recovered model.\ndpred = inv_prob_L2.dpred\n\n# Observed data | Predicted data | Data misfit\ndata_array = np.c_[dobs, dpred, dobs - dpred]\n\nfig = plt.figure(figsize=(12, 5))\nplot_title = [\"Observed\", \"Predicted\", \"Data Misfit\"]\nplot_units = [\"mGal\", \"mGal\", \"mGal\"]\n\nax1 = 3 * [None]\nax2 = 3 * [None]\nnorm = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\nv_lim = [np.max(np.abs(dobs)), np.max(np.abs(dobs)), np.max(np.abs(dobs - dpred))]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.3 * ii + 0.1, 0.2, 0.27, 0.75])\n    norm[ii] = mpl.colors.Normalize(vmin=-v_lim[ii], vmax=v_lim[ii])\n    cplot[ii] = plot2Ddata(\n        receiver_list[0].locations,\n        data_array[:, ii],\n        ax=ax1[ii],\n        ncontour=30,\n        contourOpts={\"cmap\": \"bwr\", \"norm\": norm[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    if ii == 0:\n        ax1[ii].set_ylabel(\"y (m)\")\n    else:\n        ax1[ii].set_yticks([])\n\n    ax2[ii] = fig.add_axes([0.3 * ii + 0.1, 0.05, 0.27, 0.05])\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm[ii], orientation=\"horizontal\", cmap=mpl.cm.bwr\n    )\n    cbar[ii].ax.locator_params(nbins=3)\n    cbar[ii].set_label(plot_units[ii], labelpad=5)\n\nplt.show()\n\n","type":"content","url":"/inv-gravity-anomaly-3d#plot-the-data-misfit","position":39},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#plot-the-recovered-model","position":40},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"As we can see, weighted least-squares regularization leads to the recovery of smooth models. And even with sensitivity weighting, there is a tendancy for gravity anomaly inversion to place recovered structures near the Earth’s surface.\n\n# Plot Recovered Model\nfig = plt.figure(figsize=(7, 3))\nax1 = fig.add_axes([0.1, 0.1, 0.73, 0.8])\n\nnorm = mpl.colors.Normalize(\n    vmin=np.min(recovered_tensor_model), vmax=np.max(recovered_tensor_model)\n)\ntensor_mesh.plot_slice(\n    tensor_plotting_map * recovered_tensor_model,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(tensor_mesh.shape_cells[1] / 2),\n    grid=False,\n    pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": norm},\n)\nax1.set_title(\"Model slice at y = 0 m\")\n\nax2 = fig.add_axes([0.85, 0.1, 0.03, 0.8])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(\"$g/cm^3$\", rotation=270, labelpad=15, size=16)\n\nplt.show()\n\n","type":"content","url":"/inv-gravity-anomaly-3d#plot-the-recovered-model","position":41},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#iteratively-re-weighted-least-squares-irls-inversion-on-a-tree-mesh","position":42},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"Here, we provide a step-by-step best-practices approach for iteratively IRLS inversion of gravity anomaly data on a tree mesh. Many of the steps are the same as our previous approach. As a result, we will avoid repeating information whenever possible. For the tutorial example, any datum whose normalized data misfit is outside of (-2, 2) will have its uncertainty decreased by a factor of 2.5. This choice was problem dependent!\n\n","type":"content","url":"/inv-gravity-anomaly-3d#iteratively-re-weighted-least-squares-irls-inversion-on-a-tree-mesh","position":43},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Reassign the Uncertainties","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#reassign-the-uncertainties","position":44},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Reassign the Uncertainties","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"Prior to performing the IRLS inversion, we decrease the uncertainties at the locations we observed the largest data misfits. Here, our goal is to recover a model that better fits the anomalies.\n\n# Compute normalized data misfits\nnormalized_data_misfits = (dobs - dpred) / uncertainties\n\n# Plot the normalized data misfits\nfig = plt.figure(figsize=(6, 3))\nax = fig.add_subplot(111)\nax.plot(np.sort(normalized_data_misfits))\nax.set_title(\"Normalized Data Misfits (sorted)\")\nax.grid()\nplt.show(fig)\n\n# Generate new uncertainties\nnew_uncertainties = uncertainties.copy()\nnew_uncertainties[np.abs(normalized_data_misfits) > 2.0] /= 2.5\n\n# Generate new data object\nnew_data_object = data.Data(survey, dobs=dobs, standard_deviation=new_uncertainties)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#reassign-the-uncertainties","position":45},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Design a (Tree) Mesh","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#design-a-tree-mesh","position":46},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Design a (Tree) Mesh","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"Here, we design a \n\ntree mesh. See the \n\ndiscretize user tutorials to learn more about creating tree meshes. The same approach used to construct the tensor mesh used in the weighted least-squares inversion example applies to tree meshes.\n\ndx = 5  # minimum cell width (base tree_mesh cell width) in x\ndy = 5  # minimum cell width (base tree_mesh cell width) in y\ndz = 5  # minimum cell width (base tree_mesh cell width) in z\n\nx_length = 240.0  # domain width in x\ny_length = 240.0  # domain width in y\nz_length = 120.0  # domain width in z\n\n# Compute number of base tree_mesh cells required in x and y\nnbcx = 2 ** int(np.round(np.log(x_length / dx) / np.log(2.0)))\nnbcy = 2 ** int(np.round(np.log(y_length / dy) / np.log(2.0)))\nnbcz = 2 ** int(np.round(np.log(z_length / dz) / np.log(2.0)))\n\n# Define the base tree_mesh\nhx = [(dx, nbcx)]\nhy = [(dy, nbcy)]\nhz = [(dz, nbcz)]\ntree_mesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift vertically to top same as maximum topography\ntree_mesh.origin += np.r_[0.0, 0.0, topo_xyz[:, -1].max()]\n\n# Refine based on surface topography\ntree_mesh.refine_surface(topo_xyz, padding_cells_by_level=[2, 2], finalize=False)\n\n# Refine box based on region of interest\nwsb_corner = np.c_[-100, -100, 20]\nent_corner = np.c_[100, 100, 100]\n# Note -1 is a flag for smallest cell size\ntree_mesh.refine_box(wsb_corner, ent_corner, levels=[-1], finalize=False)\n\ntree_mesh.finalize()\n\n","type":"content","url":"/inv-gravity-anomaly-3d#design-a-tree-mesh","position":47},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Active Cells","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-active-cells-1","position":48},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Active Cells","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"\n\nactive_tree_cells = active_from_xyz(tree_mesh, topo_xyz)\nn_tree_active = int(active_tree_cells.sum())\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-active-cells-1","position":49},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Mapping from Model to Active Cells","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#mapping-from-model-to-active-cells","position":50},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Mapping from Model to Active Cells","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"\n\ntree_model_map = maps.IdentityMap(nP=n_tree_active)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#mapping-from-model-to-active-cells","position":51},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Starting and Reference Models","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#starting-and-reference-models","position":52},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Starting and Reference Models","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"\n\nstarting_tree_model = 1e-6 * np.ones(n_tree_active)\nreference_tree_model = np.zeros_like(starting_tree_model)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#starting-and-reference-models","position":53},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-forward-simulation-1","position":54},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"\n\nsimulation_irls = gravity.simulation.Simulation3DIntegral(\n    survey=survey, mesh=tree_mesh, rhoMap=tree_model_map, active_cells=active_tree_cells\n)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-forward-simulation-1","position":55},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-data-misfit","position":56},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"\n\ndmis_irls = data_misfit.L2DataMisfit(data=new_data_object, simulation=simulation_irls)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-data-misfit","position":57},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-regularization-1","position":58},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"Here, we use the \n\nSparse regularization class to constrain the inversion result using an IRLS approach. Here, the scaling constants that balance the smallness and smoothness terms are set directly. Equal emphasis on smallness and smoothness is generally applied by using the inverse square of the smallest cell dimension. The reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros. Here, we apply a 0-norm to the smallness term and a 1-norm to first-order smoothness along the x, y and z directions.\n\nreg_irls = regularization.Sparse(\n    tree_mesh,\n    active_cells=active_tree_cells,\n    alpha_s=dh**-2,\n    alpha_x=1,\n    alpha_y=1,\n    alpha_z=1,\n    reference_model=reference_tree_model,\n    reference_model_in_smooth=False,\n    norms=[0, 1, 1, 1],\n)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-regularization-1","position":59},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-optimization-algorithm-1","position":60},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"Here, we use the \n\nProjectedGNCG class to solve the optimization problem using projected Gauss-Newton conjugate gradient. This opimization class allows the user to set upper and lower bounds for the recovered model using the upper and lower properties.\n\nopt_irls = optimization.ProjectedGNCG(\n    maxIter=100, lower=-1.0, upper=1.0, maxIterLS=20, maxIterCG=10, tolCG=1e-2\n)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-optimization-algorithm-1","position":61},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-the-inverse-problem-1","position":62},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"\n\ninv_prob_irls = inverse_problem.BaseInvProblem(dmis_irls, reg_irls, opt_irls)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-the-inverse-problem-1","position":63},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#provide-inversion-directives-1","position":64},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"Here, we create common directives for IRLS inversion of gravity data and describe their roles. In additon to the \n\nUpdateSensitivityWeights, \n\nUpdatePreconditioner and \n\nBetaEstimate_ByEig  (described before), inversion with sparse-norms requires the \n\nUpdateIRLS directive.\n\nYou will notice that we don’t use the \n\nBetaSchedule and \n\nTargetMisfit directives. Here, the beta cooling schedule is set in the \n\nUpdateIRLS directive using the coolingFactor and coolingRate properties. The target misfit for the L2 portion of the IRLS approach is set with the chifact_start property.\n\nsensitivity_weights_irls = directives.UpdateSensitivityWeights(every_iteration=False)\nstarting_beta_irls = directives.BetaEstimate_ByEig(beta0_ratio=10)\nupdate_jacobi_irls = directives.UpdatePreconditioner(update_every_iteration=True)\nupdate_irls = directives.UpdateIRLS(\n    cooling_factor=2,\n    cooling_rate=1,\n    chifact_start=1.0,\n    f_min_change=1e-4,\n    max_irls_iterations=25,\n)\n\ndirectives_list_irls = [\n    update_irls,\n    sensitivity_weights_irls,\n    starting_beta_irls,\n    update_jacobi_irls,\n]\n\n","type":"content","url":"/inv-gravity-anomaly-3d#provide-inversion-directives-1","position":65},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#define-and-run-the-inversion-1","position":66},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"\n\ninv_irls = inversion.BaseInversion(inv_prob_irls, directives_list_irls)\nrecovered_tree_model = inv_irls.run(starting_tree_model)\n\n","type":"content","url":"/inv-gravity-anomaly-3d#define-and-run-the-inversion-1","position":67},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Plot the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"type":"lvl3","url":"/inv-gravity-anomaly-3d#plot-the-data-misfit-1","position":68},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl3":"Plot the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares (IRLS) Inversion on a Tree Mesh"},"content":"Here we plot the observed data, predicted and misfit for the IRLS inversion. As we can see from the misfit map, the observed data is now fit equally at all locations.\n\n# Predicted data with final recovered model.\ndpred_new = inv_prob_irls.dpred\n\n# Observed data | Predicted data | Data misfit\ndata_array = np.c_[dobs, dpred_new, dobs - dpred_new]\n\nfig = plt.figure(figsize=(12, 5))\nplot_title = [\"Observed\", \"Predicted\", \"Data Misfit\"]\nplot_units = [\"mGal\", \"mGal\", \"mGal\"]\n\nax1 = 3 * [None]\nax2 = 3 * [None]\nnorm = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\nv_lim = [np.max(np.abs(dobs)), np.max(np.abs(dobs)), np.max(np.abs(dobs - dpred_new))]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.3 * ii + 0.1, 0.2, 0.27, 0.75])\n    norm[ii] = mpl.colors.Normalize(vmin=-v_lim[ii], vmax=v_lim[ii])\n    cplot[ii] = plot2Ddata(\n        receiver_list[0].locations,\n        data_array[:, ii],\n        ax=ax1[ii],\n        ncontour=30,\n        contourOpts={\"cmap\": \"bwr\", \"norm\": norm[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    if ii == 0:\n        ax1[ii].set_ylabel(\"y (m)\")\n    else:\n        ax1[ii].set_yticks([])\n\n    ax2[ii] = fig.add_axes([0.3 * ii + 0.1, 0.05, 0.27, 0.05])\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm[ii], orientation=\"horizontal\", cmap=mpl.cm.bwr\n    )\n    cbar[ii].ax.locator_params(nbins=3)\n    cbar[ii].set_label(plot_units[ii], labelpad=5)\n\nplt.show()\n\n","type":"content","url":"/inv-gravity-anomaly-3d#plot-the-data-misfit-1","position":69},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Plot True, L2 and IRLS Models"},"type":"lvl2","url":"/inv-gravity-anomaly-3d#plot-true-l2-and-irls-models","position":70},{"hierarchy":{"lvl1":"3D Inversion of Gravity Anomaly Data","lvl2":"Plot True, L2 and IRLS Models"},"content":"Here, we compare the models recovered from weighted least-squares and iteratively re-weighted least-squares inversion to the true model.\n\n# Recreate True Model on a Tensor Mesh\nbackground_density = 0.0\nblock_density = -0.2\nsphere_density = 0.2\n\ntrue_model = background_density * np.ones(n_tensor_active)\n\nind_block = model_builder.get_indices_block(\n    [-50, -15, 50], [-20, 15, 70], tensor_mesh.cell_centers[active_tensor_cells]\n)\ntrue_model[ind_block] = block_density\n\nind_sphere = model_builder.get_indices_sphere(\n    np.r_[35.0, 0.0, 60.0], 14.0, tensor_mesh.cell_centers[active_tensor_cells]\n)\ntrue_model[ind_sphere] = sphere_density\n\n# Plot all models\nmesh_list = [tensor_mesh, tensor_mesh, tree_mesh]\nind_list = [active_tensor_cells, active_tensor_cells, active_tree_cells]\nmodel_list = [true_model, recovered_tensor_model, recovered_tree_model]\ntitle_list = [\"True Model\", \"L2 Tensor Model\", \"IRLS Tree Model\"]\ncplot = 3 * [None]\ncbar = 3 * [None]\nnorm = 3 * [None]\n\nfig = plt.figure(figsize=(7, 8))\nax1 = [fig.add_axes([0.1, 0.7 - 0.3 * ii, 0.75, 0.23]) for ii in range(0, 3)]\nax2 = [fig.add_axes([0.88, 0.7 - 0.3 * ii, 0.025, 0.23]) for ii in range(0, 3)]\n\nfor ii, mesh in enumerate(mesh_list):\n    plotting_map = maps.InjectActiveCells(mesh, ind_list[ii], np.nan)\n    max_abs = np.max(np.abs(model_list[ii]))\n    norm[ii] = mpl.colors.Normalize(vmin=-max_abs, vmax=max_abs)\n\n    cplot[ii] = mesh.plot_slice(\n        plotting_map * model_list[ii],\n        normal=\"Y\",\n        ax=ax1[ii],\n        ind=int(mesh.shape_cells[1] / 2),\n        grid=False,\n        pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": norm[ii]},\n    )\n    ax1[ii].set_xlim([-150, 150])\n    ax1[ii].set_ylim([topo_xyz[:, -1].max() - 100, topo_xyz[:, -1].max()])\n    if ii < 2:\n        ax1[ii].set_xlabel(\"\")\n        ax1[ii].set_xticks([])\n    ax1[ii].set_title(title_list[ii])\n\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm[ii], orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n    )\n    cbar[ii].set_label(\"$g/cm^3$\", labelpad=0)","type":"content","url":"/inv-gravity-anomaly-3d#plot-true-l2-and-irls-models","position":71},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data"},"type":"lvl1","url":"/weighting-strategies","position":0},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nHere we invert gravity anomaly data to recover a density contrast model. We formulate the inverse problem as an iteratively\nre-weighted least-squares (IRLS) optimization problem. For this tutorial, we\nfocus on the following:\n\nSetting regularization weights\n\nDefining the survey from xyz formatted data\n\nGenerating a mesh based on survey geometry\n\nIncluding surface topography\n\nDefining the inverse problem (data misfit, regularization, optimization)\n\nSpecifying directives for the inversion\n\nSetting sparse and blocky norms\n\nPlotting the recovered model and data misfit\n\nAlthough we consider gravity anomaly data in this tutorial, the same approach\ncan be used to invert gradiometry and other types of geophysical data.\n\n","type":"content","url":"/weighting-strategies","position":1},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Import modules"},"type":"lvl2","url":"/weighting-strategies#import-modules","position":2},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Import modules"},"content":"\n\nimport os\nimport tarfile\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom discretize import TensorMesh\nfrom discretize.utils import active_from_xyz\n\nfrom simpeg import (\n    data,\n    data_misfit,\n    directives,\n    inverse_problem,\n    inversion,\n    maps,\n    optimization,\n    regularization,\n    utils,\n)\nfrom simpeg.potential_fields import gravity\nfrom simpeg.utils import model_builder, plot2Ddata\n\n","type":"content","url":"/weighting-strategies#import-modules","position":3},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Define File Names"},"type":"lvl2","url":"/weighting-strategies#define-file-names","position":4},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Define File Names"},"content":"File paths for assets we are loading. To set up the inversion, we require\ntopography and field observations. The true model defined on the whole mesh\nis loaded to compare with the inversion result. These files are stored as a\ntar-file on our google cloud bucket:\n“\n\nhttps://​storage​.googleapis​.com​/simpeg​/doc​-assets​/gravity​.tar​.gz”\n\n# storage bucket where we have the data\ndata_source = \"https://storage.googleapis.com/simpeg/doc-assets/gravity.tar.gz\"\n\n# download the data\ndownloaded_data = utils.download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"gravity_topo.txt\"\ndata_filename = dir_path + \"gravity_data.obs\"\n\n","type":"content","url":"/weighting-strategies#define-file-names","position":5},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Load Data and Plot"},"type":"lvl2","url":"/weighting-strategies#load-data-and-plot","position":6},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Load Data and Plot"},"content":"Here we load and plot synthetic gravity anomaly data. Topography is generally\ndefined as an (N, 3) array. Gravity data is generally defined with 4 columns:\nx, y, z and data.\n\n# Load topography\nxyz_topo = np.loadtxt(str(topo_filename))\n\n# Load field data\ndobs = np.loadtxt(str(data_filename))\n\n# Define receiver locations and observed data\nreceiver_locations = dobs[:, 0:3]\ndobs = dobs[:, -1]\n\n# Plot\nmpl.rcParams.update({\"font.size\": 12})\nfig = plt.figure(figsize=(7, 5))\n\nax1 = fig.add_axes([0.1, 0.1, 0.73, 0.85])\nplot2Ddata(\n    receiver_locations,\n    dobs,\n    ax=ax1,\n    contourOpts={\"cmap\": \"bwr\"},\n    shade=True,\n    nx=20,\n    ny=20,\n    dataloc=True,\n)\nax1.set_title(\"Gravity Anomaly\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\n\nax2 = fig.add_axes([0.8, 0.1, 0.03, 0.85])\nnorm = mpl.colors.Normalize(vmin=-np.max(np.abs(dobs)), vmax=np.max(np.abs(dobs)))\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.bwr, format=\"%.1e\"\n)\ncbar.set_label(\"$mGal$\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/weighting-strategies#load-data-and-plot","position":7},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/weighting-strategies#assign-uncertainties","position":8},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Assign Uncertainties"},"content":"Inversion with simpeg requires that we define the standard deviation of our data.\nThis represents our estimate of the noise in our data. For a gravity inversion,\na constant floor value is generally applied to all data. For this tutorial,\nthe standard deviation on each datum will be 1% of the maximum observed\ngravity anomaly value.\n\nmaximum_anomaly = np.max(np.abs(dobs))\n\nuncertainties = 0.01 * maximum_anomaly * np.ones(np.shape(dobs))\n\n","type":"content","url":"/weighting-strategies#assign-uncertainties","position":9},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Defining the Survey"},"type":"lvl2","url":"/weighting-strategies#defining-the-survey","position":10},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Defining the Survey"},"content":"Here, we define the survey that will be used for this tutorial. Gravity\nsurveys are simple to create. The user only needs an (N, 3) array to define\nthe xyz locations of the observation locations. From this, the user can\ndefine the receivers and the source field.\n\n# Define the receivers. The data consists of vertical gravity anomaly measurements.\n# The set of receivers must be defined as a list.\nreceiver_list = gravity.receivers.Point(receiver_locations, components=\"gz\")\n\nreceiver_list = [receiver_list]\n\n# Define the source field\nsource_field = gravity.sources.SourceField(receiver_list=receiver_list)\n\n# Define the survey\nsurvey = gravity.survey.Survey(source_field)\n\n","type":"content","url":"/weighting-strategies#defining-the-survey","position":11},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Defining the Data"},"type":"lvl2","url":"/weighting-strategies#defining-the-data","position":12},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Defining the Data"},"content":"Here is where we define the data that is inverted. The data is defined by\nthe survey, the observation values and the standard deviation.\n\ndata_object = data.Data(survey, dobs=dobs, standard_deviation=uncertainties)\n\n","type":"content","url":"/weighting-strategies#defining-the-data","position":13},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Defining a Tensor Mesh"},"type":"lvl2","url":"/weighting-strategies#defining-a-tensor-mesh","position":14},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Defining a Tensor Mesh"},"content":"Here, we create the tensor mesh that will be used to invert gravity anomaly\ndata. If desired, we could define an OcTree mesh.\n\ndh = 5.0\nhx = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhy = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhz = [(dh, 5, -1.3), (dh, 15)]\nmesh = TensorMesh([hx, hy, hz], \"CCN\")\n\n","type":"content","url":"/weighting-strategies#defining-a-tensor-mesh","position":15},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Starting/Reference Model and Mapping on Tensor Mesh"},"type":"lvl2","url":"/weighting-strategies#starting-reference-model-and-mapping-on-tensor-mesh","position":16},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Starting/Reference Model and Mapping on Tensor Mesh"},"content":"Here, we create starting and/or reference models for the inversion as\nwell as the mapping from the model space to the active cells. Starting and\nreference models can be a constant background value or contain a-priori\nstructures.\n\n# Find the indices of the active cells in forward model (ones below surface)\nind_active = active_from_xyz(mesh, xyz_topo)\n\n# Define mapping from model to active cells\nnC = int(ind_active.sum())\nmodel_map = maps.IdentityMap(nP=nC)  # model consists of a value for each active cell\n\n# Define and plot starting model\nstarting_model = np.zeros(nC)\n\n","type":"content","url":"/weighting-strategies#starting-reference-model-and-mapping-on-tensor-mesh","position":17},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Define the Physics and data misfit"},"type":"lvl2","url":"/weighting-strategies#define-the-physics-and-data-misfit","position":18},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Define the Physics and data misfit"},"content":"Here, we define the physics of the gravity problem by using the simulation\nclass.\n\nsimulation = gravity.simulation.Simulation3DIntegral(\n    survey=survey, mesh=mesh, rhoMap=model_map, active_cells=ind_active\n)\n\n# Define the data misfit. Here the data misfit is the L2 norm of the weighted\n# residual between the observed data and the data predicted for a given model.\n# Within the data misfit, the residual between predicted and observed data are\n# normalized by the data's standard deviation.\ndmis = data_misfit.L2DataMisfit(data=data_object, simulation=simulation)\n\n","type":"content","url":"/weighting-strategies#define-the-physics-and-data-misfit","position":19},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Running the Depth Weighted inversion"},"type":"lvl2","url":"/weighting-strategies#running-the-depth-weighted-inversion","position":20},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Running the Depth Weighted inversion"},"content":"Here we define the directives, weights, regularization, and optimization\nfor a depth-weighted inversion\n\n# inversion directives\n# Defining a starting value for the trade-off parameter (beta) between the data\n# misfit and the regularization.\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=1e0)\n\n# Defines the directives for the IRLS regularization. This includes setting\n# the cooling schedule for the trade-off parameter.\nupdate_IRLS = directives.UpdateIRLS(\n    f_min_change=1e-4,\n    max_irls_iterations=30,\n    irls_cooling_factor=1.5,\n    misfit_tolerance=1e-2,\n)\n\n# Options for outputting recovered models and predicted data for each beta.\nsave_iteration = directives.SaveOutputEveryIteration(save_txt=False)\n\n# Updating the preconditionner if it is model dependent.\nupdate_jacobi = directives.UpdatePreconditioner()\n\n# The directives are defined as a list\ndirectives_list = [\n    update_IRLS,\n    starting_beta,\n    save_iteration,\n    update_jacobi,\n]\n\n# Define the regularization (model objective function) with depth weighting.\nreg_dpth = regularization.Sparse(mesh, active_cells=ind_active, mapping=model_map)\nreg_dpth.norms = [0, 2, 2, 2]\ndepth_weights = utils.depth_weighting(\n    mesh, receiver_locations, active_cells=ind_active, exponent=2\n)\nreg_dpth.set_weights(depth_weights=depth_weights)\n\n# Define how the optimization problem is solved. Here we will use a projected\n# Gauss-Newton approach that employs the conjugate gradient solver.\nopt = optimization.ProjectedGNCG(\n    maxIter=100, lower=-1.0, upper=1.0, maxIterLS=20, maxIterCG=10, tolCG=1e-3\n)\n\n# Here we define the inverse problem that is to be solved\ninv_prob = inverse_problem.BaseInvProblem(dmis, reg_dpth, opt)\n\n# Here we combine the inverse problem and the set of directives\ninv = inversion.BaseInversion(inv_prob, directives_list)\n\n# Run inversion\nrecovered_model_dpth = inv.run(starting_model)\n\n","type":"content","url":"/weighting-strategies#running-the-depth-weighted-inversion","position":21},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Running the Distance Weighted inversion"},"type":"lvl2","url":"/weighting-strategies#running-the-distance-weighted-inversion","position":22},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Running the Distance Weighted inversion"},"content":"Here we define the directives, weights, regularization, and optimization\nfor a distance-weighted inversion\n\n# inversion directives\n# Defining a starting value for the trade-off parameter (beta) between the data\n# misfit and the regularization.\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=1e0)\n\n# Defines the directives for the IRLS regularization. This includes setting\n# the cooling schedule for the trade-off parameter.\nupdate_IRLS = directives.UpdateIRLS(\n    f_min_change=1e-4,\n    max_irls_iterations=30,\n    irls_cooling_factor=1.5,\n    misfit_tolerance=1e-2,\n)\n\n# Options for outputting recovered models and predicted data for each beta.\nsave_iteration = directives.SaveOutputEveryIteration(save_txt=False)\n\n# Updating the preconditionner if it is model dependent.\nupdate_jacobi = directives.UpdatePreconditioner()\n\n# The directives are defined as a list\ndirectives_list = [\n    update_IRLS,\n    starting_beta,\n    save_iteration,\n    update_jacobi,\n]\n\n# Define the regularization (model objective function) with distance weighting.\nreg_dist = regularization.Sparse(mesh, active_cells=ind_active, mapping=model_map)\nreg_dist.norms = [0, 2, 2, 2]\ndistance_weights = utils.distance_weighting(\n    mesh, receiver_locations, active_cells=ind_active, exponent=2\n)\nreg_dist.set_weights(distance_weights=distance_weights)\n\n# Define how the optimization problem is solved. Here we will use a projected\n# Gauss-Newton approach that employs the conjugate gradient solver.\nopt = optimization.ProjectedGNCG(\n    maxIter=100, lower=-1.0, upper=1.0, maxIterLS=20, maxIterCG=10, tolCG=1e-3\n)\n\n# Here we define the inverse problem that is to be solved\ninv_prob = inverse_problem.BaseInvProblem(dmis, reg_dist, opt)\n\n# Here we combine the inverse problem and the set of directives\ninv = inversion.BaseInversion(inv_prob, directives_list)\n\n# Run inversion\nrecovered_model_dist = inv.run(starting_model)\n\n","type":"content","url":"/weighting-strategies#running-the-distance-weighted-inversion","position":23},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Running the Distance Weighted inversion"},"type":"lvl2","url":"/weighting-strategies#running-the-distance-weighted-inversion-1","position":24},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Running the Distance Weighted inversion"},"content":"Here we define the directives, weights, regularization, and optimization\nfor a sensitivity weighted inversion\n\n# inversion directives\n# Defining a starting value for the trade-off parameter (beta) between the data\n# misfit and the regularization.\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=1e0)\n\n# Defines the directives for the IRLS regularization. This includes setting\n# the cooling schedule for the trade-off parameter.\nupdate_IRLS = directives.UpdateIRLS(\n    f_min_change=1e-4,\n    max_irls_iterations=30,\n    irls_cooling_factor=1.5,\n    misfit_tolerance=1e-2,\n)\n\n# Options for outputting recovered models and predicted data for each beta.\nsave_iteration = directives.SaveOutputEveryIteration(save_txt=False)\n\n# Updating the preconditionner if it is model dependent.\nupdate_jacobi = directives.UpdatePreconditioner()\n\n# Add sensitivity weights\nsensitivity_weights = directives.UpdateSensitivityWeights(every_iteration=False)\n\n# The directives are defined as a list\ndirectives_list = [\n    update_IRLS,\n    sensitivity_weights,\n    starting_beta,\n    save_iteration,\n    update_jacobi,\n]\n\n# Define the regularization (model objective function) for sensitivity weighting.\nreg_sensw = regularization.Sparse(mesh, active_cells=ind_active, mapping=model_map)\nreg_sensw.norms = [0, 2, 2, 2]\n\n# Define how the optimization problem is solved. Here we will use a projected\n# Gauss-Newton approach that employs the conjugate gradient solver.\nopt = optimization.ProjectedGNCG(\n    maxIter=100, lower=-1.0, upper=1.0, maxIterLS=20, maxIterCG=10, tolCG=1e-3\n)\n\n# Here we define the inverse problem that is to be solved\ninv_prob = inverse_problem.BaseInvProblem(dmis, reg_sensw, opt)\n\n# Here we combine the inverse problem and the set of directives\ninv = inversion.BaseInversion(inv_prob, directives_list)\n\n# Run inversion\nrecovered_model_sensw = inv.run(starting_model)\n\n","type":"content","url":"/weighting-strategies#running-the-distance-weighted-inversion-1","position":25},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Recreate True Model"},"type":"lvl2","url":"/weighting-strategies#recreate-true-model","position":26},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Recreate True Model"},"content":"\n\n# Define density contrast values for each unit in g/cc\nbackground_density = 0.0\nblock_density = -0.2\nsphere_density = 0.2\n\n# Define model. Models in simpeg are vector arrays.\ntrue_model = background_density * np.ones(nC)\n\n# You could find the indicies of specific cells within the model and change their\n# value to add structures.\nind_block = (\n    (mesh.gridCC[ind_active, 0] > -50.0)\n    & (mesh.gridCC[ind_active, 0] < -20.0)\n    & (mesh.gridCC[ind_active, 1] > -15.0)\n    & (mesh.gridCC[ind_active, 1] < 15.0)\n    & (mesh.gridCC[ind_active, 2] > -50.0)\n    & (mesh.gridCC[ind_active, 2] < -30.0)\n)\ntrue_model[ind_block] = block_density\n\n# You can also use simpeg utilities to add structures to the model more concisely\nind_sphere = model_builder.get_indices_sphere(\n    np.r_[35.0, 0.0, -40.0], 15.0, mesh.gridCC\n)\nind_sphere = ind_sphere[ind_active]\ntrue_model[ind_sphere] = sphere_density\n\n","type":"content","url":"/weighting-strategies#recreate-true-model","position":27},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Plotting True Model and Recovered Models"},"type":"lvl2","url":"/weighting-strategies#plotting-true-model-and-recovered-models","position":28},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Plotting True Model and Recovered Models"},"content":"\n\n# Plot Models\nfig, ax = plt.subplots(2, 2, figsize=(20, 10), sharex=True, sharey=True)\nax = ax.flatten()\nplotting_map = maps.InjectActiveCells(mesh, ind_active, np.nan)\ncmap = \"coolwarm\"\nslice_y_loc = 0.0\n\nmm = mesh.plot_slice(\n    plotting_map * true_model,\n    normal=\"Y\",\n    ax=ax[0],\n    grid=False,\n    slice_loc=slice_y_loc,\n    pcolor_opts={\"cmap\": cmap, \"norm\": norm},\n)\nax[0].set_title(f\"True model slice at y = {slice_y_loc} m\")\nplt.colorbar(mm[0], label=\"$g/cm^3$\", ax=ax[0])\n\n# plot depth weighting result\nvmax = np.abs(recovered_model_dpth).max()\nnorm = mpl.colors.TwoSlopeNorm(vcenter=0, vmin=-vmax, vmax=vmax)\nmm = mesh.plot_slice(\n    plotting_map * recovered_model_dpth,\n    normal=\"Y\",\n    ax=ax[1],\n    grid=False,\n    slice_loc=slice_y_loc,\n    pcolor_opts={\"cmap\": cmap, \"norm\": norm},\n)\nax[1].set_title(f\"Depth weighting Model slice at y = {slice_y_loc} m\")\nplt.colorbar(mm[0], label=\"$g/cm^3$\", ax=ax[1])\n\n# plot distance weighting result\nvmax = np.abs(recovered_model_dist).max()\nnorm = mpl.colors.TwoSlopeNorm(vcenter=0, vmin=-vmax, vmax=vmax)\nmm = mesh.plot_slice(\n    plotting_map * recovered_model_dist,\n    normal=\"Y\",\n    ax=ax[2],\n    grid=False,\n    slice_loc=slice_y_loc,\n    pcolor_opts={\"cmap\": cmap, \"norm\": norm},\n)\nax[2].set_title(f\"Distance weighting Model slice at y = {slice_y_loc} m\")\nplt.colorbar(mm[0], label=\"$g/cm^3$\", ax=ax[2])\n\n# plot sensitivity weighting result\nvmax = np.abs(recovered_model_sensw).max()\nnorm = mpl.colors.TwoSlopeNorm(vcenter=0, vmin=-vmax, vmax=vmax)\nmm = mesh.plot_slice(\n    plotting_map * recovered_model_sensw,\n    normal=\"Y\",\n    ax=ax[3],\n    grid=False,\n    slice_loc=slice_y_loc,\n    pcolor_opts={\"cmap\": cmap, \"norm\": norm},\n)\nax[3].set_title(f\"Sensitivity weighting Model slice at y = {slice_y_loc} m\")\nplt.colorbar(mm[0], label=\"$g/cm^3$\", ax=ax[3])\n\n# shared plotting\nplotting_map = maps.InjectActiveCells(mesh, ind_active, 0.0)\nslice_y_ind = (\n    mesh.cell_centers[:, 1] == np.abs(mesh.cell_centers[:, 1] - slice_y_loc).min()\n)\nfor axx in ax:\n    utils.plot2Ddata(\n        mesh.cell_centers[slice_y_ind][:, [0, 2]],\n        (plotting_map * true_model)[slice_y_ind],\n        contourOpts={\"alpha\": 0},\n        level=True,\n        ncontour=2,\n        levelOpts={\"colors\": \"grey\", \"linewidths\": 2, \"linestyles\": \"--\"},\n        method=\"nearest\",\n        ax=axx,\n    )\n    axx.set_aspect(1)\n\nplt.tight_layout()\n\n","type":"content","url":"/weighting-strategies#plotting-true-model-and-recovered-models","position":29},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Visualize weights"},"type":"lvl2","url":"/weighting-strategies#visualize-weights","position":30},{"hierarchy":{"lvl1":"Compare weighting strategy with Inversion of surface Gravity Anomaly Data","lvl2":"Visualize weights"},"content":"Plot Weights\n\nfig, ax = plt.subplots(1, 3, figsize=(20, 4), sharex=True, sharey=True)\nplotting_map = maps.InjectActiveCells(mesh, ind_active, np.nan)\ncmap = \"magma\"\nslice_y_loc = 0.0\n\n# plot depth weights\nmm = mesh.plot_slice(\n    plotting_map * np.log10(depth_weights),\n    normal=\"Y\",\n    ax=ax[0],\n    grid=False,\n    slice_loc=slice_y_loc,\n    pcolor_opts={\"cmap\": cmap},\n)\nax[0].set_title(f\"log10(depth weights) slice at y = {slice_y_loc} m\")\nplt.colorbar(mm[0], label=\"log10(depth weights)\", ax=ax[0])\n\n# plot distance weights\nmm = mesh.plot_slice(\n    plotting_map * np.log10(distance_weights),\n    normal=\"Y\",\n    ax=ax[1],\n    grid=False,\n    slice_loc=slice_y_loc,\n    pcolor_opts={\"cmap\": cmap},\n)\nax[1].set_title(f\"log10(distance weights) slice at y = {slice_y_loc} m\")\nplt.colorbar(mm[0], label=\"log10(distance weights)\", ax=ax[1])\n\n# plot sensitivity weights\nmm = mesh.plot_slice(\n    plotting_map * np.log10(reg_sensw.objfcts[0].get_weights(key=\"sensitivity\")),\n    normal=\"Y\",\n    ax=ax[2],\n    grid=False,\n    slice_loc=slice_y_loc,\n    pcolor_opts={\"cmap\": cmap},\n)\nax[2].set_title(f\"log10(sensitivity weights) slice at y = {slice_y_loc} m\")\nplt.colorbar(mm[0], label=\"log10(sensitivity weights)\", ax=ax[2])\n\n# shared plotting\nfor axx in ax:\n    axx.set_aspect(1)\n\nplt.tight_layout()","type":"content","url":"/weighting-strategies#visualize-weights","position":31},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data"},"type":"lvl1","url":"/fwd-magnetics-induced-3d","position":0},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: total magnetic intensity, forward simulation, integral formulation, tensor mesh.\n\nSummary: Here we use the module \n\nsimpeg​.potential​_fields​.magnetics to simulate total magnetic intensity data for a synthetic susceptibility model. We use the \n\n3D integral formulation and carry out the forward simulation on a tensor mesh. The integral formulation works well when magnetic susceptibilities are less than 0.1 SI. However when susceptibilities are sufficiently large, self-demagnetization becomes significant and the integral formulation is no longer accurate.\n\nLearning Objectives:\n\nHow to simulate magnetic data for 3D structures with SimPEG.\n\nHow to create magnetics surveys.\n\nHow to design tensor meshes for magnetic simulations using the integral formulation.\n\nHow to predict total magnetic intensity data for a susceptibility model.\n\nHow to include surface topography in the forward simulation.\n\nWhat are the units of the susceptibility model and resulting data.\n\n","type":"content","url":"/fwd-magnetics-induced-3d","position":1},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to simulating magnetic data are imported from \n\nsimpeg​.potential​_fields​.magnetics.\nWe also import some useful utility functions from \n\nsimpeg.utils. To simulate magnetic data, we need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we used the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.potential_fields import magnetics\nfrom simpeg.utils import plot2Ddata, model_builder\nfrom simpeg import maps\n\n# discretize functionality\nfrom discretize import TensorMesh\nfrom discretize.utils import mkvc, active_from_xyz\n\n# Common Python functionality\nimport numpy as np\nfrom scipy.interpolate import LinearNDInterpolator\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport os\n\nmpl.rcParams.update({\"font.size\": 14})\n\nsave_output = False  # Optional\n\n","type":"content","url":"/fwd-magnetics-induced-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#define-the-topography","position":4},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Topography"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray for 3D simulations.\nHere, we create basic topography for the forward simulation.\nFor user-specific simulations, you may load topography from an XYZ file.\n\n[x_topo, y_topo] = np.meshgrid(np.linspace(-200, 200, 41), np.linspace(-200, 200, 41))\nrng = np.random.default_rng(seed=737)\nz_topo = (\n    -15 * np.exp(-(x_topo**2 + y_topo**2) / 80**2)\n    + 100.0\n    + rng.uniform(low=0.0, high=0.5, size=x_topo.shape)\n)\n\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([z_topo.max() - 40, z_topo.max()])\nax.plot_surface(x_topo, y_topo, z_topo, color=\"r\", edgecolor=\"k\", linewidth=0.5)\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=20.0)\n\nx_topo, y_topo, z_topo = mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)\ntopo_xyz = np.c_[x_topo, y_topo, z_topo]\n\n","type":"content","url":"/fwd-magnetics-induced-3d#define-the-topography","position":5},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Survey"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#define-the-survey","position":6},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Survey"},"content":"Surveys within SimPEG generally require the user to create and connect three types of objects:\n\nreceivers: which define the locations of field measurements and type of data being measured.\n\nsources: the passive or active sources responsible for generating geophysical responses, and their associated receivers.\n\nsurvey: the object which stores and organizes all of the sources and receivers.\n\nHere, we define the survey that will be used for the forward simulation. Magnetic surveys are simple to create. The user only needs an (N, 3) \n\nnumpy.ndarray to define the xyz locations of the observation locations, the field components being measured, and the Earth’s inducing field. For the tutorial simulation, the receivers are located 10 m above the surface topography and spaced 10 m apart.\n\n# Define the observation locations as an (N, 3) numpy array or load them.\nx = np.linspace(-80.0, 80.0, 17)\ny = np.linspace(-80.0, 80.0, 17)\nx, y = np.meshgrid(x, y)\nx, y = mkvc(x.T), mkvc(y.T)\nfun_interp = LinearNDInterpolator(np.c_[x_topo, y_topo], z_topo)\nz = fun_interp(np.c_[x, y]) + 10  # Flight height 10 m above surface.\nreceiver_locations = np.c_[x, y, z]\n\n# Define the component(s) of the field we want to simulate as a list of strings.\n# Here we simulation total magnetic intensity data.\ncomponents = [\"tmi\"]\n\n# Use the observation locations and components to define the receivers. To\n# simulate data, the receivers must be defined as a list.\nreceiver_list = magnetics.receivers.Point(receiver_locations, components=components)\nreceiver_list = [receiver_list]\n\n# Define the inducing field\ninclination = 90  # inclination [deg]\ndeclination = 0  # declination [deg]\namplitude = 50000  # amplitude [nT]\n\nsource_field = magnetics.sources.UniformBackgroundField(\n    receiver_list=receiver_list,\n    amplitude=amplitude,\n    inclination=inclination,\n    declination=declination,\n)\n\n# Define the survey\nsurvey = magnetics.survey.Survey(source_field)\n\nIf desired, we can extract various objects and properties from the objects used to generate the survey. E.g.\n\nprint(\"# of data: {}\".format(survey.nD))  # number of data that will be simulated\nprint(survey.source_field.inclination)  # inclination of the source field\nprint(survey.source_field.receiver_list[0])  # the receiver object\nprint(receiver_list[0].locations[:5, :])  # the first 5 receiver locations\n\n","type":"content","url":"/fwd-magnetics-induced-3d#define-the-survey","position":7},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Design a (Tensor) Mesh"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#design-a-tensor-mesh","position":8},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Design a (Tensor) Mesh"},"content":"Meshes are designed using the \n\ndiscretize package. See the \n\ndiscretize user tutorials to learn more about creating meshes.\nHere, the forward simulation is computed for a \n\ntensor mesh. If you wanted to generate a \n\ntree mesh instead, you can use the code snippet from the \n\nForward simulation of magnetic gradiometry data tutorial.\n\nThe integral formulation for magnetics essentially sums the independent contribution for every magnetized voxel cell in the mesh. Since the kernel function that computes the contribution for a single cell is an analytic solution, small cells are not required to accurately compute the contributions from coarse structures with constant magnetization (e.g. a rectangular prism). For complex structures however, or to define surface topography more accurately, finer cells may be needed. Furthermore, cells do not need to be cubic. Since the analytic solution is only valid outside the magnetized region, please do no place receivers within the Earth.\n\nHere, a core cell width of 5 m is used within our survey region. Padding is used to extend the mesh outside the immediate survey area. The mesh will be plotted after we define our density contrast model.\n\n# Generate tensor mesh with top at z = 0 m\ndh = 5.0\nhx = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhy = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhz = [(dh, 5, -1.3), (dh, 15)]\nmesh = TensorMesh([hx, hy, hz], \"CCN\")\n\n# Shift vertically to top same as maximum topography\nmesh.origin += np.r_[0.0, 0.0, z_topo.max()]\n\nIf desired, we can extract various properties of the mesh. E.g.\n\nprint(\"# of cells: {}\".format(mesh.n_cells))  # Number of cells\nprint(\"# of x-faces: {}\".format(mesh.n_faces_x))  # Number of x-faces\nprint(\"Origin: {}\".format(mesh.origin))  # bottom-southewest corner\nprint(\"Max cell volume: {}\".format(mesh.cell_volumes.max()))  # Largest cell size\nprint(mesh.cell_centers[0:5, :])  # Cell center locations\n\n","type":"content","url":"/fwd-magnetics-induced-3d#design-a-tensor-mesh","position":9},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Active Cells"},"content":"Whereas cells below the Earth’s surface contribute towards the simulated magnetic anomaly, air cells do not.\nThe set of mesh cells used in the forward simulation are referred to as ‘active cells’. Unused cells (air cells) are ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n","type":"content","url":"/fwd-magnetics-induced-3d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Mapping from the Model to Active Cells"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#mapping-from-the-model-to-active-cells","position":12},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Mapping from the Model to Active Cells"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For example, the model may be defined as the logarithms of the physical property values, or be parameters defining a layered Earth. When simulating total magnetic intensity data using the integral formulation, we must define a mapping from the set of model parameters to the active cells in the mesh. Mappings are created using the \n\nsimpeg.maps module. For the tutorial exercise, the model is the susceptibility values for all active cells. As such, our mapping is an identity mapping, whose dimensions are equal to the number of active cells.\n\n# Define mapping from model to active cells. The model consists of a\n# susceptibility value for each cell below the Earth's surface.\nn_active = int(active_cells.sum())\nmodel_map = maps.IdentityMap(nP=n_active)\n\n","type":"content","url":"/fwd-magnetics-induced-3d#mapping-from-the-model-to-active-cells","position":13},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Model"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#define-the-model","position":14},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Model"},"content":"Here, we create the model that will be used to predict total magnetic intensity data.\nRecall that our model is the susceptibility values for all active mesh cells.\nSo the model is a 1D \n\nnumpy.ndarray whose length is\nequal to the number of model parameters.\nIn SimPEG, susceptibility values are in SI units.\nHere, the model consists of a susceptible sphere within a negligibly susceptible host.\nWe plot the model using the \n\nplot_slice method.\n\n# Define susceptibility values for each unit in SI\nbackground_susceptibility = 0.0001\nsphere_susceptibility = 0.01\n\n# Instantiate a vector array. Models in SimPEG are vector arrays.\nmodel = background_susceptibility * np.ones(n_active)\n\n# You can use SimPEG utilities to add structures to the model more concisely,\n# or index the mesh cells manually.\nind_sphere = model_builder.get_indices_sphere(\n    np.r_[0.0, 0.0, 55.0], 16.0, mesh.cell_centers\n)\nind_sphere = ind_sphere[active_cells]\nmodel[ind_sphere] = sphere_susceptibility\n\n# Mapping to ignore inactive cells when plotting model\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\n# Plot Susceptibility Model\nfig = plt.figure(figsize=(8, 3.5))\nax1 = fig.add_axes([0.1, 0.12, 0.73, 0.78])\n\nnorm = mpl.colors.Normalize(vmin=0, vmax=np.max(model))\nmesh.plot_slice(\n    plotting_map * model,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(mesh.shape_cells[1] / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n)\nax1.set_title(\"Model slice at y = 0 m\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.85, 0.12, 0.03, 0.78])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.plasma\n)\ncbar.set_label(\"$SI$\", rotation=270, labelpad=15, size=16)\n\nplt.show()\n\n","type":"content","url":"/fwd-magnetics-induced-3d#define-the-model","position":15},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#define-the-forward-simulation","position":16},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Define the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class.\nIn this case, we use the simulation class for the \n\n3D integral formulation. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe mesh\n\nthe indices of the active cells\n\nthe mapping from the model to the active cells\n\nthe model type: “scalar” for susceptibility model, “vector” for magnetic vector model\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object. Additional keyword arguments can also be set which impact the forward simulation. Because we are only simulating data for a single model, there is no benefit to storing the sensitivities for the forward simulation. store_sensitivities property to ‘forward_only’\n\nBy choosing engine=\"choclo\" we can make our simulation to run the faster and more memory efficient implementation of the magnetic forward that uses \n\nNumba and \n\nChoclo under the hood. To do so, we need to have \n\nChoclo installed.\n\nsimulation = magnetics.simulation.Simulation3DIntegral(\n    survey=survey,\n    mesh=mesh,\n    model_type=\"scalar\",\n    chiMap=model_map,\n    active_cells=active_cells,\n    store_sensitivities=\"forward_only\",\n    engine=\"choclo\",\n)\n\n","type":"content","url":"/fwd-magnetics-induced-3d#define-the-forward-simulation","position":17},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Simulate Total Magnetic Intensity Data"},"type":"lvl2","url":"/fwd-magnetics-induced-3d#simulate-total-magnetic-intensity-data","position":18},{"hierarchy":{"lvl1":"3D Forward Simulation of TMI Data","lvl2":"Simulate Total Magnetic Intensity Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. In SimPEG, total magnetic data values are in units nT.\n\ndpred = simulation.dpred(model)\n\nfig = plt.figure(figsize=(7, 5))\nax1 = fig.add_axes([0.1, 0.1, 0.75, 0.85])\n\nnorm = mpl.colors.Normalize(vmin=-np.max(np.abs(dpred)), vmax=np.max(np.abs(dpred)))\nplot2Ddata(\n    receiver_list[0].locations,\n    dpred,\n    ax=ax1,\n    ncontour=40,\n    contourOpts={\"cmap\": mpl.cm.bwr, \"norm\": norm},\n)\nax1.set_title(\"Total Magnetic Intensity\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\n\nax2 = fig.add_axes([0.81, 0.1, 0.04, 0.85])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.bwr\n)\ncbar.set_label(\"$SI$\", rotation=270, labelpad=20, size=16)\n\nplt.show()\n\nOptional: Export the data and topography\n\nif save_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_magnetics_induced_3d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    fname = dir_path + \"magnetics_topo.txt\"\n    np.savetxt(fname, np.c_[topo_xyz], fmt=\"%.4e\")\n\n    rng = np.random.default_rng(seed=211)\n    maximum_anomaly = np.max(np.abs(dpred))\n    noise = rng.normal(scale=0.02 * maximum_anomaly, size=len(dpred))\n    fname = dir_path + \"magnetics_data.obs\"\n    np.savetxt(fname, np.c_[receiver_locations, dpred + noise], fmt=\"%.4e\")","type":"content","url":"/fwd-magnetics-induced-3d#simulate-total-magnetic-intensity-data","position":19},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models"},"type":"lvl1","url":"/fwd-magnetics-mvi-3d","position":0},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: gradiometry, magnetic vector model, forward simulation, integral formulation, tree mesh.\n\nSummary: Here we use the module \n\nsimpeg​.potential​_fields​.magnetics to simulate magnetic gradiometry data for a magnetic vector model. We use the \n\n3D integral formulation and carry out the forward simulation on a tree mesh.\n\nLearning Objectives:\n\nHow to simulate magnetic data for 3D structures with SimPEG.\n\nHow to create magnetic gradiometry surveys; i.e. managing multiple data components.\n\nHow to design tensor meshes for magnetic simulations using the integral formulation.\n\nHow to construct a magnetic vector model.\n\nHow to predict magnetic gradiometry data for a magnetic vector model.\n\nHow to include surface topography in the forward simulation.\n\nWhat are the units of the magnetic vector model and resulting data.\n\n","type":"content","url":"/fwd-magnetics-mvi-3d","position":1},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to simulating magnetic data are imported from \n\nsimpeg​.potential​_fields​.magnetics.\nWe also import some useful utility functions from \n\nsimpeg.utils. To simulate magnetic data, we need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we used the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.potential_fields import magnetics\nfrom simpeg.utils import plot2Ddata, model_builder, mat_utils\nfrom simpeg import maps\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import mkvc, active_from_xyz\n\n# Common Python functionality\nimport numpy as np\nfrom scipy.interpolate import LinearNDInterpolator\nfrom scipy.constants import mu_0\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.rcParams.update({\"font.size\": 14})\n\nsave_output = False  # Optional\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#define-the-topography","position":4},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Topography"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray for 3D simulations.\nHere, we create basic topography for the forward simulation.\nFor user-specific simulations, you may load topography from an XYZ file.\n\n[x_topo, y_topo] = np.meshgrid(np.linspace(-200, 200, 41), np.linspace(-200, 200, 41))\nrng = np.random.default_rng(seed=42)\nz_topo = (\n    -15 * np.exp(-(x_topo**2 + y_topo**2) / 80**2)\n    + 100.0\n    + rng.uniform(low=0.0, high=0.5, size=x_topo.shape)\n)\n\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([z_topo.max() - 40, z_topo.max()])\nax.plot_surface(x_topo, y_topo, z_topo, color=\"r\", edgecolor=\"k\", linewidth=0.5)\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=20.0)\n\nx_topo, y_topo, z_topo = mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)\ntopo_xyz = np.c_[x_topo, y_topo, z_topo]\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#define-the-topography","position":5},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Survey"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#define-the-survey","position":6},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Survey"},"content":"Surveys within SimPEG generally require the user to create and connect three types of objects:\n\nreceivers: which define the locations of field measurements and type of data being measured.\n\nsources: the passive or active sources responsible for generating geophysical responses, and their associated receivers.\n\nsurvey: the object which stores and organizes all of the sources and receivers.\n\nHere, we define the survey that will be used for the forward simulation. Magnetic surveys are simple to create. The user only needs an (N, 3) \n\nnumpy.ndarray to define the xyz locations of the observation locations, the field components being measured, and the Earth’s inducing field. For the tutorial simulation, the receivers are located 10 m above the surface topography and spaced 10 m apart.\n\n# Define the observation locations as an (N, 3) numpy array or load them.\nx = np.linspace(-80.0, 80.0, 17)\ny = np.linspace(-80.0, 80.0, 17)\nx, y = np.meshgrid(x, y)\nx, y = mkvc(x.T), mkvc(y.T)\nfun_interp = LinearNDInterpolator(np.c_[x_topo, y_topo], z_topo)\nz = fun_interp(np.c_[x, y]) + 10  # Flight height 10 m above surface.\nreceiver_locations = np.c_[x, y, z]\n\n# Define the component(s) of the field we want to simulate as strings within\n# a list. Here we measure the x, y and z derivatives of the Bz anomaly at\n# each observation location.\ncomponents = [\"bxz\", \"byz\", \"bzz\"]\n\n# Use the observation locations and components to define the receivers. To\n# simulate data, the receivers must be defined as a list.\nreceiver_list = magnetics.receivers.Point(receiver_locations, components=components)\nreceiver_list = [receiver_list]\n\n# Define the inducing field\nfield_inclination = 90  # inclination [deg]\nfield_declination = 0  # declination [deg]\nfield_amplitude = 50000  # amplitude [nT]\n\nsource_field = magnetics.sources.UniformBackgroundField(\n    receiver_list=receiver_list,\n    amplitude=field_amplitude,\n    inclination=field_inclination,\n    declination=field_declination,\n)\n\n# Define the survey\nsurvey = magnetics.survey.Survey(source_field)\n\nIf desired, we can extract various objects and properties from the objects used to generate the survey. E.g.\n\nprint(\"# of locations: {}\".format(survey.nRx))  # number of receiver locations\nprint(\"# of data: {}\".format(survey.nD))  # number of data that will be simulated\nprint(survey.source_field.inclination)  # inclination of the source field\nprint(survey.source_field.receiver_list[0])  # the receiver object\nprint(receiver_list[0].locations[:5, :])  # the first 5 receiver locations\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#define-the-survey","position":7},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#design-a-tree-mesh","position":8},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Design a (Tree) Mesh"},"content":"Meshes are designed using the \n\ndiscretize package. See the \n\ndiscretize user tutorials to learn more about creating meshes.\nHere, the forward simulation is computed for a \n\ntree mesh. If you wanted to generate a \n\ntensor mesh instead, you can use the code snippet from the \n\n3D Forward Simulation of Total Magnetic Intensity Data tutorial.\n\nThe integral formulation for magnetics essentially sums the independent contribution for every magnetized voxel cell in the mesh. Since the kernel function that computes the contribution for a single cell is an analytic solution, small cells are not required to accurately compute the contributions from coarse structures with constant magnetization (e.g. a rectangular prism). For complex structures however, or to define surface topography more accurately, finer cells may be needed. Furthermore, cells do not need to be cubic. Since the analytic solution is only valid outside the magnetized region, please do no place receivers within the Earth.\n\nHere, a core cell width of 5 m is used within our survey region. Padding is used to extend the mesh outside the immediate survey area. The mesh will be plotted after we define our density contrast model.\n\ndx = 5  # minimum cell width (base mesh cell width) in x\ndy = 5  # minimum cell width (base mesh cell width) in y\ndz = 5  # minimum cell width (base mesh cell width) in z\n\nx_length = 240.0  # domain width in x\ny_length = 240.0  # domain width in y\nz_length = 120.0  # domain width in z\n\n# Compute number of base mesh cells required in x and y\nnbcx = 2 ** int(np.round(np.log(x_length / dx) / np.log(2.0)))\nnbcy = 2 ** int(np.round(np.log(y_length / dy) / np.log(2.0)))\nnbcz = 2 ** int(np.round(np.log(z_length / dz) / np.log(2.0)))\n\n# Define the base mesh. Top defined at z = 0 m.\nhx = [(dx, nbcx)]\nhy = [(dy, nbcy)]\nhz = [(dz, nbcz)]\nmesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift vertically to top same as maximum topography\nmesh.origin += np.r_[0.0, 0.0, z_topo.max()]\n\n# Refine based on surface topography\nmesh.refine_surface(topo_xyz, padding_cells_by_level=[2, 2], finalize=False)\n\n# Refine box based on region of interest\nwsb_corner = np.c_[-100, -100, 20]\nent_corner = np.c_[100, 100, 100]\n# Note -1 is a flag for smallest cell size\nmesh.refine_box(wsb_corner, ent_corner, levels=[-1], finalize=False)\n\nmesh.finalize()\n\nIf desired, we can extract various properties of the mesh. E.g.\n\nprint(\"# of cells: {}\".format(mesh.n_cells))  # Number of cells\nprint(\"# of x-faces: {}\".format(mesh.n_faces_x))  # Number of x-faces\nprint(\"Origin: {}\".format(mesh.origin))  # bottom-southewest corner\nprint(\"Max cell volume: {}\".format(mesh.cell_volumes.max()))  # Largest cell size\nprint(mesh.cell_centers[0:5, :])  # Cell center locations\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#design-a-tree-mesh","position":9},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Active Cells"},"content":"Whereas cells below the Earth’s surface contribute towards the simulated magnetic anomaly, air cells do not.\nThe set of mesh cells used in the forward simulation are referred to as ‘active cells’. Unused cells (air cells) are ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Mapping from the Model to Active Cells"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#mapping-from-the-model-to-active-cells","position":12},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Mapping from the Model to Active Cells"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For example, the model may be defined as the logarithms of the physical property values, or be parameters defining a layered Earth. When simulating magnetic data using the integral formulation, we must define a mapping from the set of model parameters to the active cells in the mesh. Mappings are created using the \n\nsimpeg.maps module. For the tutorial exercise, the model is the density contrast values for all active cells. As such, our mapping is an identity mapping, whose dimensions are equal to the number of active cells.\n\n# Define mapping from model to active cells. The model consists of a density\n# contrast value for each cell below the Earth's surface.\nn_active = int(active_cells.sum())\nmodel_map = maps.IdentityMap(nP=3 * n_active)\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#mapping-from-the-model-to-active-cells","position":13},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Magnetic Vector Model"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#define-the-magnetic-vector-model","position":14},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Magnetic Vector Model"},"content":"Magnetic vector models are defined by three-component effective susceptibilities. Where \\vec{M}_{ind} represents the induced magnetization, \\vec{M}_{rem} represents the remanent magnetization, and \\vec{H}_0 is the inducing magnetic field intensity, the magnetic vector model defines the components of:\\vec{\\chi}_{eff} = \\frac{\\vec{M}_{ind} + \\vec{M}_{rem}}{\\left | \\vec{H}_0 \\right |}\n\nAs a result, magnetic vector models in SimPEG are defined using SI units.\nTo create a magnetic vector model, we must\n\nCompute the induced magnetization vector for each cell by multiplying the susceptibility \\chi by the inducing magnetic field intensity \\vec{H}_0. The resulting quantity has units A/m.\n\nDefine the remanent magnetization vector for each cell, once again in A/m.\n\nSum the induced and remanent contributions.\n\nNormalize by the amplitude of inducing magnetic field intensity; i.e. \\left | \\vec{H}_0 \\right | in units A/m. The resulting quantity is unitless (SI).\n\nRe-organize the quantity as a 1D \n\nnumpy.ndarray organized by vector component; i.e. np.r_[chi_1, chi_2, chi_3]\n\nHere, the model consists of a susceptible and remanently magnetized sphere within a negligibly susceptible host. The horizontal components of the induced and remanent magnetization has been balance so that they cancel out, and the net magnetization is downward. We plot the magnetic vector models using the \n\nplot_slice method.\n\n# Define susceptibility values for each unit in SI\nbackground_susceptibility = 0.0001\nsphere_susceptibility = 0.01\n\n# Compute the induced magnetization vector (A/m) for every active cell\nsusceptibility_model = background_susceptibility * np.ones(n_active)\nind_sphere = model_builder.get_indices_sphere(\n    np.r_[0.0, 0.0, 55.0], 16.0, mesh.cell_centers\n)\nind_sphere = ind_sphere[active_cells]\nsusceptibility_model[ind_sphere] = sphere_susceptibility\n\n# Compute the unit direction of the inducing field in Cartesian coordinates\nfield_direction = mat_utils.dip_azimuth2cartesian(field_inclination, field_declination)\n\n# Inducing magnetic field intensity (A/m)\nH0 = 1e-9 * field_amplitude * field_direction / mu_0\n\n# Compute induced magnetization\ninduced_magnetization = np.outer(\n    susceptibility_model, H0\n)  # (n_active, 3) numpy.ndarray\n\n# Define the remanent magnetization vector (A/m) for every active cell.\n# inclination (deg), declination (deg), amplitude (A/m)\nremanence_inclination = 45.0\nremanence_declination = 210.0\nremanence_amplitude = 0.39788735751313814\n\nremanent_magnetization = np.zeros_like(induced_magnetization)\nremanent_magnetization_sphere = remanence_amplitude * mat_utils.dip_azimuth2cartesian(\n    remanence_inclination, remanence_declination\n)\nremanent_magnetization[ind_sphere, :] = remanent_magnetization_sphere\n\n# Compute total magnetization (A/m) for all active cells\ntotal_magnetization = induced_magnetization + remanent_magnetization\n\n# Define effective susceptibility model as a vector np.r_[chi_x, chi_y, chi_z]\nmodel = mkvc(total_magnetization) / np.linalg.norm(H0)\n\n# Mapping to ignore inactive cells when plotting MVI amplitude\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\n# MVI model organized into (N, 3) numpy.ndarray\nplotting_model = total_magnetization / np.linalg.norm(H0)\n\n# Amplitude of MVI\nmodel_amplitude = np.sqrt(np.sum(plotting_model**2, axis=1))\n\nfig = plt.figure(figsize=(14, 4))\n\nnorm = mpl.colors.Normalize(vmin=0, vmax=np.max(model_amplitude))\n\nax1 = fig.add_axes([0.05, 0.12, 0.5, 0.78])\nmesh.plot_slice(\n    plotting_map * model_amplitude,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(mesh.h[1].size / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n)\nax1.set_title(\"MVI Model at y = 0 m (amplitude)\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.62, 0.12, 0.25, 0.78])\nmesh.plot_slice(\n    plotting_map * plotting_model,\n    v_type=\"CCv\",\n    view=\"vec\",\n    normal=\"Y\",\n    ax=ax2,\n    ind=int(mesh.h[1].size / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n    quiver_opts={\n        \"pivot\": \"mid\",\n        \"width\": 0.01,\n        \"headwidth\": 3.0,\n        \"headlength\": 3.0,\n        \"headaxislength\": 3.0,\n        \"scale\": 0.25,\n    },\n)\nax2.set_title(\"MVI Model at y = 0 m\")\nax2.set_xlim([-25, 25])\nax2.set_ylim([30, 80])\nax2.set_xlabel(\"x (m)\")\nax2.set_ylabel(\"z (m)\")\n\ncx = fig.add_axes([0.89, 0.12, 0.02, 0.78])\ncbar = mpl.colorbar.ColorbarBase(\n    cx, norm=norm, orientation=\"vertical\", cmap=mpl.cm.plasma\n)\ncbar.set_label(\"SI\", rotation=270, labelpad=15)\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#define-the-magnetic-vector-model","position":15},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#define-the-forward-simulation","position":16},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Define the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class.\nIn this case, we use the simulation class for the \n\n3D integral formulation. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe mesh\n\nthe indices of the active cells\n\nthe mapping from the model to the active cells\n\nthe model type: “scalar” for susceptibility model, “vector” for magnetic vector model\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object. Additional keyword arguments can also be set which impact the forward simulation. Because we are only simulating data for a single model, there is no benefit to storing the sensitivities for the forward simulation. store_sensitivities property to ‘forward_only’\n\nBy choosing engine=\"choclo\" we can make our simulation to run the faster and more memory efficient implementation of the magnetic forward that uses \n\nNumba and \n\nChoclo under the hood. To do so, we need to have \n\nChoclo installed.\n\nsimulation = magnetics.simulation.Simulation3DIntegral(\n    survey=survey,\n    mesh=mesh,\n    model_type=\"vector\",\n    chiMap=model_map,\n    active_cells=active_cells,\n    store_sensitivities=\"forward_only\",\n    engine=\"choclo\",\n)\n\n","type":"content","url":"/fwd-magnetics-mvi-3d#define-the-forward-simulation","position":17},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Simulate Magnetic Gradiometry Data"},"type":"lvl2","url":"/fwd-magnetics-mvi-3d#simulate-magnetic-gradiometry-data","position":18},{"hierarchy":{"lvl1":"3D Forward Simulation of Magnetic Gradiometry Data for Magnetic Vector Models","lvl2":"Simulate Magnetic Gradiometry Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. In SimPEG, magnetic gradiometry data values are in nT/m.\n\ndpred = simulation.dpred(model)\n\nData are ordered by component, then by location. Here, we reshape the predicted data vector into an array for easier plotting.\n\nn_loc = survey.nRx  # Number of receiver locations\nn_comp = len(components)  # Number of data components\ndpred_plotting = np.reshape(dpred, (n_loc, n_comp))\n\nfig = plt.figure(figsize=(10, 3))\nv_max = np.max(np.abs(dpred))\n\nax = 3 * [None]\ncplot = 3 * [None]\ncomp_list = [\"x\", \"y\", \"z\"]\n\nnorm = mpl.colors.Normalize(vmin=-v_max, vmax=v_max)\n\nfor ii in range(0, 3):\n    ax[ii] = fig.add_axes([0.1 + ii * 0.26, 0.15, 0.25, 0.78])\n    cplot[ii] = plot2Ddata(\n        receiver_locations,\n        dpred_plotting[:, ii],\n        ax=ax[ii],\n        ncontour=60,\n        contourOpts={\"cmap\": \"bwr\", \"norm\": norm},\n    )\n    ax[ii].set_title(r\"$\\partial B_z /\\partial {}$\".format(comp_list[ii]))\n    ax[ii].set_xlabel(\"x (m)\")\n    if ii == 0:\n        ax[ii].set_ylabel(\"y (m)\")\n    else:\n        ax[ii].set_yticks([])\n\ncx = fig.add_axes([0.89, 0.13, 0.02, 0.79])\ncbar = mpl.colorbar.ColorbarBase(cx, norm=norm, orientation=\"vertical\", cmap=mpl.cm.bwr)\ncbar.set_label(\"$nT/m$\", rotation=270, labelpad=10, size=12)\n\nplt.show()","type":"content","url":"/fwd-magnetics-mvi-3d#simulate-magnetic-gradiometry-data","position":19},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model"},"type":"lvl1","url":"/inv-magnetics-induced-3d","position":0},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: total magnetic intensity, integral formulation, inversion, sparse norm, tensor mesh, tree mesh.\n\nSummary: Here we invert total magnetic intensity data to recover a susceptibility model. We demonstrate two approaches for recovering a susceptibility model:\n\nWeighted least-squares inversion for a tensor mesh\n\nIteratively re-weighted least-squares (IRLS) inversion for a tree mesh\n\nThe weighted least-squares approach is a great introduction to geophysical inversion with SimPEG. One drawback however, is that it recovers smooth structures which may not be representative of the true model. To recover sparse and/or blocky structures, we demonstrate the iteratively re-weighted least-squares approach. Because this tutorial focusses primarily on\ninversion-related functionality, we urge the reader to become familiar with functionality explained in the \n\n3D Forward Simulation of Total Magnetic Intensity Data tutorial before working through this one.\n\nLearning Objectives:\n\nIntroduce geophysical inversion with SimPEG.\n\nAssigning appropriate uncertainties to total magnetic intensity data.\n\nDesigning a suitable mesh for magnetic inversion.\n\nChoosing suitable parameters for the inversion.\n\nSpecifying directives that are applied throughout the inversion.\n\nApply the sensitivity weighting commonly used when inverting magnetic data.\n\nInversion with weighted least-squares and sparse-norm regularizations.\n\nAnalyzing inversion outputs.\n\nAlthough we consider total magnetic intensity data in this tutorial, the same approach can be used to invert magnetic gradiometry data.\n\n","type":"content","url":"/inv-magnetics-induced-3d","position":1},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Import Modules"},"type":"lvl2","url":"/inv-magnetics-induced-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to the forward simulation of magnetic data are imported from the \n\nsimpeg​.potential​_fields​.magnetics module. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.potential_fields import magnetics\nfrom simpeg.utils import plot2Ddata, model_builder, download\nfrom simpeg import (\n    maps,\n    data,\n    data_misfit,\n    inverse_problem,\n    regularization,\n    optimization,\n    directives,\n    inversion,\n)\n\n# discretize functionality\nfrom discretize import TensorMesh, TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Common Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport tarfile\n\nmpl.rcParams.update({\"font.size\": 14})\n\n","type":"content","url":"/inv-magnetics-induced-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Load Tutorial Files"},"type":"lvl2","url":"/inv-magnetics-induced-3d#load-tutorial-files","position":4},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Load Tutorial Files"},"content":"For most geophysical inversion projects, a reasonable inversion result can be obtained so long as the practitioner has observed data and topography. For this tutorial, the observed data and topography files are provided. Here, we download and import the observed data and topography into the SimPEG framework.\n\n# URL to download from repository assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/04-magnetics/inv_magnetics_induced_3d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"magnetics_topo.txt\"\ndata_filename = dir_path + \"magnetics_data.obs\"\n\nFor this tutorial, the data are organized within basic XYZ files. However, SimPEG does allow the user to import UBC-GIF formatted magnetic data files; see \n\nread_mag3d_ubc.\n\n# Load topography (xyz file)\ntopo_xyz = np.loadtxt(str(topo_filename))\n\n# Load field data (xyz file)\ndobs = np.loadtxt(str(data_filename))\n\n","type":"content","url":"/inv-magnetics-induced-3d#load-tutorial-files","position":5},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Plot Observed Data and Topography"},"type":"lvl2","url":"/inv-magnetics-induced-3d#plot-observed-data-and-topography","position":6},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Plot Observed Data and Topography"},"content":"Here we plot the synthetic total magnetic intensity data and local topography.\n\n# Define receiver locations and observed data\nreceiver_locations = dobs[:, 0:3]\ndobs = dobs[:, -1]\n\nfig = plt.figure(figsize=(8, 5))\nax1 = fig.add_axes([0.05, 0.35, 0.35, 0.6])\n\nv_max = np.max(np.abs(dobs))\nnorm1 = mpl.colors.Normalize(vmin=-v_max, vmax=v_max)\n\nplot2Ddata(\n    receiver_locations,\n    dobs,\n    ax=ax1,\n    dataloc=True,\n    ncontour=40,\n    contourOpts={\"cmap\": mpl.cm.bwr, \"norm\": norm1},\n)\nax1.set_title(\"TMI Anomaly\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\n\ncx1 = fig.add_axes([0.05, 0.18, 0.35, 0.04])\ncbar1 = mpl.colorbar.ColorbarBase(\n    cx1, norm=norm1, orientation=\"horizontal\", cmap=mpl.cm.bwr\n)\ncbar1.set_label(\"$nT$\", size=16)\n\nax2 = fig.add_axes([0.55, 0.35, 0.35, 0.6])\nplot2Ddata(\n    topo_xyz[:, 0:2],\n    topo_xyz[:, -1],\n    ax=ax2,\n    ncontour=50,\n    contourOpts={\"cmap\": \"gist_earth\"},\n)\nax2.set_title(\"Topography\", pad=15)\nax2.set_xlabel(\"x (m)\")\nax2.set_ylabel(\"y (m)\")\n\ncx2 = fig.add_axes([0.55, 0.18, 0.35, 0.04])\nnorm2 = mpl.colors.Normalize(vmin=np.min(topo_xyz[:, -1]), vmax=np.max(topo_xyz[:, -1]))\ncbar2 = mpl.colorbar.ColorbarBase(\n    cx2, norm=norm2, orientation=\"horizontal\", cmap=mpl.cm.gist_earth\n)\ncbar2.set_label(\"$m$\", size=16)\n\nplt.show()\n\n","type":"content","url":"/inv-magnetics-induced-3d#plot-observed-data-and-topography","position":7},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-magnetics-induced-3d#assign-uncertainties","position":8},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor total magnetic intensity data, a constant floor value is generally applied to all data. We generally avoid assigning percent uncertainties because the inversion prioritizes fitting the background over fitting anomalies. The floor value for the uncertainties may be chosen based on some knowledge of the instrument error, or it may be chosen as some fraction of the largest anomaly value. For this tutorial, the floor uncertainty assigned to all data is 2% of the maximum observed total magnetic intensity value. For magnetic gradiometry data, you may choose to assign a different floor value to each data component.\n\nmaximum_anomaly = np.max(np.abs(dobs))\nfloor_uncertainty = 0.02 * maximum_anomaly\nuncertainties = floor_uncertainty * np.ones(np.shape(dobs))\nprint(\"Floor uncertainty: {}\".format(floor_uncertainty))\n\n","type":"content","url":"/inv-magnetics-induced-3d#assign-uncertainties","position":9},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Define the Survey"},"type":"lvl2","url":"/inv-magnetics-induced-3d#define-the-survey","position":10},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Define the Survey"},"content":"Here, we define the survey geometry. The survey consists of a 160 m x 160 m grid of equally spaced receivers located 10 m\nabove the surface topography. For a more comprehensive description of constructing magnetic surveys in SimPEG, see the \n\n3D Forward Simulation of Total Magnetic Intensity Data tutorial.\n\n# Define the component(s) of the field we are inverting as a list. Here we will\n# invert total magnetic intensity data.\ncomponents = [\"tmi\"]\n\n# Use the observation locations and components to define the receivers. To\n# simulate data, the receivers must be defined as a list.\nreceiver_list = magnetics.receivers.Point(receiver_locations, components=components)\nreceiver_list = [receiver_list]\n\n# Define the inducing field\ninclination = 90  # inclination [deg]\ndeclination = 0  # declination [deg]\namplitude = 50000  # amplitude [nT]\n\nsource_field = magnetics.sources.UniformBackgroundField(\n    receiver_list=receiver_list,\n    amplitude=amplitude,\n    inclination=inclination,\n    declination=declination,\n)\n\n# Define the survey\nsurvey = magnetics.survey.Survey(source_field)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-survey","position":11},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Define the Data"},"type":"lvl2","url":"/inv-magnetics-induced-3d#define-the-data","position":12},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Define the Data"},"content":"The SimPEG \n\nData class is required for inversion and connects the observed data, uncertainties and survey geometry.\n\ndata_object = data.Data(survey, dobs=dobs, standard_deviation=uncertainties)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-data","position":13},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl2","url":"/inv-magnetics-induced-3d#weighted-least-squares-inversion-on-a-tensor-mesh","position":14},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"\n\n","type":"content","url":"/inv-magnetics-induced-3d#weighted-least-squares-inversion-on-a-tensor-mesh","position":15},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Design a (Tensor) Mesh","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#design-a-tensor-mesh","position":16},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Design a (Tensor) Mesh","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Meshes are designed using the \n\ndiscretize package. Here, we design a \n\ntensor mesh. See the \n\ndiscretize user tutorials to learn more about creating meshes. When designing a mesh for magnetic inversion, we must consider the spatial wavelengths of the signals contained within the data. If the data spacing is large and/or the signals present in the data are smooth, larger cells can be used to construct the mesh. If the data spacing is smaller and compact anomalies are observed, smaller cells are needed to characterize the structures responsible. And smaller cells are required when the effects of surface topography are significant.\n\nGeneral rule of thumb: The minimum cell size in each direction is at most 0.5 - 1 times the station spacing. And the thickness of the padding is at least 1 - 2 times the width of the survey region.\n\n# Generate tensor mesh with top at z = 0 m\ndh = 5.0  # minimum cell size\nhx = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]  # discretization along x\nhy = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]  # discretization along y\nhz = [(dh, 5, -1.3), (dh, 15)]  # discretization along z\ntensor_mesh = TensorMesh([hx, hy, hz], \"CCN\")\n\n# Shift vertically to top same as maximum topography\ntensor_mesh.origin += np.r_[0.0, 0.0, topo_xyz[:, -1].max()]\n\n","type":"content","url":"/inv-magnetics-induced-3d#design-a-tensor-mesh","position":17},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-active-cells","position":18},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Whereas cells below the Earth’s surface contribute towards simulated magnetic anomalies, air cells do not.\nThe set of mesh cells used in the forward simulation are referred to as ‘active cells’. Unused cells (air cells) are ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\nactive_tensor_cells = active_from_xyz(tensor_mesh, topo_xyz)\nn_tensor_active = int(active_tensor_cells.sum())\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-active-cells","position":19},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Mapping from the Model to Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#mapping-from-the-model-to-active-cells","position":20},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Mapping from the Model to Active Cells","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For whatever model we choose, we must define a mapping from the set of model parameters (a \n\n1D numpy.ndarray) to the active cells in the mesh. Mappings are created using the \n\nsimpeg.maps module. For the tutorial exercise, the model is the susceptibility values for all active cells. As such, our mapping is an identity mapping, whose dimensions are equal to the number of active cells.\n\ntensor_model_map = maps.IdentityMap(nP=n_tensor_active)\n\n","type":"content","url":"/inv-magnetics-induced-3d#mapping-from-the-model-to-active-cells","position":21},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#starting-reference-models","position":22},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"The starting model defines a reasonable starting point for the inversion and does not necessarily represent an initial estimate of the true model. Because the integral formulation used to solve the magnetic forward simulation is linear, the optimization problem we must solve is a linear least-squares problem, making the choice in starting model insignificant. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration. For magnetic inversion, the starting model is frequently a constant vector with a very small value.\n\nThe reference model is used to include a-priori information. The impact of the reference model on the inversion will be discussed in another tutorial. Assuming the contribution from all regional structures has been removed from the magnetic data, and assuming we have not a-priori information, the reference model for basic inversion of magnetic data is zero or equal to the starting model.\n\nNotice that the length of the starting and reference models is equal to the number of active mesh cells!!!\n\nstarting_tensor_model = 1e-6 * np.ones(n_tensor_active)\nreference_tensor_model = np.zeros_like(starting_tensor_model)\n\n# Mapping to ignore inactive cells when plotting\ntensor_plotting_map = maps.InjectActiveCells(tensor_mesh, active_tensor_cells, np.nan)\n\nfig = plt.figure(figsize=(7, 3))\nax1 = fig.add_axes([0.1, 0.1, 0.73, 0.8])\n\nnorm = mpl.colors.Normalize(vmin=0.0, vmax=1.0)\ntensor_mesh.plot_slice(\n    tensor_plotting_map * starting_tensor_model,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(tensor_mesh.shape_cells[1] / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n)\nax1.set_title(\"Starting Model (slice at y = 0 m)\")\n\nax2 = fig.add_axes([0.85, 0.1, 0.03, 0.8])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.plasma\n)\ncbar.set_label(\"$SI$\", rotation=270, labelpad=15, size=16)\n\nplt.show()\n\n","type":"content","url":"/inv-magnetics-induced-3d#starting-reference-models","position":23},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-forward-simulation","position":24},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for total magnetic intensity data was discussed in the \n\n3D Forward Simulation of Total Magnetic Intensity Data tutorial. Here, we use the \n\n3D integral formulation.\n\nsimulation_L2 = magnetics.simulation.Simulation3DIntegral(\n    survey=survey,\n    mesh=tensor_mesh,\n    model_type=\"scalar\",\n    chiMap=tensor_model_map,\n    active_cells=active_tensor_cells,\n    engine=\"choclo\",\n)\n\nTip\n\nBy choosing engine=\"choclo\" we can make our simulation to run the faster and more memory efficient implementation of the gravity forward that uses \n\nNumba and \n\nChoclo under the hood. To do so, we need to have \n\nChoclo installed.\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-forward-simulation","position":25},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-data-misfit","position":26},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(data=data_object, simulation=simulation_L2)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-data-misfit","position":27},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-regularization","position":28},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource. Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Here, length scales along x, y and z are used to balance the smallness and smoothness terms. And the reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    tensor_mesh,\n    active_cells=active_tensor_cells,\n    length_scale_x=1.0,\n    length_scale_y=1.0,\n    length_scale_z=1.0,\n    reference_model=reference_tensor_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-regularization","position":29},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-optimization-algorithm","position":30},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Here, we use the \n\nProjectedGNCG class to solve the optimization problem using projected Gauss-Newton with conjugate gradietn solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches. Here, the lower property is set to 0 to ensure recovered susceptibility values are positive.\n\nopt_L2 = optimization.ProjectedGNCG(\n    maxIter=100, lower=0.0, maxIterLS=20, maxIterCG=10, tolCG=1e-2\n)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-optimization-algorithm","position":31},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-inverse-problem","position":32},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-inverse-problem","position":33},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#provide-inversion-directives","position":34},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"Directives represent operations that are carried out during the inversion. Here, we apply common directives for weighted least-squares inversion of magnetic data and describe their roles. These are:\n\nUpdateSensitivityWeights: Apply sensitivity weighting to counteract the natural tendancy of potential field inversion to cluster recovered structures near the receivers. Because the 3D integral formulation is linear, the sensitivity weighting is independent of the model and does not need to be updated throughout the inversion, so we set every_iteration=False.\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nsensitivity_weights = directives.UpdateSensitivityWeights(every_iteration=False)\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=10)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=1)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [\n    sensitivity_weights,\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-magnetics-induced-3d#provide-inversion-directives","position":35},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-and-run-the-inversion","position":36},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run inversion\nrecovered_tensor_model = inv_L2.run(starting_tensor_model)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-and-run-the-inversion","position":37},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#plot-the-data-misfit","position":38},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"This step is necessary for determining whether the recovered model accurately reproduces observed anomalies. Here, we plot the observed data, predicted data for the recovered model, and the misfit. As we can see, the predicted data fits the background somewhat better than the anomalies. As a result, you may reassign smaller uncertainties in these areas and re-run the inversion in order to better fit the anomalies. We will do this for the iteratively reweighted least-squares inversion.\n\n# Predicted data with final recovered model.\ndpred = inv_prob_L2.dpred\n\n# Observed data | Predicted data | Data misfit\ndata_array = np.c_[dobs, dpred, (dobs - dpred)]\n\nfig = plt.figure(figsize=(12, 5))\nplot_title = [\"Observed\", \"Predicted\", \"Data Misfit\"]\nplot_units = [\"nT\", \"nT\", \"nT\"]\n\nax1 = 3 * [None]\nax2 = 3 * [None]\nnorm = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\nv_lim = [np.max(np.abs(dobs)), np.max(np.abs(dobs)), np.max(np.abs(dobs - dpred))]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.3 * ii + 0.1, 0.2, 0.27, 0.75])\n    norm[ii] = mpl.colors.Normalize(vmin=-v_lim[ii], vmax=v_lim[ii])\n    cplot[ii] = plot2Ddata(\n        receiver_list[0].locations,\n        data_array[:, ii],\n        ax=ax1[ii],\n        ncontour=30,\n        contourOpts={\"cmap\": \"bwr\", \"norm\": norm[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    if ii == 0:\n        ax1[ii].set_ylabel(\"y (m)\")\n    else:\n        ax1[ii].set_yticks([])\n\n    ax2[ii] = fig.add_axes([0.3 * ii + 0.1, 0.05, 0.27, 0.05])\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm[ii], orientation=\"horizontal\", cmap=mpl.cm.bwr\n    )\n    cbar[ii].set_label(plot_units[ii], labelpad=5)\n\nplt.show()\n\n","type":"content","url":"/inv-magnetics-induced-3d#plot-the-data-misfit","position":39},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"type":"lvl3","url":"/inv-magnetics-induced-3d#plot-the-recovered-model","position":40},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion on a Tensor Mesh"},"content":"As we can see, weighted least-squares regularization leads to the recovery of smooth models. And even with sensitivity weighting, there is a tendancy for gravity anomaly inversion to place recovered structures near the Earth’s surface.\n\n# Plot Recovered Model\nfig = plt.figure(figsize=(7, 3))\nax1 = fig.add_axes([0.1, 0.1, 0.73, 0.8])\n\nnorm = mpl.colors.Normalize(\n    vmin=np.min(recovered_tensor_model), vmax=np.max(recovered_tensor_model)\n)\ntensor_mesh.plot_slice(\n    tensor_plotting_map * recovered_tensor_model,\n    normal=\"Y\",\n    ax=ax1,\n    ind=int(tensor_mesh.shape_cells[1] / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n)\nax1.set_title(\"Model slice at y = 0 m\")\n\nax2 = fig.add_axes([0.85, 0.1, 0.03, 0.8])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.plasma\n)\ncbar.set_label(\"$SI$\", rotation=270, labelpad=15, size=16)\n\nplt.show()\n\n","type":"content","url":"/inv-magnetics-induced-3d#plot-the-recovered-model","position":41},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-magnetics-induced-3d#iteratively-re-weighted-least-squares-inversion","position":42},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we provide a step-by-step best-practices approach for iteratively IRLS inversion of total magnetic intensity data on a tree mesh. Many of the steps are the same as our previous approach. As a result, we will avoid repeating information whenever possible.\n\n","type":"content","url":"/inv-magnetics-induced-3d#iteratively-re-weighted-least-squares-inversion","position":43},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Reassign the Uncertainties","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#reassign-the-uncertainties","position":44},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Reassign the Uncertainties","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Prior to performing the IRLS inversion, we decrease the uncertainties at the locations we observed the largest data misfits. Here, our goal is to recover a model that better fits the anomalies.\n\n# Compute normalized data misfits\nnormalized_data_misfits = (dobs - dpred) / uncertainties\n\n# Plot the normalized data misfits\nfig = plt.figure(figsize=(6, 3))\nax = fig.add_subplot(111)\nax.plot(np.sort(normalized_data_misfits))\nax.set_title(\"Normalized Data Misfits (sorted)\")\nax.grid()\nplt.show(fig)\n\n# Generate new uncertainties\nnew_uncertainties = uncertainties.copy()\nnew_uncertainties[np.abs(normalized_data_misfits) > 2.0] /= 2.5\n\n# Generate new data object\nnew_data_object = data.Data(survey, dobs=dobs, standard_deviation=new_uncertainties)\n\n","type":"content","url":"/inv-magnetics-induced-3d#reassign-the-uncertainties","position":45},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Design a (Tree) Mesh","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#design-a-tree-mesh","position":46},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Design a (Tree) Mesh","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we design a \n\ntree mesh. See the \n\ndiscretize user tutorials to learn more about creating tree meshes. The same approach used to construct the tensor mesh used in the weighted least-squares inversion example applies to tree meshes.\n\ndx = 5  # minimum cell width (base tree_mesh cell width) in x\ndy = 5  # minimum cell width (base tree_mesh cell width) in y\ndz = 5  # minimum cell width (base tree_mesh cell width) in z\n\nx_length = 240.0  # domain width in x\ny_length = 240.0  # domain width in y\nz_length = 120.0  # domain width in z\n\n# Compute number of base tree_mesh cells required in x and y\nnbcx = 2 ** int(np.round(np.log(x_length / dx) / np.log(2.0)))\nnbcy = 2 ** int(np.round(np.log(y_length / dy) / np.log(2.0)))\nnbcz = 2 ** int(np.round(np.log(z_length / dz) / np.log(2.0)))\n\n# Define the base tree_mesh\nhx = [(dx, nbcx)]\nhy = [(dy, nbcy)]\nhz = [(dz, nbcz)]\ntree_mesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift vertically to top same as maximum topography\ntree_mesh.origin += np.r_[0.0, 0.0, topo_xyz[:, -1].max()]\n\n# Refine based on surface topography\ntree_mesh.refine_surface(topo_xyz, padding_cells_by_level=[2, 2], finalize=False)\n\n# Refine box based on region of interest\nwsb_corner = np.c_[-100, -100, 20]\nent_corner = np.c_[100, 100, 100]\n# Note -1 is a flag for smallest cell size\ntree_mesh.refine_box(wsb_corner, ent_corner, levels=[-1], finalize=False)\n\ntree_mesh.finalize()\n\n","type":"content","url":"/inv-magnetics-induced-3d#design-a-tree-mesh","position":47},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Active Cells","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-active-cells-1","position":48},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Active Cells","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nind_tree_active = active_from_xyz(tree_mesh, topo_xyz)\nn_tree_active = int(ind_tree_active.sum())\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-active-cells-1","position":49},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Mapping from Model to Active Cells","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#mapping-from-model-to-active-cells","position":50},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Mapping from Model to Active Cells","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ntree_model_map = maps.IdentityMap(nP=n_tree_active)\n\n","type":"content","url":"/inv-magnetics-induced-3d#mapping-from-model-to-active-cells","position":51},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Starting and Reference Models","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#starting-and-reference-models","position":52},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Starting and Reference Models","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nstarting_tree_model = 1e-6 * np.ones(n_tree_active)\nreference_tree_model = np.zeros_like(starting_tree_model)\n\n","type":"content","url":"/inv-magnetics-induced-3d#starting-and-reference-models","position":53},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-forward-simulation","position":54},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nsimulation_irls = magnetics.simulation.Simulation3DIntegral(\n    survey=survey,\n    mesh=tree_mesh,\n    model_type=\"scalar\",\n    chiMap=tree_model_map,\n    active_cells=ind_tree_active,\n    engine=\"choclo\",\n)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-forward-simulation","position":55},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-data-misfit","position":56},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndmis_irls = data_misfit.L2DataMisfit(data=new_data_object, simulation=simulation_irls)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-data-misfit","position":57},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-regularization-1","position":58},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the \n\nSparse regularization class to constrain the inversion result using an IRLS approach. Here, the scaling constants that balance the smallness and smoothness terms are set directly. Equal emphasis on smallness and smoothness is generally applied by using the inverse square of the smallest cell dimension. The reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros. Here, we apply a 0-norm to the smallness term and a 1-norm to first-order smoothness along the x, y and z directions.\n\nreg_irls = regularization.Sparse(\n    tree_mesh,\n    active_cells=ind_tree_active,\n    alpha_s=dh**-2,\n    alpha_x=1,\n    alpha_y=1,\n    alpha_z=1,\n    reference_model=reference_tree_model,\n    reference_model_in_smooth=False,\n    norms=[0, 1, 1, 1],\n)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-regularization-1","position":59},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-optimization-algorithm-1","position":60},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nopt_irls = optimization.ProjectedGNCG(\n    maxIter=100, lower=0.0, maxIterLS=20, maxIterCG=10, tolCG=1e-2\n)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-optimization-algorithm-1","position":61},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-the-inverse-problem-1","position":62},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_prob_irls = inverse_problem.BaseInvProblem(dmis_irls, reg_irls, opt_irls)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-the-inverse-problem-1","position":63},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#provide-inversion-directives-1","position":64},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we create common directives for IRLS inversion of total magnetic intensity data and describe their roles. In additon to the \n\nUpdateSensitivityWeights, \n\nUpdatePreconditioner and \n\nBetaEstimate_ByEig  (described before), inversion with sparse-norms requires the \n\nUpdateIRLS directive.\n\nYou will notice that we don’t use the \n\nBetaSchedule and \n\nTargetMisfit directives. Here, the beta cooling schedule is set in the \n\nUpdateIRLS directive using the coolingFactor and coolingRate properties. The target misfit for the L2 portion of the IRLS approach is set with the chifact_start property.\n\nsensitivity_weights_irls = directives.UpdateSensitivityWeights(every_iteration=False)\nstarting_beta_irls = directives.BetaEstimate_ByEig(beta0_ratio=10)\nupdate_jacobi_irls = directives.UpdatePreconditioner(update_every_iteration=True)\nupdate_irls = directives.UpdateIRLS(\n    cooling_factor=2,\n    f_min_change=1e-4,\n    max_irls_iterations=25,\n    chifact_start=1.0,\n)\n\ndirectives_list_irls = [\n    update_irls,\n    sensitivity_weights_irls,\n    starting_beta_irls,\n    update_jacobi_irls,\n]\n\n","type":"content","url":"/inv-magnetics-induced-3d#provide-inversion-directives-1","position":65},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#define-and-run-the-inversion-1","position":66},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_irls = inversion.BaseInversion(inv_prob_irls, directives_list_irls)\nrecovered_tree_model = inv_irls.run(starting_tree_model)\n\n","type":"content","url":"/inv-magnetics-induced-3d#define-and-run-the-inversion-1","position":67},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Plot the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-magnetics-induced-3d#plot-the-data-misfit-1","position":68},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl3":"Plot the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here we plot the observed data, predicted and misfit for the IRLS inversion. As we can see from the misfit map, the observed data is now fit equally at all locations.\n\n# Predicted data with final recovered model.\ndpred_new = inv_prob_irls.dpred\n\n# Observed data | Predicted data | Data misfit\ndata_array = np.c_[dobs, dpred_new, (dobs - dpred_new)]\n\nfig = plt.figure(figsize=(12, 5))\nplot_title = [\"Observed\", \"Predicted\", \"Data Misfit\"]\nplot_units = [\"nT\", \"nT\", \"nT\"]\n\nax1 = 3 * [None]\nax2 = 3 * [None]\nnorm = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\nv_lim = [np.max(np.abs(dobs)), np.max(np.abs(dobs)), np.max(np.abs(dobs - dpred))]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.3 * ii + 0.1, 0.2, 0.27, 0.75])\n    norm[ii] = mpl.colors.Normalize(vmin=-v_lim[ii], vmax=v_lim[ii])\n    cplot[ii] = plot2Ddata(\n        receiver_list[0].locations,\n        data_array[:, ii],\n        ax=ax1[ii],\n        ncontour=30,\n        contourOpts={\"cmap\": \"bwr\", \"norm\": norm[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    if ii == 0:\n        ax1[ii].set_ylabel(\"y (m)\")\n    else:\n        ax1[ii].set_yticks([])\n\n    ax2[ii] = fig.add_axes([0.3 * ii + 0.1, 0.05, 0.27, 0.05])\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm[ii], orientation=\"horizontal\", cmap=mpl.cm.bwr\n    )\n    cbar[ii].set_label(plot_units[ii], labelpad=5)\n\nplt.show()\n\n","type":"content","url":"/inv-magnetics-induced-3d#plot-the-data-misfit-1","position":69},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Plot True, L2 and IRLS Models"},"type":"lvl2","url":"/inv-magnetics-induced-3d#plot-true-l2-and-irls-models","position":70},{"hierarchy":{"lvl1":"3D Inversion of TMI Data to Recover a Susceptibility Model","lvl2":"Plot True, L2 and IRLS Models"},"content":"Here, we compare the models recovered from weighted least-squares and iteratively re-weighted least-squares inversion to the true model.\n\n# Recreate True Model on a Tensor Mesh\nbackground_susceptibility = 0.0001\nsphere_susceptibility = 0.01\n\ntrue_model = background_susceptibility * np.ones(n_tensor_active)\nind_sphere = model_builder.get_indices_sphere(\n    np.r_[0.0, 0.0, 55.0], 16.0, tensor_mesh.cell_centers[active_tensor_cells]\n)\ntrue_model[ind_sphere] = sphere_susceptibility\n\nmesh_list = [tensor_mesh, tensor_mesh, tree_mesh]\nind_list = [active_tensor_cells, active_tensor_cells, ind_tree_active]\nmodel_list = [true_model, recovered_tensor_model, recovered_tree_model]\ntitle_list = [\"True Model\", \"L2 Tensor Model\", \"IRLS Tree Model\"]\ncplot = 3 * [None]\ncbar = 3 * [None]\nnorm = 3 * [None]\n\nfig = plt.figure(figsize=(7, 8))\nax1 = [fig.add_axes([0.1, 0.7 - 0.3 * ii, 0.75, 0.23]) for ii in range(0, 3)]\nax2 = [fig.add_axes([0.88, 0.7 - 0.3 * ii, 0.025, 0.23]) for ii in range(0, 3)]\n\nfor ii, mesh in enumerate(mesh_list):\n    plotting_map = maps.InjectActiveCells(mesh, ind_list[ii], np.nan)\n    max_abs = np.max(np.abs(model_list[ii]))\n    norm[ii] = mpl.colors.Normalize(vmin=0.0, vmax=max_abs)\n\n    cplot[ii] = mesh.plot_slice(\n        plotting_map * model_list[ii],\n        normal=\"Y\",\n        ax=ax1[ii],\n        ind=int(mesh.shape_cells[1] / 2),\n        grid=False,\n        pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm[ii]},\n    )\n    ax1[ii].set_xlim([-150, 150])\n    ax1[ii].set_ylim([topo_xyz[:, -1].max() - 100, topo_xyz[:, -1].max()])\n    if ii < 2:\n        ax1[ii].set_xlabel(\"\")\n        ax1[ii].set_xticks([])\n    ax1[ii].set_title(title_list[ii])\n\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm[ii], orientation=\"vertical\", cmap=mpl.cm.plasma\n    )\n    cbar[ii].set_label(\"$SI$\", labelpad=5)","type":"content","url":"/inv-magnetics-induced-3d#plot-true-l2-and-irls-models","position":71},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding"},"type":"lvl1","url":"/fwd-dcr-1d","position":0},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: DC resistivity, forward simulation, apparent resistivity, 1D sounding, wires mapping.\n\nSummary: Here we use the module \n\nsimpeg​.electromagnetics​.static​.resistivity to simulate 1D apparent resistivity data for a 1D Wenner array. The \n\nSimulation1DLayers class is used to solve the problem via a semi-analytic Hankel transform solution.\n\nLearning Objectives:\n\nIntroduce the fundamentals of simulating DC resistivity data with SimPEG.\n\nIntroduce the basics of defining DC resistivity surveys in SimPEG.\n\nDemonstrate various approaches for defining a 1D layered Earth model.\n\nDemonstrate how the Earth’s electrical properties can be defined according to conductivity OR resistivity.\n\nHow to simulate the data as normalize voltages OR apparent resistivities.\n\n","type":"content","url":"/fwd-dcr-1d","position":1},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-dcr-1d#import-modules","position":2},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to DC resistivity is imported from \n\nsimpeg​.electromagnetics​.static​.resistivity.\nWe also import some useful utility functions from \n\nsimpeg.utils.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import resistivity as dc\nfrom simpeg import maps\nfrom simpeg.utils import plot_1d_layer_model\n\n# Common Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.rcParams.update({\"font.size\": 16})\n\nwrite_output = False\n\n","type":"content","url":"/fwd-dcr-1d#import-modules","position":3},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define the Survey"},"type":"lvl2","url":"/fwd-dcr-1d#define-the-survey","position":4},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define the Survey"},"content":"DC resistivity surveys within SimPEG require the user to create and connect three types of objects:\n\nreceivers: which defines the locations of the potential (or MN) electrodes and the type of data; e.g. ‘volt’ for normalized voltage in V/A or ‘apparent_resistivity’ for apparent resistivity in \\Omega m. Note only M electrode locations are needed to define pole receivers.\n\nsources: which defines the locations of the current (or AB) electrodes, and their associated receivers. Note only A electrode locations are needed to define pole sources.\n\nsurvey: the object which stores and organizes all of the sources and receivers.\n\nEach datum corresponds to a unique pair of current and potential electrodes. When running the 1D forward simulation, the horizontal position is taken into account and we assume the electrodes are placed at the Earth’s surface. Therefore electrode locations can be defined by an xyz location, but the vertical position is ignored.\n\n# Define the 'a' spacings for Wenner array and number of soundings\na_min = 20.0\na_max = 500.0\nn_stations = 25\nelectrode_separations = np.linspace(a_min, a_max, n_stations)\n\nsource_list = []  # create empty array for sources to live\nfor ii in range(0, len(electrode_separations)):\n    # Extract separation parameter for sources and receivers\n    a = electrode_separations[ii]\n\n    # AB electrode locations for source. Each is a (1, 3) numpy array\n    A_location = np.r_[-1.5 * a, 0.0, 0.0]\n    B_location = np.r_[1.5 * a, 0.0, 0.0]\n\n    # MN electrode locations for receivers. Each is an (N, 3) numpy array\n    M_location = np.r_[-0.5 * a, 0.0, 0.0]\n    N_location = np.r_[0.5 * a, 0.0, 0.0]\n\n    # Create receivers list. Define as pole or dipole.\n    receiver_list = dc.receivers.Dipole(\n        M_location, N_location, data_type=\"apparent_resistivity\"\n    )\n    receiver_list = [receiver_list]\n\n    # Define the source properties and associated receivers\n    source_list.append(dc.sources.Dipole(receiver_list, A_location, B_location))\n\n# Define survey\nsurvey = dc.Survey(source_list)\n\nWe can extract various objects and properties from the objects used to generate the survey. As we can see, all receivers associated with each source are defined within a single object.\n\nprint(\"# of locations: {}\".format(survey.nSrc))  # number of sources\nprint(\"# of data: {}\".format(survey.nD))  # number of data that will be simulated\nprint(survey.source_list[3])  # the 3rd source object\nprint(survey.source_list[3].receiver_list[0])  # Its receiver\n\n","type":"content","url":"/fwd-dcr-1d#define-the-survey","position":5},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define a 1D Layered Earth Model"},"type":"lvl2","url":"/fwd-dcr-1d#define-a-1d-layered-earth-model","position":6},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define a 1D Layered Earth Model"},"content":"In SimPEG, a 1D layered Earth is defined by the set of layer thicknesses and the physical properties for each layer. Thicknesses and physical property values are defined from the top layer down. If we have N layers, we define N physical property values and N-1 layer thicknesses. The lowest layer is assumed to extend to infinity. In the case of a halfspace, the layer thicknesses would be an empty array.\n\n# Define layer thicknesses.\nlayer_thicknesses = np.r_[100.0, 100.0]\n\n# Define layer resistivities.\nlayer_resistivities = np.r_[1e3, 4e3, 2e2]\n\nax = plot_1d_layer_model(layer_thicknesses, layer_resistivities)\nax.grid(which=\"both\")\nax.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nplt.show()\n\n","type":"content","url":"/fwd-dcr-1d#define-a-1d-layered-earth-model","position":7},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define a Model and Mapping"},"type":"lvl2","url":"/fwd-dcr-1d#define-a-model-and-mapping","position":8},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define a Model and Mapping"},"content":"In SimPEG, the term ‘model’ is not necessarily synonymous with a set of physical property values. For example, the model may be defined as the logarithms of the physical property values, or be the parameters defining a layered Earth geometry. Models in SimPEG are 1D \n\nnumpy.ndarray whose lengths are equal to the number of model parameters.\n\nClasses within the simpeg.maps module are used to define the mapping that connects the model to the parameters required to run the DC resistivity simulation; i.e. layer thicknesses and layer conductivities/resistivities. Here, we demonstrate two types of mappings and models that may be used for 1D DC resistivity simulation.\n\n1. Resistivity model: For forward simulation, the easiest approach is to define the model as the layer resistivities and hard-code the layer thicknesses into simulation. In this case, the mapping from the model to the resistivities is defined using the \n\nsimpeg​.maps​.IdentityMap class.\n\n2. Parametric layered Earth model: In this case, the model defines the layer thicknesses and log-conductivities. We therefore need a mapping that extracts layer thicknesses from the model, and a mapping that extracts log-conductivities from the model and converts them into conductivities. For this, we require the \n\nsimpeg.maps.Wires mapping and \n\nsimpeg.maps.ExpMap mapping classes. Note that successive mappings can be chained together using the * operator.\n\n# Define mapping for a resistivity model.\nresistivity_model = layer_resistivities.copy()\nresistivity_map = maps.IdentityMap(nP=len(layer_resistivities))\n\n# Define mappings for parametric model with log-resistivities\nparametric_model = np.r_[layer_thicknesses, np.log(1 / layer_resistivities)]\nwire_map = maps.Wires(\n    (\"thicknesses\", len(layer_thicknesses)),\n    (\"log_conductivity\", len(layer_resistivities)),\n)\nthicknesses_map = wire_map.thicknesses\nlog_conductivity_map = maps.ExpMap() * wire_map.log_conductivity\n\n","type":"content","url":"/fwd-dcr-1d#define-a-model-and-mapping","position":9},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/fwd-dcr-1d#define-the-forward-simulation","position":10},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Define the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class. Here, we use the \n\nSimulation1DLayers which simulates the data according to a 1D Hankel transform solution. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe layer thicknesses\n\nthe layer conductivities/resistivities\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object. Here, we define two simulation objects.\n\n1. Resistivity model simulation: Here, the model parameters are the layer resistivities. rhoMap is used to define the mapping from the model to the layer resistivities. And thicknessess is used to set the layer thicknesses as static parameters of the simulation.\n\n2. Parametric model simulation: Here we are working with conductivities as opposed to resistivities, and the model contains layer thicknesses and log-conductivities. In this case, sigmaMap is used to define the mapping from the model to the layer conductivities. And thicknessesMap is used to define the mapping from the model to the layer thicknesses.\n\nsimulation_resistivity = dc.simulation_1d.Simulation1DLayers(\n    survey=survey,\n    rhoMap=resistivity_map,\n    thicknesses=layer_thicknesses,\n)\n\nsimulation_parametric = dc.simulation_1d.Simulation1DLayers(\n    survey=survey,\n    sigmaMap=log_conductivity_map,\n    thicknessesMap=thicknesses_map,\n)\n\n","type":"content","url":"/fwd-dcr-1d#define-the-forward-simulation","position":11},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Predict DC Resistivity Data"},"type":"lvl2","url":"/fwd-dcr-1d#predict-dc-resistivity-data","position":12},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Predict DC Resistivity Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. Note that despite the difference in how we defined the model, the data predicted by both simulations is equivalent because data are being modeled for the same 1D layered Earth.\n\ndpred_resistivity = simulation_resistivity.dpred(resistivity_model)\ndpred_parametric = simulation_parametric.dpred(parametric_model)\n\nfig = plt.figure(figsize=(9, 5))\nax1 = fig.add_axes([0.1, 0.1, 0.75, 0.85])\nax1.semilogy(1.5 * electrode_separations, dpred_resistivity, \"b\")\nax1.semilogy(1.5 * electrode_separations, dpred_parametric, \"r*\")\nax1.grid(True, which=\"both\")\nax1.set_xlabel(\"AB/2 (m)\")\nax1.set_ylabel(r\"$\\Omega m$\")\nax1.set_title(\"Sounding Curve\")\nax1.legend([\"Resistivity Model\", \"Parametric Model\"])\nplt.show()\n\nOptional: Export Data\n\nif write_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_dcr_1d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    rng = np.random.default_rng(seed=145)\n    noise = rng.normal(scale=0.025 * dpred_resistivity, size=len(dpred_resistivity))\n\n    data_array = np.c_[\n        survey.locations_a,\n        survey.locations_b,\n        survey.locations_m,\n        survey.locations_n,\n        dpred_resistivity + noise,\n    ]\n\n    fname = dir_path + \"app_res_1d_data.dobs\"\n    np.savetxt(fname, data_array, fmt=\"%.4e\")","type":"content","url":"/fwd-dcr-1d#predict-dc-resistivity-data","position":13},{"hierarchy":{"lvl1":"2.5D Forward Simulation"},"type":"lvl1","url":"/fwd-dcr-2d","position":0},{"hierarchy":{"lvl1":"2.5D Forward Simulation"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: DC resistivity, forward simulation, 2.5D, apparent resistivity, tree mesh.\n\nSummary: Here we use the module \n\nsimpeg​.electromagnetics​.static​.resistivity to simulate DC resistivity data when the local geology doesn’t change along the strike direction. Here, we use a 2.5D simulation approach to leverage the symmetry of the problem and avoid the higher computational cost associated with full 3D simulations.\n\nLearning Objectives:\n\nHow to define DC resistivity lines manually or by using utility functions in SimPEG.\n\nHow to design a 2D tree mesh (or tensor mesh) for accurately simulating DC resistivity data for the 2.5D approach.\n\nHow to define the Earth’s electrical properties according to conductivity OR resistivity.\n\nHow to included surface topography in the forward simulation.\n\nHow to plot simulated data in pseudosection.\n\n","type":"content","url":"/fwd-dcr-2d","position":1},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-dcr-2d#import-modules","position":2},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to DC resistivity is imported from \n\nsimpeg​.electromagnetics​.static​.resistivity.\nWe also import some useful utility functions from \n\nsimpeg.utils. To simulate DC resistivity data, we need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we used the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import resistivity as dc\nfrom simpeg.utils import model_builder\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import write_dcip2d_ubc\nfrom simpeg import maps, data\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    generate_dcip_sources_line,\n    pseudo_locations,\n    plot_pseudosection,\n    apparent_resistivity_from_voltage,\n)\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Common Python functionality\nimport os\nimport numpy as np\nfrom scipy.interpolate import interp1d\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\n\nmpl.rcParams.update({\"font.size\": 14})  # default font size\n\nwrite_output = False  # Optional\n\n","type":"content","url":"/fwd-dcr-2d#import-modules","position":3},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-dcr-2d#define-the-topography","position":4},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Topography"},"content":"True surface topography is defined as an (N, 3) \n\nnumpy.ndarray.\nFor use in a 2.5D simulation however, topography is defined as an (N, 2) \n\nnumpy.ndarray, where the first coordinate represent along-line position and the second coordinate represents the vertical position. Here, we define the 2D topography used for the 2.5D simulation.\n\n# Along-line locations\nx_topo = np.linspace(-2000, 2000, 401)\n\n# Elevation as a function of along-line location\nT = 800.0\nz_topo = 20.0 * np.sin(2 * np.pi * x_topo / T) + 140.0\nz_topo[x_topo < -3 * T / 4] = 160.0\nz_topo[x_topo > 3 * T / 4] = 120.0\nz_topo += 50.0 * (1.0 + np.tanh(-3 * (x_topo + 1200.0) / T))\nz_topo -= 50.0 * (1.0 + np.tanh(3 * (x_topo - 1200.0) / T))\n\n# Define full 2D topography\ntopo_2d = np.c_[x_topo, z_topo]\n\n# Plot 2D topography\nfig = plt.figure(figsize=(10, 2))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\nax.plot(x_topo, z_topo, color=\"b\", linewidth=2)\nax.set_xlabel(\"x (m)\", labelpad=5)\nax.set_ylabel(\"z (m)\", labelpad=5)\nax.grid(True)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=10)\nplt.show(fig)\n\n","type":"content","url":"/fwd-dcr-2d#define-the-topography","position":5},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Survey"},"type":"lvl2","url":"/fwd-dcr-2d#define-the-survey","position":6},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Survey"},"content":"DC (and IP) surveys within SimPEG require the user to create and connect three types of objects:\n\nreceivers: which defines the locations of the potential (or MN) electrodes and the type of data; e.g. ‘volt’ for normalized voltage (V/A), ‘apparent_resistivity’ for apparent resistivity (\\Omega m) or ‘apparent_chargeability’ for apparent chargeability (unitless). Note only M electrode locations are needed to define pole receivers.\n\nsources: which defines the locations of the current (or AB) electrodes, and their associated receivers. Note only A electrode locations are needed to define pole sources.\n\nsurvey: the object which stores and organizes all of the sources and receivers.\n\nEach DC/IP datum corresponds to a unique pair of current and potential electrode locations. Within the SimPEG framework, there is a standard way in which the electrodes are organized. Because each current source (pole or dipole) is discretized to form a separate right-hand side for the DC resistivity PDE, each source object defines the electrodes for a single source. But for each source object, we can instantiate a single receiver object to store the electrode locations of all potential electrodes.\n\nUsing SimPEG, there are three approaches one might use to generate the a 2.5D resistivity survey. The final approach will be used to simulate the data for this tutorial.\n\nOption A: Define each source and its associated receivers directly\n\nFor a 2.5D simulation, current electrode locations are defined as (2,) \n\nnumpy.array and the associated set of potential electrode locations are defined as (N, 2) \n\nnumpy.ndarray. We can define \n\nPole or \n\nDipole sources. And we can define \n\nPole or \n\nDipole receivers.\n\nHere, the survey consists of an 800 m long EW dipole-dipole line with an electrode spacing of 40 m. There is a maximum of 10 potential electrodes per current electrode. And the data defined by the receivers are current-normalized voltages in V/A.\n\n# Define survey line parameters\nsurvey_type = \"dipole-dipole\"\ndimension_type = \"2D\"\ndata_type = \"volt\"\nend_locations = np.r_[-400.0, 400.0]  # along-line position\nstation_separation = 40.0\nnum_rx_per_src = 10\n\n# Define linear interpolation function for elevation\ninterp_fun = interp1d(x_topo, z_topo)\n\n# Define electrode locations\nelectrode_locations_x = np.arange(\n    end_locations[0], end_locations[1] + station_separation, station_separation\n)\nelectrode_locations_z = interp_fun(electrode_locations_x)\nelectrode_locations = np.c_[electrode_locations_x, electrode_locations_z]\n\n# Number of electrode locations\nn_electrodes = len(electrode_locations_x)\n\n# Instantiate empty list for sources\nsource_list = []\n\nii = 0\nwhile ii < n_electrodes - 3:\n    # A and B electrode locations\n    location_a = electrode_locations[ii, :]\n    location_b = electrode_locations[ii + 1, :]\n\n    # M and N electrode locations\n    ii_max = np.min([ii + 3 + num_rx_per_src, n_electrodes])\n    locations_m = electrode_locations[ii + 2 : ii_max - 1]\n    locations_n = electrode_locations[ii + 3 : ii_max]\n\n    # Define receivers for source ii\n    receivers_list = [\n        dc.receivers.Dipole(\n            locations_m=locations_m, locations_n=locations_n, data_type=data_type\n        )\n    ]\n\n    # Append source ii to list\n    source_list.append(\n        dc.sources.Dipole(receivers_list, location_a=location_a, location_b=location_b)\n    )\n\n    ii += 1\n\n# Define survey\nsurvey = dc.Survey(source_list)\n\nOption B: Survey from ABMN electrode locations\n\nIf we have (N, 2) \n\nnumpy.ndarray for A, B, M and N electrode locations for each datum (loaded or created), we can use the \n\ngenerate​_survey​_from​_abmn​_locations to generate the survey automatically.\n\nOption C: Survey from a set of survey lines\n\nIf the survey is comprised of a single DC resistivity line, we can use the \n\ngenerate​_dcip​_sources​_line utility function to define the source list. I.e.:# Generate source list for DC survey line\nsource_list = generate_dcip_sources_line(\n    survey_type,\n    data_type,\n    dimension_type,\n    end_locations,\n    topo_2d,\n    num_rx_per_src,\n    station_separation,\n)\n\n# Define survey\nsurvey = dc.survey.Survey(source_list, survey_type=survey_type)\n\nWe can extract various objects and properties from the objects used to generate the survey. As we can see, all receivers associated with each source are defined within a single object.\n\nfig = plt.figure(figsize=(10, 2))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\nax.plot(x_topo, z_topo, color=\"b\", linewidth=1)\nax.scatter(electrode_locations_x, electrode_locations_z, 8, \"r\")\nax.set_xlim([x_topo.min(), x_topo.max()])\nax.set_xlabel(\"x (m)\", labelpad=5)\nax.set_ylabel(\"z (m)\", labelpad=5)\nax.grid(True)\nax.set_title(\"Topography and electrode locations\", fontsize=16, pad=10)\nplt.show(fig)\n\nHere we plot the electrode locations. We use the \n\npseudo_locations utility to extract the pseudo-locations.\n\npseudo_locations_xz = pseudo_locations(survey)\nfig = plt.figure(figsize=(8, 2.75))\nax = fig.add_axes([0.1, 0.1, 0.85, 0.8])\nax.scatter(pseudo_locations_xz[:, 0], pseudo_locations_xz[:, -1], 8, \"r\")\nax.set_xlabel(\"x (m)\")\nax.set_ylabel(\"z (m)\")\nax.set_title(\"Pseudo-locations\")\nplt.show()\n\n","type":"content","url":"/fwd-dcr-2d#define-the-survey","position":7},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/fwd-dcr-2d#design-a-tree-mesh","position":8},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Design a (Tree) Mesh"},"content":"Meshes are designed using the \n\ndiscretize package. See the \n\ndiscretize user tutorials to learn more about creating meshes.\nHere, the forward simulation is computed for a \n\ntree mesh. Because of the modular nature of SimPEG, you could define a \n\ntensor mesh instead.\n\nStandard approach for DC/IP: The electric potential produced by a current electrode falls off as r^{-3}. So smaller cells are needed near the current electrodes to model the fields accurately, and larger cells can be used away from the current electrodes where the fields are smooth. Tree meshes are well-suited for DC (and IP) simulation because the cell size can be increased at specified distances from the current electrodes. For DC resistivity meshing, we advise the following considerations and rules of thumb:\n\nBecause there are no currents in the air, we do not need to pad upwards. I.e. the top of the mesh corresponds to the top of the topography.\n\nWe require at least 2-3 cells between each current electrode; with more accurate results being obtained when the minimum cell size is smaller. For a 2.5D problem geometry, we can discretize much finer.\n\nTo be safe, the padding thickness should be at least 2-3 times the largest electrode spacing.\n\nThe increase in cell size at increasing distances from the current electrodes should not happen too abruptly. At each cell size, you should have a layer at least 4 cells thick before increasing the cell size.\n\nFiner discretization is required when topography is significant.\n\nTutorial mesh: Here, a minimum cell width of 4 m (or 1/10 the minimum electrode spacing) is used within our survey region. The largest electrode spacing was 400 m, so a the padding was extended at least 1200 m from the survey region. Using the \n\nrefine_surface method, we refine the tree mesh where there is significant topography. And using the \n\nrefine_points methods, we refine based on electrodes locations. Visit the \n\ntree mesh API to see additional refinement methods.\n\ndh = 4  # base cell width\ndom_width_x = 3200.0  # domain width x\ndom_width_z = 2400.0  # domain width z\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh with top at z = 0 m.\nhx = [(dh, nbcx)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hz], x0=\"CN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, z_topo.max()]\n\n# Mesh refinement based on topography\nmesh.refine_surface(\n    topo_2d,\n    padding_cells_by_level=[0, 0, 4, 4],\n    finalize=False,\n)\n\n# Extract unique electrode locations.\nunique_locations = survey.unique_electrode_locations\n\n# Mesh refinement near electrodes.\nmesh.refine_points(\n    unique_locations, padding_cells_by_level=[8, 12, 6, 6], finalize=False\n)\n\nmesh.finalize()\n\nIf desired, we can extract various properties of the mesh. E.g.\n\nprint(\"# of cells: {}\".format(mesh.n_cells))  # Number of cells\nprint(\"# of x-faces: {}\".format(mesh.n_faces_x))  # Number of x-faces\nprint(\"Origin: {}\".format(mesh.origin))  # bottom-southewest corner\nprint(\"Max cell volume: {}\".format(mesh.cell_volumes.max()))  # Largest cell size\nprint(mesh.cell_centers[0:5, :])  # Cell center locations\n\nAnd we can plot the mesh and electrode locations.\n\nfig = plt.figure(figsize=(10, 4))\n\nax1 = fig.add_axes([0.14, 0.17, 0.8, 0.7])\nmesh.plot_grid(ax=ax1, linewidth=1)\nax1.grid(False)\nax1.set_xlim(-1500, 1500)\nax1.set_ylim(np.max(z_topo) - 1000, np.max(z_topo))\nax1.set_title(\"Mesh\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nplt.show()\n\n","type":"content","url":"/fwd-dcr-2d#design-a-tree-mesh","position":9},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-dcr-2d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Active Cells"},"content":"Simulated geophysical data are dependent on the subsurface distribution of physical property values. As a result, the cells lying below the surface topography are commonly referred to as ‘active cells’. And air cells, whose physical property values are fixed, are commonly referred to as ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_2d)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/fwd-dcr-2d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Models and Mappings"},"type":"lvl2","url":"/fwd-dcr-2d#models-and-mappings","position":12},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Models and Mappings"},"content":"In SimPEG, the term ‘model’ is not necessarily synonymous with the set of physical property values defined on the mesh. For example, the model may be defined as the logarithms of the physical property values, or be the parameters defining a layered Earth geometry. Models in SimPEG are 1D \n\nnumpy.ndarray whose lengths are\nequal to the number of model parameters.\n\nClasses within the \n\nsimpeg.maps module are used to define the mapping that connects the model to the physical property values used in the DC resistivity simulation. Sophisticated mappings can be defined by combining multiple mapping objects. But in the simplest case, the mapping is an identity map and the model consists of the conductivity/resistivity values for all mesh cells (including air).\n\nWhen simulating DC resistivity data, we have the choice of using resistivity or conductivity to define the Earth’s electrical properties. Here, we define the model and its associate mapping for two cases:\n\nThe model consists of the conductivity values for all active cells\n\nThe model consists of the log-resistivity values for all active cells\n\n","type":"content","url":"/fwd-dcr-2d#models-and-mappings","position":13},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl3":"Define the Model","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-dcr-2d#define-the-model","position":14},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl3":"Define the Model","lvl2":"Models and Mappings"},"content":"The units for resistivity are \\Omega m and the units for conductivity are S/m.\n\nair_conductivity = 1e-8\nbackground_conductivity = 1e-2\nconductor_conductivity = 1e-1\nresistor_conductivity = 1e-3\n\n# Define conductivity model\nconductivity_model = background_conductivity * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-120.0, 40.0], 60.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_conductor] = conductor_conductivity\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[120.0, 72.0], 60.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_resistor] = resistor_conductivity\n\n# Define log-resistivity model\nlog_resistivity_model = np.log(1 / conductivity_model)\n\n","type":"content","url":"/fwd-dcr-2d#define-the-model","position":15},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl3":"Mapping from the Model to the Mesh","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-dcr-2d#mapping-from-the-model-to-the-mesh","position":16},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl3":"Mapping from the Model to the Mesh","lvl2":"Models and Mappings"},"content":"For our first case, we use the \n\nsimpeg​.maps​.InjectActiveCells mapping. This mapping projects quantities defined on the active cells to the entire mesh, and sets a constant value for all inactive cells. Important: we set all inactive (air) cells to 1e-8 S/m instead of 0. This is done to ensure that the linear system constructed to solve the PDE for the DC resistivity problem is well-conditioned.\n\nFor the second case, we both the \n\nsimpeg​.maps​.InjectActiveCells and \n\nsimpeg.maps.ExpMap mappings; the latter of which takes the natural exponential. Important: we set all inactive (air) cells to 1e8 \\Omega m instead of \\infty. Once again, this is done to ensure that the linear system constructed to solve the PDE for the DC resistivity problem is well-conditioned.\n\n# Conductivity map. Model parameters are conductivities for all active cells.\nconductivity_map = maps.InjectActiveCells(mesh, active_cells, air_conductivity)\n\n# Resistivity map. Model parameters are log-resistivities for all active cells.\nlog_resistivity_map = maps.InjectActiveCells(\n    mesh, active_cells, 1 / air_conductivity\n) * maps.ExpMap(nP=n_active)\n\n","type":"content","url":"/fwd-dcr-2d#mapping-from-the-model-to-the-mesh","position":17},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl3":"Plot the Model","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-dcr-2d#plot-the-model","position":18},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl3":"Plot the Model","lvl2":"Models and Mappings"},"content":"To show the geometry of the problem, we plot the conductivity model using the \n\nplot_slice method.\n\n# Generate a mapping to ignore inactice cells in plot\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nfig = plt.figure(figsize=(9, 4))\n\nnorm = LogNorm(vmin=1e-3, vmax=1e-1)\n\nax1 = fig.add_axes([0.14, 0.17, 0.68, 0.7])\nmesh.plot_image(\n    plotting_map * conductivity_model,\n    ax=ax1,\n    grid=False,\n    pcolor_opts={\"norm\": norm, \"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_xlim(-500, 500)\nax1.set_ylim(-300, 200)\nax1.set_title(\"Conductivity Model\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.84, 0.17, 0.03, 0.7])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(r\"$\\sigma$ (S/m)\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/fwd-dcr-2d#plot-the-model","position":19},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/fwd-dcr-2d#project-electrodes-to-discretized-topography","position":20},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"content":"Surface DC resistivity data will not be modeled accurately if the electrodes are modeled as living above or below the surface. It is especially problematic when electrodes are modeled as living in the air. Prior to simulating surface DC resistivity data, we must project the electrodes from their true elevation to the surface of the discretized topography. This is done using the \n\ndrape​_electrodes​_on​_topography method.\n\nsurvey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/fwd-dcr-2d#project-electrodes-to-discretized-topography","position":21},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/fwd-dcr-2d#define-the-forward-simulation","position":22},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Define the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class. There are two simulation classes which may be used to simulate 2.5D DC resistivity data:\n\nSimulation2DNodel, which defines the discrete electric potentials on mesh nodes.\n\nSimulation2DCellCentered, which defines the discrete electric potentials at cell centers.\n\nFor surface DC resistivity data, the nodal formulation is more well-suited and will be used here. The cell-centered formulation works well for simulating borehole DC resistivity data. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe mesh\n\nthe mapping from the model to the mesh\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object. Here, we define two simulation objects, one where the model defines the subsurface conductivities, and one where the model defines subsurface log-resistivities. When our model is used to define subsurface electric conductivity, the mapping is set using the sigmaMap keyword argument. However when our model is used to define subsurface electric resistivity, the mapping must be set using the rhoMap keyword argument\n\n# DC simulation for a conductivity model\nsimulation_con = dc.simulation_2d.Simulation2DNodal(\n    mesh, survey=survey, sigmaMap=conductivity_map\n)\n\n# DC simulation for a log-resistivity model\nsimulation_res = dc.simulation_2d.Simulation2DNodal(\n    mesh, survey=survey, rhoMap=log_resistivity_map\n)\n\n","type":"content","url":"/fwd-dcr-2d#define-the-forward-simulation","position":23},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Predict DC Resistivity Data"},"type":"lvl2","url":"/fwd-dcr-2d#predict-dc-resistivity-data","position":24},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Predict DC Resistivity Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. Note that despite the difference in how we defined the models representing the Earth’s electrical properties, the data predicted by both simulations is equivalent.\n\ndpred_con = simulation_con.dpred(conductivity_model)\n\ndpred_res = simulation_res.dpred(log_resistivity_model)\n\nprint(\"MAX ABSOLUTE ERROR = {}\".format(np.max(np.abs(dpred_con - dpred_res))))\n\n","type":"content","url":"/fwd-dcr-2d#predict-dc-resistivity-data","position":25},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Plot Data in Pseudosection"},"type":"lvl2","url":"/fwd-dcr-2d#plot-data-in-pseudosection","position":26},{"hierarchy":{"lvl1":"2.5D Forward Simulation","lvl2":"Plot Data in Pseudosection"},"content":"Here we use the \n\nplot_pseudosection utility function to represent the predicted data on a pseudosection plot as apparent conductivities. Since our receivers were defined to simulate data as normalized voltages, we use the \n\napparent​_resistivity​_from​_voltage utility function to convert the data to apparent resistivities, then take the reciprocal to obtain apparent conductivities.\n\n# Plot voltages pseudo-section\nfig = plt.figure(figsize=(8, 2.75))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    survey,\n    dobs=np.abs(dpred_con),\n    plot_type=\"scatter\",\n    ax=ax1,\n    scale=\"log\",\n    cbar_label=\"V/A\",\n    scatter_opts={\"cmap\": mpl.cm.viridis},\n)\nax1.set_title(\"Normalized Voltages\")\nplt.show()\n\n# Get apparent conductivities from volts and survey geometry\napparent_conductivities = 1 / apparent_resistivity_from_voltage(survey, dpred_con)\n\n# Plot apparent conductivity pseudo-section\nfig = plt.figure(figsize=(8, 2.75))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    survey,\n    dobs=apparent_conductivities,\n    plot_type=\"contourf\",\n    ax=ax1,\n    scale=\"log\",\n    cbar_label=\"S/m\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_title(\"Apparent Conductivity\")\nplt.show()\n\nOptional: Write DC resistivity data and topography.\n\nif write_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_dcr_2d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    # Add 5% Gaussian noise to each datum\n    rng = np.random.default_rng(seed=225)\n    std = 0.05 * np.abs(dpred_con)\n    dc_noise = rng.normal(scale=std, size=len(dpred_con))\n    dobs = dpred_con + dc_noise\n\n    # Create a survey with the original electrode locations\n    # and not the shifted ones\n    # Generate source list for DC survey line\n    source_list = generate_dcip_sources_line(\n        survey_type,\n        data_type,\n        dimension_type,\n        end_locations,\n        topo_2d,\n        num_rx_per_src,\n        station_separation,\n    )\n    survey_original = dc.survey.Survey(source_list)\n\n    # Write out data at their original electrode locations (not shifted)\n    data_obj = data.Data(survey_original, dobs=dobs, standard_deviation=std)\n    fname = dir_path + \"dc_data.obs\"\n    write_dcip2d_ubc(fname, data_obj, \"volt\", \"dobs\")\n\n    fname = dir_path + \"topo_2d.txt\"\n    np.savetxt(fname, topo_2d, fmt=\"%.4e\")","type":"content","url":"/fwd-dcr-2d#plot-data-in-pseudosection","position":27},{"hierarchy":{"lvl1":"3D Forward Simulation"},"type":"lvl1","url":"/fwd-dcr-3d","position":0},{"hierarchy":{"lvl1":"3D Forward Simulation"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nMedium-weight notebook\n\nRequires moderate computational resources. Run-times may exceed several minutes and require up to 8 GB of available RAM.\n\nKeywords: DC Resistivity, forward simulation, 3D, apparent resistivity, tree mesh.\n\nSummary: Here we use the module \n\nsimpeg​.electromagnetics​.static​.resistivity to simulate 3D DC resistivity data on a tree mesh. Most of the functionality required for this tutorial was presented in the \n\n2.5D Forward Simulation tutorial. We strongly urge the reader to work through the 2.5D tutorial prior to working through this one, as we will avoid verbose repitition of content.\n\nLearning Objectives:\n\nDemonstrating 3D forward simulation of DC resistivity data with SimPEG.\n\nSpecific aspects of designing 3D DC resistivity surveys.\n\nGenerating and plotting models on 3D meshes.\n\nHow to plot 3D data in pseudosection.\n\nComputational resource considerations for 3D DC resistivity simulations.\n\n","type":"content","url":"/fwd-dcr-3d","position":1},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-dcr-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to DC resistivity is imported from \n\nsimpeg​.electromagnetics​.static​.resistivity.\nWe also import some useful utility functions from \n\nsimpeg.utils. To simulate DC resistivity data, we need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg import maps, data\nfrom simpeg.utils import model_builder\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import write_dcip_xyz\nfrom simpeg.electromagnetics.static import resistivity as dc\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    generate_dcip_sources_line,\n    pseudo_locations,\n    plot_pseudosection,\n    apparent_resistivity_from_voltage,\n    convert_survey_3d_to_2d_lines,\n)\n\ntry:\n    import plotly\n    from simpeg.electromagnetics.static.utils.static_utils import plot_3d_pseudosection\n    from IPython.core.display import display, HTML\n\n    has_plotly = True\nexcept ImportError:\n    has_plotly = False\n    pass\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import mkvc, active_from_xyz\n\n# Common Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\n\nmpl.rcParams.update({\"font.size\": 14})\n\nwrite_output = False  # Optional\n\n","type":"content","url":"/fwd-dcr-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-dcr-3d#define-the-topography","position":4},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Topography"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray for 3D simulations.\nHere, we create basic topography for the forward simulation.\nFor user-specific simulations, you may load topography from an XYZ file.\n\n# Generate some topography\nx_topo, y_topo = np.meshgrid(\n    np.linspace(-2100, 2100, 141), np.linspace(-2100, 2100, 141)\n)\nz_topo = 410.0 + 140.0 * (1 / np.pi) * (\n    np.arctan((x_topo - 500 * np.sin(np.pi * y_topo / 2800) - 400.0) / 200.0)\n    - np.arctan((x_topo - 500 * np.sin(np.pi * y_topo / 2800) + 400.0) / 200.0)\n)\n\n# Turn into a (N, 3) numpy.ndarray\nx_topo, y_topo, z_topo = mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)\ntopo_xyz = np.c_[mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)]\n\n# Plot the topography\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([-400, 400])\nax.scatter3D(topo_xyz[:, 0], topo_xyz[:, 1], topo_xyz[:, 2], s=0.25, c=\"b\")\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=45.0, azim=-125)\n\n","type":"content","url":"/fwd-dcr-3d#define-the-topography","position":5},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Survey"},"type":"lvl2","url":"/fwd-dcr-3d#define-the-survey","position":6},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Survey"},"content":"Descriptions of the elements required to construct DC resistivity surveys were covered in the \n\n2.5D Forward Simulation tutorial. The only difference is that for 3D surveys, XYZ locations are required for each electrode location. Once again, there are three approaches one might use to generate the a DC resistivity survey. The final approach will be used to simulate the data for this tutorial.\n\nOption A: Define each source and its associated receivers directly\n\nWe used this approach in our \n\n2.5D Forward Simulation tutorial. For a 3D simulation however, current electrode locations are defined as (3,) \n\nnumpy.array and the associated set of potential electrode locations are defined as (N, 3) \n\nnumpy.ndarray. This approach is somewhat cumbersome for generating synthetic 3D examples, so we will use a survey generation utility instead (Option C).\n\nOption B: Survey from ABMN electrode locations\n\nIf we have (N, 3) \n\nnumpy.ndarray containing the A, B, M and N electrode locations for each datum (loaded or created), we can use the \n\ngenerate​_survey​_from​_abmn​_locations to generate the survey automatically.\n\nOption C: Survey from a set of survey lines\n\nIf the survey is comprised of a set of DC resistivity lines, we can use the \n\ngenerate​_dcip​_sources​_line utility function to define the survey. Here we define the DC resistivity survey that is used simulate the tutorial data. The survey consists of 3 DC resistivity lines that use a dipole-dipole electrode configuration; 1 line along the East-West direction and 2 lines along the North-South direction. Each line is 2000 m in length and has an electrode spacing of 100 m.\n\n# Define the parameters for each survey line\nsurvey_type = \"dipole-dipole\"\ndata_type = \"volt\"\ndimension_type = \"3D\"\nend_locations_list = [\n    np.r_[-1000.0, 1000.0, 0.0, 0.0],\n    np.r_[-600.0, -600.0, -1000.0, 1000.0],\n    np.r_[-300.0, -300.0, -1000.0, 1000.0],\n    np.r_[0.0, 0.0, -1000.0, 1000.0],\n    np.r_[300.0, 300.0, -1000.0, 1000.0],\n    np.r_[600.0, 600.0, -1000.0, 1000.0],\n]  # [x0, x1, y0, y1]\nstation_separation = 100.0\nnum_rx_per_src = 8\n\n# The source lists for each line can be appended to create the source\n# list for the whole survey.\nsource_list = []\nfor ii in range(0, len(end_locations_list)):\n    source_list += generate_dcip_sources_line(\n        survey_type,\n        data_type,\n        dimension_type,\n        end_locations_list[ii],\n        topo_xyz,\n        num_rx_per_src,\n        station_separation,\n    )\n\n# Define the survey\nsurvey = dc.survey.Survey(source_list)\n\nHere we plot the electrode locations. We use the \n\nunique​_electrode​_locations method to extract the unique electrode locations from the survey and the \n\npseudo_locations utility to extract the pseudo-location.\n\nunique_locations = survey.unique_electrode_locations\nfig = plt.figure(figsize=(12, 2.75))\nax1 = fig.add_axes([0.1, 0.1, 0.2, 0.8])\nax1.scatter(unique_locations[:, 0], unique_locations[:, 1], 8, \"r\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\nax1.set_title(\"Horizontal locations\")\n\npseudo_locations_xyz = pseudo_locations(survey)\ninds = pseudo_locations_xyz[:, 1] == 0.0\nax2 = fig.add_axes([0.4, 0.1, 0.55, 0.8])\nax2.scatter(pseudo_locations_xyz[inds, 0], pseudo_locations_xyz[inds, -1], 8, \"r\")\nax2.set_xlabel(\"x (m)\")\nax2.set_ylabel(\"z (m)\")\nax2.set_title(\"Pseudo-locations (EW line)\")\nplt.show()\n\n","type":"content","url":"/fwd-dcr-3d#define-the-survey","position":7},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/fwd-dcr-3d#design-a-tree-mesh","position":8},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Design a (Tree) Mesh"},"content":"Standard approach for DC/IP: The standard approach presented in the \n\n2.5D Forward Simulation tutorial also applies to forward simulations in 3D. And the same methods are used to refine the tree mesh around electrodes, topography, etc... For 3D simulations however, we may need to consider limitations in computational resources which are not encountered in 2.5D simulations. Because 3D simulations require discretization along a third direction, the number of cells in the mesh is proportional h^{-3}; where h is the minimum cell edge length. Therefore the minimum cell size used for 3D simulations is generally coarser than the minimum cell size used for 2.5D simulations.\n\nTutorial mesh: Here, a minimum cell width of 25 m (or 1/4 the minimum electrode spacing) is used within our survey region. The largest electrode spacing was 1000 m, so a the padding was extended at least 3000 m from the survey region. Using the \n\nrefine_surface method, we refine the tree mesh where there is significant topography. And using the \n\nrefine_points methods, we refine based on electrodes locations. Visit the \n\ntree mesh API to see additional refinement methods.\n\n# Defining domain size and minimum cell size\ndh = 25.0  # base cell width\ndom_width_x = 8000.0  # domain width x\ndom_width_y = 8000.0  # domain width y\ndom_width_z = 4000.0  # domain width z\n\n# Number of base mesh cells in each direction. Must be a power of 2\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcy = 2 ** int(np.round(np.log(dom_width_y / dh) / np.log(2.0)))  # num. base cells y\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh\nhx = [(dh, nbcx)]\nhy = [(dh, nbcy)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, 0.0, z_topo.max()]\n\n# Mesh refinement based on surface topography\nk = np.sqrt(np.sum(topo_xyz[:, 0:2] ** 2, axis=1)) < 1200\nmesh.refine_surface(topo_xyz[k, :], padding_cells_by_level=[0, 4, 4], finalize=False)\n\n# Mesh refinement near electrodes.\nmesh.refine_points(unique_locations, padding_cells_by_level=[6, 6, 4], finalize=False)\n\n# Finalize the mesh\nmesh.finalize()\n\n","type":"content","url":"/fwd-dcr-3d#design-a-tree-mesh","position":9},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-dcr-3d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Active Cells"},"content":"Simulated geophysical data are dependent on the subsurface distribution of physical property values. As a result, the cells lying below the surface topography are commonly referred to as ‘active cells’. And air cells, whose physical property values are fixed, are commonly referred to as ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/fwd-dcr-3d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Models and Mappings"},"type":"lvl2","url":"/fwd-dcr-3d#models-and-mappings","position":12},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Models and Mappings"},"content":"In SimPEG, the term ‘model’ is not necessarily synonymous with the set of physical property values defined on the mesh. For example, the model may be defined as the logarithms of the physical property values, or be the parameters defining a layered Earth geometry. Models in SimPEG are 1D \n\nnumpy.ndarray whose lengths are\nequal to the number of model parameters.\n\nClasses within the \n\nsimpeg.maps module are used to define the mapping that connects the model to the physical property values used in the DC resistivity simulation. Sophisticated mappings can be defined by combining multiple mapping objects. But in the simplest case, the mapping is an identity map and the model consists of the conductivity/resistivity values for all mesh cells (including air).\n\nWhen simulating DC resistivity data, we have the choice of using resistivity or conductivity to define the Earth’s electrical properties. Here, we define the model and its associate mapping for two cases:\n\nThe model consists of the conductivity values for all active cells\n\nThe model consists of the log-resistivity values for all active cells\n\n","type":"content","url":"/fwd-dcr-3d#models-and-mappings","position":13},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Define the Model","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-dcr-3d#define-the-model","position":14},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Define the Model","lvl2":"Models and Mappings"},"content":"The units for resistivity are \\Omega m and the units for conductivity are S/m.\n\n# Define conductivity values in S/m (take reciprocal for resistivities in Ohm m)\nair_conductivity = 1e-8\nbackground_conductivity = 1e-2\nconductor_conductivity = 1e-1\nresistor_conductivity = 1e-3\n\n# Define conductivity model\nconductivity_model = background_conductivity * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_conductor] = conductor_conductivity\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_resistor] = resistor_conductivity\n\n# Define log-resistivity model\nlog_resistivity_model = np.log(1 / conductivity_model)\n\n","type":"content","url":"/fwd-dcr-3d#define-the-model","position":15},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Mapping from the Model to the Mesh","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-dcr-3d#mapping-from-the-model-to-the-mesh","position":16},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Mapping from the Model to the Mesh","lvl2":"Models and Mappings"},"content":"For our first case, we use the \n\nsimpeg​.maps​.InjectActiveCells mapping. This mapping projects quantities defined on the active cells to the entire mesh, and sets a constant value for all inactive cells. Important: we set all inactive (air) cells to 1e-8 S/m instead of 0. This is done to ensure that the linear system constructed to solve the PDE for the DC resistivity problem is well-conditioned.\n\nFor the second case, we use both the \n\nsimpeg​.maps​.InjectActiveCells and \n\nsimpeg.maps.ExpMap mappings; the latter of which takes the natural exponential. Important: we set all inactive (air) cells to 1e8 \\Omega m instead of \\infty. Once again, this is done to ensure that the linear system constructed to solve the PDE for the DC resistivity problem is well-conditioned.\n\n# Conductivity map. Model parameters are conductivities for all active cells.\nconductivity_map = maps.InjectActiveCells(mesh, active_cells, air_conductivity)\n\n# Resistivity map. Model parameters are log-resistivities for all active cells.\nlog_resistivity_map = maps.InjectActiveCells(\n    mesh, active_cells, 1 / air_conductivity\n) * maps.ExpMap(nP=n_active)\n\n","type":"content","url":"/fwd-dcr-3d#mapping-from-the-model-to-the-mesh","position":17},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Plot the Model","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-dcr-3d#plot-the-model","position":18},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Plot the Model","lvl2":"Models and Mappings"},"content":"To show the geometry of the problem, we plot the conductivity model using the \n\nplot_slice method.\n\n# Generate a mapping to ignore inactice cells in plot\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nfig = plt.figure(figsize=(10, 4.5))\n\nnorm = LogNorm(vmin=1e-3, vmax=1e-1)\n\nax1 = fig.add_axes([0.15, 0.15, 0.68, 0.75])\nmesh.plot_slice(\n    plotting_map * conductivity_model,\n    ax=ax1,\n    normal=\"Y\",\n    ind=int(len(mesh.h[1]) / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": norm},\n)\nax1.set_title(\"Conductivity Model\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\nax1.set_xlim([-1500, 1500])\nax1.set_ylim([z_topo.max() - 1500, z_topo.max()])\n\nax2 = fig.add_axes([0.84, 0.15, 0.03, 0.75])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, cmap=mpl.cm.RdYlBu_r, norm=norm, orientation=\"vertical\"\n)\ncbar.set_label(r\"$\\sigma$ [S/m]\", rotation=270, labelpad=15, size=16)\n\n","type":"content","url":"/fwd-dcr-3d#plot-the-model","position":19},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/fwd-dcr-3d#project-electrodes-to-discretized-topography","position":20},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"content":"Surface DC resistivity data will not be modeled accurately if the electrodes are modeled as living above or below the surface. It is especially problematic when electrodes are modeled as living in the air. Prior to simulating surface DC resistivity data, we must project the electrodes from their true elevation to the surface of the discretized topography. This is done using the \n\ndrape​_electrodes​_on​_topography method.\n\nsurvey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/fwd-dcr-3d#project-electrodes-to-discretized-topography","position":21},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/fwd-dcr-3d#define-the-forward-simulation","position":22},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Define the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class. There are two simulation classes which may be used to simulate 3D DC resistivity data:\n\nSimulation3DNodel, which defines the discrete electric potentials on mesh nodes.\n\nSimulation3DCellCentered, which defines the discrete electric potentials at cell centers.\n\nFor surface DC resistivity data, the nodal formulation is more well-suited and will be used here. The cell-centered formulation works well for simulating borehole DC resistivity data. Here, we define two simulation objects, one where the model defines the subsurface conductivities, and one where the model defines subsurface log-resistivities. When our model is used to define subsurface electric conductivity, the mapping is set using the sigmaMap keyword argument. However when our model is used to define subsurface electric resistivity, the mapping must be set using the rhoMap keyword argument\n\n# DC simulation for a conductivity model\nsimulation_con = dc.simulation.Simulation3DNodal(\n    mesh, survey=survey, sigmaMap=conductivity_map\n)\n\n# DC simulation for a log-resistivity model\nsimulation_res = dc.simulation.Simulation3DNodal(\n    mesh, survey=survey, rhoMap=log_resistivity_map\n)\n\n","type":"content","url":"/fwd-dcr-3d#define-the-forward-simulation","position":23},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Predict DC Resistivity Data"},"type":"lvl2","url":"/fwd-dcr-3d#predict-dc-resistivity-data","position":24},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Predict DC Resistivity Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. Note that despite the difference in how we defined the models representing the Earth’s electrical properties, the data predicted by both simulations is equivalent.\n\ndpred_con = simulation_con.dpred(conductivity_model)\n\ndpred_res = simulation_res.dpred(log_resistivity_model)\n\nprint(\"MAX ABSOLUTE ERROR = {}\".format(np.max(np.abs(dpred_con - dpred_res))))\n\n","type":"content","url":"/fwd-dcr-3d#predict-dc-resistivity-data","position":25},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Convert Normalized Voltages to Apparent Conductivities"},"type":"lvl2","url":"/fwd-dcr-3d#convert-normalized-voltages-to-apparent-conductivities","position":26},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Convert Normalized Voltages to Apparent Conductivities"},"content":"In this tutorial, the receivers were defined to simulation normalized voltage data. Here, we use the \n\napparent​_resistivity​_from​_voltage utility function to convert the data to apparent resistivities, then take the reciprocal to obtain apparent conductivities.\n\napparent_conductivity = apparent_resistivity_from_voltage(survey, dpred_con) ** -1\n\n","type":"content","url":"/fwd-dcr-3d#convert-normalized-voltages-to-apparent-conductivities","position":27},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Plot Data in Pseudosection"},"type":"lvl2","url":"/fwd-dcr-3d#plot-data-in-pseudosection","position":28},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl2":"Plot Data in Pseudosection"},"content":"\n\n","type":"content","url":"/fwd-dcr-3d#plot-data-in-pseudosection","position":29},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Plot 3D Pseudosection","lvl2":"Plot Data in Pseudosection"},"type":"lvl3","url":"/fwd-dcr-3d#plot-3d-pseudosection","position":30},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Plot 3D Pseudosection","lvl2":"Plot Data in Pseudosection"},"content":"For general 3D survey configurations, we can use the \n\nplot​_3d​_pseudosection utility function to plot 3D pseudosection data. For large datasets or for surveys with unconventional electrode geometry, interpretation can be challenging if we plot every datum. Here, we plot 3 out of the 6 survey lines to better image anomalous structures. To plot ALL of the data, simply remove the keyword argument plane_points when calling plot_3d_pseudosection. To use this utility, you must have Python’s \n\nplotly package.\n\n# Empty list for plane points\nplane_points = []\n\n# 3-points defining the plane for EW survey line\np1, p2, p3 = np.array([-1000, 0, 0]), np.array([1000, 0, 0]), np.array([0, 0, -1000])\nplane_points.append([p1, p2, p3])\n\n# NS at x = -300 m\np1, p2, p3 = (\n    np.array([-300, -1000, 0]),\n    np.array([-300, 1000, 0]),\n    np.array([-300, 0, -1000]),\n)\nplane_points.append([p1, p2, p3])\n\n# NS at x = 300 m\np1, p2, p3 = (\n    np.array([300, -1000, 0]),\n    np.array([300, 1000, 0]),\n    np.array([300, 0, -1000]),\n)\nplane_points.append([p1, p2, p3])\n\nif has_plotly:\n    fig = plot_3d_pseudosection(\n        survey,\n        apparent_conductivity,\n        scale=\"log\",\n        units=\"S/m\",\n        plane_points=plane_points,\n        plane_distance=15,\n        marker_opts={\"colorscale\": \"RdYlBu_r\"},\n    )\n\n    fig.update_layout(\n        title_text=\"Apparent Conductivity\",\n        title_x=0.5,\n        title_font_size=24,\n        width=650,\n        height=500,\n        scene_camera=dict(center=dict(x=0.05, y=0, z=-0.4)),\n    )\n\n    #     plotly.io.show(fig)\n    html_str = plotly.io.to_html(fig)\n    display(HTML(html_str))\n\nelse:\n    print(\"INSTALL 'PLOTLY' TO VISUALIZE 3D PSEUDOSECTIONS\")\n\n","type":"content","url":"/fwd-dcr-3d#plot-3d-pseudosection","position":31},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Plot Individual Lines in 2D Pseudosection","lvl2":"Plot Data in Pseudosection"},"type":"lvl3","url":"/fwd-dcr-3d#plot-individual-lines-in-2d-pseudosection","position":32},{"hierarchy":{"lvl1":"3D Forward Simulation","lvl3":"Plot Individual Lines in 2D Pseudosection","lvl2":"Plot Data in Pseudosection"},"content":"For conventional DC resistivity surveys, the electrodes are located along a set of survey lines. If we know which the survey line associated with each datum, we can parse the 3D survey into a set of 2D survey lines. Then we can plot individual pseudosections for each survey line. Here, we have 6 survey lines, each of which has the same number of data. So assigning a line ID to each datum is easy. You may need to do something more sophisticated in other cases.\n\n# line IDs\nn_lines = len(end_locations_list)\nn_data_per_line = int(survey.nD / n_lines)\nlineID = np.hstack([(ii + 1) * np.ones(n_data_per_line) for ii in range(n_lines)])\n\nHere, we use the \n\nconvert​_survey​_3d​_to​_2d​_lines to generate the list of 2D surveys.\n\nsurvey_2d_list, index_list = convert_survey_3d_to_2d_lines(\n    survey, lineID, data_type=\"volt\", output_indexing=True\n)\n\nNext, we create list of 2D apparent conductivities. Note that if you converted observed data then computed apparent conductivities, you would be doing so assuming 2D survey geometry and the values would not match those on the 3D pseudosection plot!\n\ndobs_2d_list = []\napparent_conductivities_2d = []\nfor ind in index_list:\n    dobs_2d_list.append(dpred_con[ind])\n    apparent_conductivities_2d.append(apparent_conductivity[ind])\n\nNow we can use the \n\nplot​_2d​_pseudosection utility function to plot the pseudosection for the desired survey line.\n\n# Line index\nline_ind = 0\n\n# Plot apparent conductivity pseudo-section\nfig = plt.figure(figsize=(8, 2.75))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    survey_2d_list[line_ind],\n    dobs=apparent_conductivities_2d[line_ind],\n    plot_type=\"contourf\",\n    ax=ax1,\n    scale=\"log\",\n    cbar_label=\"S/m\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_title(\"Apparent Conductivity\")\nplt.show()\n\nOptional: Write DC resistivity data and topography.\n\nif write_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_dcr_3d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    # Add 10% Gaussian noise to each datum\n    rng = np.random.default_rng(seed=433)\n    std = 0.1 * np.abs(dpred_con)\n    noise = rng.normal(scale=std, size=len(dpred_con))\n    dobs = dpred_con + noise\n\n    # Create dictionary that stores line IDs\n    out_dict = {\"LINEID\": lineID}\n\n    # Create a survey with the original electrode locations\n    # and not the shifted ones\n    source_list = []\n    for ii in range(n_lines):\n        source_list += generate_dcip_sources_line(\n            survey_type,\n            data_type,\n            dimension_type,\n            end_locations_list[ii],\n            topo_xyz,\n            num_rx_per_src,\n            station_separation,\n        )\n    survey_original = dc.survey.Survey(source_list)\n\n    # Write out data at their original electrode locations (not shifted)\n    data_obj = data.Data(survey_original, dobs=dobs, standard_deviation=std)\n\n    fname = dir_path + \"dc_data.xyz\"\n    write_dcip_xyz(\n        fname,\n        data_obj,\n        data_header=\"V/A\",\n        uncertainties_header=\"UNCERT\",\n        out_dict=out_dict,\n    )\n\n    fname = dir_path + \"topo_xyz.txt\"\n    np.savetxt(fname, topo_xyz, fmt=\"%.4e\")","type":"content","url":"/fwd-dcr-3d#plot-individual-lines-in-2d-pseudosection","position":33},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding"},"type":"lvl1","url":"/inv-dcr-1d","position":0},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: DC resistivity, 1D sounding, inversion, parametric, sparse norm, apparent resistivity, wires mapping.\n\nSummary: Here we invert DC resistivity data for a single Wenner sounding. We demonstrate 3 approaches that can be used to invert 1D data in SimPEG:\n\nA weighted least-squares inversion where the number of layers and their thicknesses are fixed.\n\nAn iteratively reweighted least-squares (IRLS) inversion to recover sparse and/or blocky structures.\n\nA parametric inversion where we invert for the layer thicknesses and electrical properties assuming a 3-layered Earth.\n\nThe weighted least-squares approach is a great introduction to geophysical inversion with SimPEG. One drawback however, is that it recovers smooth structures which may not be representative of the true model. To recover sparse and/or blocky 1D structures, we demonstrate an iteratively reweighted least-squares approach. If the number of layers is known, but their depths, thicknesses and conductivities are not, we can use a parametric inversion approach.\n\nLearning Objectives: Because this tutorial focusses primarily on inversion-related functionality, we urge the reader to become familiar with functionality explained in the \n\n1D Forward Simulation of DC Resistivity Data tutorial before working through this one. For this tutorial, we focus on:\n\nGeneral approaches for 1D inversion with SimPEG.\n\nHow to assign appropriate uncertainties to apparent resistivity or normalized voltage data.\n\nChoosing suitable parameters for the inversion.\n\nSpecifying directives that are applied throughout the inversion.\n\nWeighted least-squares, sparse-norm and parametric inversion.\n\nAnalyzing inversion outputs.\n\n","type":"content","url":"/inv-dcr-1d","position":1},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Import Modules"},"type":"lvl2","url":"/inv-dcr-1d#import-modules","position":2},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to the forward simulation of 1D DC resistivity data are imported from the \n\nsimpeg​.electromagnetics​.static​.resistivity module. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import resistivity as dc\nfrom simpeg.utils import plot_1d_layer_model, download\nfrom simpeg import (\n    maps,\n    data,\n    data_misfit,\n    regularization,\n    optimization,\n    inverse_problem,\n    inversion,\n    directives,\n)\n\n# discretize functionality\nfrom discretize import TensorMesh\n\n# Basic Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport tarfile\n\nmpl.rcParams.update({\"font.size\": 14})\n\n","type":"content","url":"/inv-dcr-1d#import-modules","position":3},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Download Tutorial Files"},"type":"lvl2","url":"/inv-dcr-1d#download-tutorial-files","position":4},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Download Tutorial Files"},"content":"For this tutorial, the observed data for the Wenner sounding are stored within a tar-file. Here, we download and extract the data file.\n\n# URL to download from repository assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/05-dcr/inv_dcr_1d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ndata_filename = dir_path + \"app_res_1d_data.dobs\"\n\n","type":"content","url":"/inv-dcr-1d#download-tutorial-files","position":5},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Load and Plot the Data"},"type":"lvl2","url":"/inv-dcr-1d#load-and-plot-the-data","position":6},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Load and Plot the Data"},"content":"Here, we load and parse the data file containing observed data and survey geometry. The data file contains the xyz locations for the A, B, M and N electrodes, in order, as well as the observed data. We then compute the AB/2 (half separation distance) and plot the Wenner sounding data.\n\n# Load data\ndobs = np.loadtxt(str(data_filename))\n\n# Extract A, B, M and N electrode locations and the observed data\nA_electrodes = dobs[:, 0:3]\nB_electrodes = dobs[:, 3:6]\nM_electrodes = dobs[:, 6:9]\nN_electrodes = dobs[:, 9:12]\ndobs = dobs[:, -1]\n\n# Compute the AB/2 separation for the 1D Wenner array\nAB_separations = np.sqrt(np.sum((A_electrodes - B_electrodes) ** 2, axis=1))\n\n# Plot apparent resistivity as a function of AB/2\nfig = plt.figure(figsize=(8, 4))\nmpl.rcParams.update({\"font.size\": 14})\nax1 = fig.add_axes([0.15, 0.1, 0.7, 0.85])\nax1.semilogy(AB_separations / 2, dobs, \"b-o\")\nax1.grid(which=\"both\")\nax1.set_xlabel(\"AB/2 (m)\")\nax1.set_ylabel(r\"Apparent Resistivity ($\\Omega m$)\")\nplt.show()\n\n","type":"content","url":"/inv-dcr-1d#load-and-plot-the-data","position":7},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-dcr-1d#assign-uncertainties","position":8},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor 1D apparent resistivity data, we generally apply a percent uncertainty to all data. A percent uncertainty will fit conductive and resistive structures equally; unlike a floor uncertainty which will prioritize fitting more resistive structures. For this tutorial, we apply a 2% uncertainty to all data. Depending on the quality of the data, we may choose a percent uncertainty between 2% - 10%.\n\nFor 1D normalized voltage data, we also tend to apply a percent uncertainty to all data. Differences in electrode spacing and subsurface conductivity result in measured voltages that span many orders of magnitude. A percent uncertainty ensures all data are fit equally. Like apparent resistivity, a percent uncertainty of 2% - 10% is a good initial guess.\n\nNOTE: if the data contain very small values that you feel could be erroneous, a small floor value can be added to ensure stability of the inversion.\n\n# Add 2.5% uncertainties to all data.\nuncertainties = 0.025 * np.abs(dobs)\n\n","type":"content","url":"/inv-dcr-1d#assign-uncertainties","position":9},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Define the Survey"},"type":"lvl2","url":"/inv-dcr-1d#define-the-survey","position":10},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Define the Survey"},"content":"Here, we define the survey geometry. Although the survey consists of a single 1D Wenner sounding, the approach is generalized for 2D and 3D surveys where the electrode locations may not be sorted. For a comprehensive description of constructing DC resistivity surveys in SimPEG, see the \n\n1D Forward Simulation of DC Resistivity Data tutorial.\n\n# Sort by unique current electrode locations\nunique_tx, k = np.unique(np.c_[A_electrodes, B_electrodes], axis=0, return_index=True)\nn_sources = len(k)\nk = np.sort(k)\nk = np.r_[k, len(k) + 1]\n\n# Define empty list for sources to live\nsource_list = []\n\n# Loop over all sources\nfor ii in range(0, n_sources):\n    # MN electrode locations for receivers. Each is an (N, 3) numpy array\n    M_locations = M_electrodes[k[ii] : k[ii + 1], :]\n    N_locations = N_electrodes[k[ii] : k[ii + 1], :]\n    receiver_list = [\n        dc.receivers.Dipole(\n            M_locations,\n            N_locations,\n            data_type=\"apparent_resistivity\",\n        )\n    ]\n\n    # AB electrode locations for source. Each is a (1, 3) numpy array\n    A_location = A_electrodes[k[ii], :]\n    B_location = B_electrodes[k[ii], :]\n    source_list.append(dc.sources.Dipole(receiver_list, A_location, B_location))\n\n# Define survey\nsurvey = dc.Survey(source_list)\n\n","type":"content","url":"/inv-dcr-1d#define-the-survey","position":11},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Define the Data"},"type":"lvl2","url":"/inv-dcr-1d#define-the-data","position":12},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Define the Data"},"content":"The SimPEG \n\nData class is required for inversion and connects the observed data, uncertainties and survey geometry.\n\ndata_object = data.Data(survey, dobs=dobs, standard_deviation=uncertainties)\n\n","type":"content","url":"/inv-dcr-1d#define-the-data","position":13},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-dcr-1d#weighted-least-squares-inversion","position":14},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the weighted least-squares inversion approach to recover the log-conductivities on a 1D layered Earth. We impose no a-priori information about the number of layers (geological units) or their thicknesses. Instead, we define a large number of layers with exponentially increasing thicknesses. And the depth, thickness and electrical properties of the Earth are inferred from the recovered model.\n\n","type":"content","url":"/inv-dcr-1d#weighted-least-squares-inversion","position":15},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Design a 1D Layered Earth","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#design-a-1d-layered-earth","position":16},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Design a 1D Layered Earth","lvl2":"Weighted Least-Squares Inversion"},"content":"When the spacings between the electrodes are small, we are obtaining higher resolution information about the conductivity near the Earth’s surface. As a result, we define much thinner layers near the Earth’s surface. When the spacings between electrodes are large, we are obtaining lower resolution information about the conductivity at depth. So at depth, we can define layers that are much thicker. The thickness defining the top layer is ultimately determined by the minimum electrode spacing. And the thickness and depth to the lower layer is determined by the largest electrode spacing. The rate at which the layer thicknesses increase with depth is determined by the user.\n\nFor Wenner soundings: For the 1D Wenner array, the layer thicknesses and largest depth are determined by the AB/2 spacing. A reasonable minimum layer thickness is 10% the minimum AB/2 spacing. And the depth to the bottom layer should be roughly equal to the largest AB/2 spacing.\n\nFor dipole-dipole, pole-dipole, etc...: For these surveys, the source electrodes AB and receiver electrodes MN are offset from one another. For a particular set of electrodes ABMN, we consider the distance between the average source location and average receiver location. For a dipole-dipole survey, this would be:d = \\Bigg | \\frac{\\vec{r}_A+\\vec{r}_B}{2} - \\frac{\\vec{r}_M+\\vec{r}_N}{2} \\Bigg |\n\nFor a pole-dipole survey, this would be:\\, \nd = \\Bigg | \\, \\vec{r}_A - \\frac{\\vec{r}_M+\\vec{r}_N}{2} \\Bigg |\n\nPole sources penetrate the Earth more deeply and produce smoother fields within the source region, so we can get away with a larger layer thickness for the top layer but we need to discretize deeper. But in general, it is easy to make your your top layer equal to 10% of your smallest distance. And to make the depth to the lower layer equal to the largest distance.\n\n# Use Wenner electrode spacings to set discretization parameters\nprint(\"AB separations: {}\".format(AB_separations))\ndepth_min = 5.0  # top layer thickness\ndepth_max = np.max(AB_separations / 2)  # depth to lowest layer\ngeometric_factor = 1.1  # rate of thickness increase\n\n# Increase subsequent layer thicknesses by the geometric factors until\n# it reaches the maximum layer depth.\nlayer_thicknesses = [depth_min]\nwhile np.sum(layer_thicknesses) < depth_max:\n    layer_thicknesses.append(geometric_factor * layer_thicknesses[-1])\n\nn_layers = len(layer_thicknesses) + 1  # Number of layers\n\n","type":"content","url":"/inv-dcr-1d#design-a-1d-layered-earth","position":17},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define a Model and Mapping","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-a-model-and-mapping","position":18},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define a Model and Mapping","lvl2":"Weighted Least-Squares Inversion"},"content":"Recall from the \n\nForward Simulation of 1D Sounding DC Resistivity Data tutorial that the ‘model’ is not necessarily synonymous with physical property values. And that we need to define a mapping from the model to the set of input parameters required by the forward simulation. When inverting to recover electrical resistivities (or conductivities), it is best to use the log-value, as electrical resistivities (or conductivities) of rocks span many order of magnitude.\n\nHere, the model defines the log-resistivity values for a defined set of subsurface layers. And we use the \n\nsimpeg.maps.ExpMap to map from the model parameters to the resistivity values required by the forward simulation.\n\nlog_resistivity_map = maps.ExpMap(nP=n_layers)\n\n","type":"content","url":"/inv-dcr-1d#define-a-model-and-mapping","position":19},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#starting-reference-models","position":20},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"content":"The starting model defines a reasonable starting point for the inversion. Because electromagnetic problems are non-linear, your choice in starting model does have an impact on the recovered model. For DC resistivity inversion, we generally choose our starting model based on apparent resistivities. For the tutorial example, the apparent resistivities were near 1000 \\Omega m. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration.\n\nThe reference model is used to include a-priori information. The impact of the reference model on the inversion will be discussed in another tutorial. The reference model for basic inversion approaches is either zero or equal to the starting model.\n\nNotice that the length of the starting and reference models is equal to the number of model parameters!!!\n\n# Starting model is log-resistivity values (Ohmm)\nstarting_resistivity_model = np.log(1e3 * np.ones(n_layers))\n\n# Reference model is also log-resistivity values (Ohmm)\nreference_resistivity_model = starting_resistivity_model.copy()\n\n","type":"content","url":"/inv-dcr-1d#starting-reference-models","position":21},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-forward-simulation","position":22},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for 1D DC resistivity was discussed in the \n\n1D Forward Simulation of DC Resistivity Data for a Single Sounding tutorial. Here, we use the \n\nSimulation1DLayers which simulates the data according to a 1D Hankel transform solution.\n\nThe layer thicknesses are a static property of the simulation, and we set them using the thicknessess keyword argument. Since our model consists of log-resistivities, we use rhoMap to set the mapping from the model to the layer resistivities.\n\nsimulation_L2 = dc.simulation_1d.Simulation1DLayers(\n    survey=survey,\n    rhoMap=log_resistivity_map,\n    thicknesses=layer_thicknesses,\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-forward-simulation","position":23},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-data-misfit","position":24},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(simulation=simulation_L2, data=data_object)\n\n","type":"content","url":"/inv-dcr-1d#define-the-data-misfit","position":25},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-regularization","position":26},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource.\n\nTo define the regularization within SimPEG, we must define a 1D \n\ntensor mesh. Meshes are designed using the \n\ndiscretize package. Whereas layer thicknesses and our model are defined from our top-layer down, tensor meshes are defined from the bottom up. So to define a 1D tensor mesh for the regularization, we:\n\nadd an extra layer to the end of our thicknesses so that the number of cells in the 1D mesh equals the number of model parameters\n\nreverse the order so that the model parameters in the regularization match up with the appropriate cell\n\ndefine the tensor mesh from the cell widths\n\n# Define 1D cell widths\nh = np.r_[layer_thicknesses, layer_thicknesses[-1]]\nh = np.flipud(h)\n\n# Create regularization mesh\nregularization_mesh = TensorMesh([h], \"N\")\nprint(regularization_mesh)\n\nBy default, the regularization acts on the model parameters. In this case, the model parameters are the log-resistivities, not the electric resistivities!!! Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Here, length scale along x are used to balance the smallness and smoothness terms; yes, x is smoothness along the vertical direction. And the reference model is only applied to the smallness term. If we wanted to apply the regularization to a function of the model parameters, we would need to set an approprate mapping object using the mapping keyword argument.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    regularization_mesh,\n    length_scale_x=1.0,\n    reference_model=reference_resistivity_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-regularization","position":27},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-optimization-algorithm","position":28},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the \n\nInexactGaussNewton class to solve the optimization problem using the inexact Gauss Newton with conjugate gradient solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches.\n\nopt_L2 = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-optimization-algorithm","position":29},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-inverse-problem","position":30},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-dcr-1d#define-the-inverse-problem","position":31},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#provide-inversion-directives","position":32},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"content":"Directives represent operations that are carried out during the inversion. Here, we apply common directives for weighted least-squares inversion of DC resistivity data and describe their roles. These are:\n\nUpdateSensitivityWeights: Apply sensitivity weighting to counteract the natural tendency of DC resistivity inversion to place materials near the electrodes. Since the problem is non-linear and the sensitivities are updated with every model, we set every_iteration=True.\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem to reduce the number of conjugate gradient iterations. We set update_every_iteration=True because the ideal preconditioner is model-dependent.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta. In general, a coolingFactor between 1.5 and 2.5, and coolingRate of 2 or 3 works well for DC resistivity inversion. Cooling beta too quickly will result in portions of the model getting trapped in local minima. And we will not be finding the solution that minimizes the optimization problem if the cooling rate is too small.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nsensitivity_weights = directives.UpdateSensitivityWeights(every_iteration=True)\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=5)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=2)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [\n    sensitivity_weights,\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-dcr-1d#provide-inversion-directives","position":33},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-and-run-the-inversion","position":34},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run the inversion\nrecovered_model_L2 = inv_L2.run(starting_resistivity_model)\n\n","type":"content","url":"/inv-dcr-1d#define-and-run-the-inversion","position":35},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Observed and Predicted Data","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#plot-observed-and-predicted-data","position":36},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Observed and Predicted Data","lvl2":"Weighted Least-Squares Inversion"},"content":"\n\n# Plot the true and apparent resistivities on a sounding curve\nfig = plt.figure(figsize=(11, 5))\nax1 = fig.add_axes([0.2, 0.1, 0.6, 0.8])\nax1.semilogy(AB_separations / 2, dobs, \"k\")\nax1.semilogy(AB_separations / 2, simulation_L2.dpred(recovered_model_L2), \"b\")\nax1.grid(which=\"both\")\nax1.set_xlabel(\"AB/2 (m)\")\nax1.set_ylabel(r\"Apparent Resistivity ($\\Omega m$)\")\nax1.legend([\"Observed\", \"L2 Inversion\"])\nplt.show()\n\n","type":"content","url":"/inv-dcr-1d#plot-observed-and-predicted-data","position":37},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#plot-the-recovered-model","position":38},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion"},"content":"\n\n# Define true model and layer thicknesses\ntrue_resistivities = np.r_[1e3, 4e3, 2e2]\ntrue_layers = np.r_[100.0, 100.0]\n\n# Plot true model and recovered model\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_resistivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_resistivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nx_min, x_max = true_resistivities.min(), true_resistivities.max()\nax1.set_xlim(0.9 * x_min, 1.1 * x_max)\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nax1.legend([\"True Model\", \"L2-Model\"])\nplt.show()\n\n","type":"content","url":"/inv-dcr-1d#plot-the-recovered-model","position":39},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-dcr-1d#iteratively-re-weighted-least-squares-inversion","position":40},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the iteratively reweighted least-squares (IRLS) inversion approach to recover sparse and/or blocky models on the set layers.\n\n","type":"content","url":"/inv-dcr-1d#iteratively-re-weighted-least-squares-inversion","position":41},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-forward-simulation-1","position":42},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nsimulation_irls = dc.simulation_1d.Simulation1DLayers(\n    survey=survey,\n    rhoMap=log_resistivity_map,\n    thicknesses=layer_thicknesses,\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-forward-simulation-1","position":43},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-data-misfit-1","position":44},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndmis_irls = data_misfit.L2DataMisfit(simulation=simulation_irls, data=data_object)\n\n","type":"content","url":"/inv-dcr-1d#define-the-data-misfit-1","position":45},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-regularization-1","position":46},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the \n\nSparse regularization class to constrain the inversion result using an IRLS approach. Here, the scaling constants that balance the smallness and smoothness terms are set directly. Equal emphasis on smallness and smoothness is generally applied by using the inverse square of the smallest cell dimension. The reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros. Here, we apply a 1-norm to the smallness term and a 1-norm to first-order smoothness along the x (vertical direction).\n\nreg_irls = regularization.Sparse(\n    regularization_mesh,\n    alpha_s=0.1,\n    alpha_x=1,\n    reference_model_in_smooth=False,\n    norms=[1.0, 1.0],\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-regularization-1","position":47},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-optimization-algorithm-1","position":48},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nopt_irls = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=30, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-optimization-algorithm-1","position":49},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-inverse-problem-1","position":50},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_prob_irls = inverse_problem.BaseInvProblem(dmis_irls, reg_irls, opt_irls)\n\n","type":"content","url":"/inv-dcr-1d#define-the-inverse-problem-1","position":51},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#provide-inversion-directives-1","position":52},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we create common directives for IRLS inversion of DC resistivity data and describe their roles. In additon to the \n\nUpdateSensitivityWeights, \n\nUpdatePreconditioner and \n\nBetaEstimate_ByEig  directives (described before), inversion with sparse-norms requires the \n\nUpdateIRLS directive.\n\nYou will notice that we don’t use the \n\nBetaSchedule and \n\nTargetMisfit directives. Here, the beta cooling schedule is set in the \n\nUpdateIRLS directive using the coolingFactor and coolingRate properties. The target misfit for the L2 portion of the IRLS approach is set with the chifact_start property.\n\nsensitivity_weights_irls = directives.UpdateSensitivityWeights(every_iteration=True)\nstarting_beta_irls = directives.BetaEstimate_ByEig(beta0_ratio=1)\nupdate_jacobi_irls = directives.UpdatePreconditioner(update_every_iteration=True)\nupdate_irls = directives.UpdateIRLS(\n    cooling_factor=2,\n    cooling_rate=2,\n    f_min_change=1e-4,\n    max_irls_iterations=30,\n    chifact_start=1.0,\n)\n\ndirectives_list_irls = [\n    update_irls,\n    sensitivity_weights_irls,\n    starting_beta_irls,\n    update_jacobi_irls,\n]\n\n","type":"content","url":"/inv-dcr-1d#provide-inversion-directives-1","position":53},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-and-run-the-inversion-1","position":54},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\n# Here we combine the inverse problem and the set of directives\ninv_irls = inversion.BaseInversion(inv_prob_irls, directives_list_irls)\n\n# Run the inversion\nrecovered_model_irls = inv_irls.run(starting_resistivity_model)\n\n","type":"content","url":"/inv-dcr-1d#define-and-run-the-inversion-1","position":55},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Observed and Predicted Data","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#plot-observed-and-predicted-data-1","position":56},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Observed and Predicted Data","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\n# Plot the true and apparent resistivities on a sounding curve\nfig = plt.figure(figsize=(11, 5))\nax1 = fig.add_axes([0.2, 0.1, 0.6, 0.8])\nax1.semilogy(AB_separations / 2, dobs, \"k\")\nax1.semilogy(AB_separations / 2, simulation_L2.dpred(recovered_model_L2), \"b\")\nax1.semilogy(AB_separations / 2, simulation_irls.dpred(recovered_model_irls), \"r\")\nax1.grid(which=\"both\")\nax1.set_xlabel(\"AB/2 (m)\")\nax1.set_ylabel(r\"Apparent Resistivity ($\\Omega m$)\")\nax1.legend([\"Observed\", \"L2 Inversion\", \"IRLS Inversion\"])\nplt.show()\n\n","type":"content","url":"/inv-dcr-1d#plot-observed-and-predicted-data-1","position":57},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Recovered Models","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-1d#plot-recovered-models","position":58},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Recovered Models","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\n# Plot true model and recovered model\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_resistivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_resistivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nplot_1d_layer_model(\n    layer_thicknesses, log_resistivity_map * recovered_model_irls, ax=ax1, color=\"r\"\n)\nx_min, x_max = true_resistivities.min(), true_resistivities.max()\nax1.set_xlim(0.9 * x_min, 1.1 * x_max)\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nax1.legend([\"True Model\", \"L2 Model\", \"IRLS Model\"])\nplt.show()\n\n","type":"content","url":"/inv-dcr-1d#plot-recovered-models","position":59},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Parametric Inversion"},"type":"lvl2","url":"/inv-dcr-1d#parametric-inversion","position":60},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Parametric Inversion"},"content":"Here, we assume the subsurface is defined by a 3-layered Earth. However, the electrical properties and thicknesses of the layers are unknown. Here, we define our model to include log-conductivities and log-thicknesses. When including quantities that span different scales, it is frequently best to define the model in terms of log-values so that each quantity influences the predicted data evenly.\n\n","type":"content","url":"/inv-dcr-1d#parametric-inversion","position":61},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Models and Mappings","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#models-and-mappings","position":62},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Models and Mappings","lvl2":"Parametric Inversion"},"content":"For a 3-layered Earth model, the model consists of 2 log-thicknesses and 3 log-conductivities. Similar to the \n\n1D Forward Simulation of DC Resistivity Data tutorial, need a mapping that extract log-thicknesses and log-conductivities from the model, and mappings that convert log-values to property values. For this, we require the \n\nsimpeg.maps.Wires mapping and \n\nsimpeg.maps.ExpMap mapping classes. Note that successive mappings can be chained together using the * operator.\n\n# Wire maps to extract log-thicknesses and log-conductivities\nwire_map = maps.Wires((\"log_thicknesses\", 2), (\"log_conductivity\", 3))\n\n# Maping for layer thicknesses\nlog_thicknesses_map = maps.ExpMap() * wire_map.log_thicknesses\n\n# Mapping for conductivities\nlog_conductivity_map = maps.ExpMap() * wire_map.log_conductivity\n\n","type":"content","url":"/inv-dcr-1d#models-and-mappings","position":63},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting and Reference Models","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#starting-and-reference-models","position":64},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting and Reference Models","lvl2":"Parametric Inversion"},"content":"This problem is highly non-linear so it is important to have a reasonable estimate of the true model.\n\nstarting_parametric_model = np.log(np.r_[125.0, 50.0, 1e-3, 2e-3, 5e-2])\n\nreference_parametric_model = starting_parametric_model.copy()\n\n","type":"content","url":"/inv-dcr-1d#starting-and-reference-models","position":65},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-forward-simulation-2","position":66},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Parametric Inversion"},"content":"Because the layer thicknesses are part of the model, we define the thicknessesMap. Because we are working in terms of electrical conductivity, we must define the sigmaMap.\n\nsimulation_parametric = dc.simulation_1d.Simulation1DLayers(\n    survey=survey,\n    sigmaMap=log_conductivity_map,\n    thicknessesMap=log_thicknesses_map,\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-forward-simulation-2","position":67},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-data-misfit-2","position":68},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Parametric Inversion"},"content":"\n\ndmis_parametric = data_misfit.L2DataMisfit(\n    simulation=simulation_parametric, data=data_object\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-data-misfit-2","position":69},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define a (Combo) Regularization","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-a-combo-regularization","position":70},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define a (Combo) Regularization","lvl2":"Parametric Inversion"},"content":"We need to define a regularization for each model parameter type. In this case, we have log-thicknesses and log-conductivities. For each model parameter type, we create a 1D \n\ntensor mesh with length equal to the number of parameters. In the mapping keyword argument, we used the wire map that extracts the specific model parameters from the model.\n\nUsing the * operator, separate regularizations can be summed to form a regularization that is also a \n\nComboObjectiveFunction. By setting the multipliers property, we can emphasis the relative contributions of the log-thicknesses and log-conductivities regularizations.\n\nreg_1 = regularization.Smallness(\n    TensorMesh([(np.ones(2))], \"0\"),\n    mapping=wire_map.log_thicknesses,\n    reference_model=reference_parametric_model,\n)\n\nreg_2 = regularization.Smallness(\n    TensorMesh([(np.ones(3))], \"0\"),\n    mapping=wire_map.log_conductivity,\n    reference_model=reference_parametric_model,\n)\n\nreg_parametric = reg_1 + reg_2\nreg_parametric.multipliers = [1.0, 0.1]\n\n","type":"content","url":"/inv-dcr-1d#define-a-combo-regularization","position":71},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Optimization Algorithm","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-optimization-algorithm-2","position":72},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Optimization Algorithm","lvl2":"Parametric Inversion"},"content":"\n\nopt_parametric = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-optimization-algorithm-2","position":73},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Inverse Problem","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-the-inverse-problem-2","position":74},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Inverse Problem","lvl2":"Parametric Inversion"},"content":"\n\ninv_prob_parametric = inverse_problem.BaseInvProblem(\n    dmis_parametric, reg_parametric, opt_parametric\n)\n\n","type":"content","url":"/inv-dcr-1d#define-the-inverse-problem-2","position":75},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Provide Inversion Directives","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#provide-inversion-directives-2","position":76},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Provide Inversion Directives","lvl2":"Parametric Inversion"},"content":"\n\nsensitivity_weights = directives.UpdateSensitivityWeights(every_iteration=True)\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=10)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=2)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_parametric = [\n    sensitivity_weights,\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-dcr-1d#provide-inversion-directives-2","position":77},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run Inversion","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#define-and-run-inversion","position":78},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run Inversion","lvl2":"Parametric Inversion"},"content":"\n\ninv_parametric = inversion.BaseInversion(\n    inv_prob_parametric, directives_list_parametric\n)\nrecovered_model_parametric = inv_parametric.run(starting_parametric_model)\n\n","type":"content","url":"/inv-dcr-1d#define-and-run-inversion","position":79},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Observed and Predicted Data","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#plot-observed-and-predicted-data-2","position":80},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Observed and Predicted Data","lvl2":"Parametric Inversion"},"content":"\n\n# Plot the true and apparent resistivities on a sounding curve\nfig = plt.figure(figsize=(11, 5))\nax1 = fig.add_axes([0.2, 0.1, 0.6, 0.8])\nax1.semilogy(AB_separations / 2, dobs, \"k\")\nax1.semilogy(AB_separations / 2, simulation_L2.dpred(recovered_model_L2), \"b\")\nax1.semilogy(AB_separations / 2, simulation_irls.dpred(recovered_model_irls), \"r\")\nax1.semilogy(\n    AB_separations / 2, simulation_parametric.dpred(recovered_model_parametric), \"g\"\n)\nax1.grid(which=\"both\")\nax1.set_xlabel(\"AB/2 (m)\")\nax1.set_ylabel(r\"Apparent Resistivity ($\\Omega m$)\")\nax1.legend([\"Observed\", \"L2 Inversion\", \"IRLS Inversion\", \"Parametric Inversion\"])\nplt.show()\n\n","type":"content","url":"/inv-dcr-1d#plot-observed-and-predicted-data-2","position":81},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Recovered Models","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-dcr-1d#plot-recovered-models-1","position":82},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Plot Recovered Models","lvl2":"Parametric Inversion"},"content":"\n\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_resistivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_resistivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nplot_1d_layer_model(\n    layer_thicknesses, log_resistivity_map * recovered_model_irls, ax=ax1, color=\"r\"\n)\nplot_1d_layer_model(\n    log_thicknesses_map * recovered_model_parametric,\n    1 / (log_conductivity_map * recovered_model_parametric),\n    ax=ax1,\n    color=\"g\",\n)\nx_min, x_max = true_resistivities.min(), true_resistivities.max()\nax1.set_xlim(0.8 * x_min, 2 * x_max)\nax1.set_ylim([np.sum(layer_thicknesses), 0])\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nax1.legend([\"True Model\", \"L2 Model\", \"IRLS Model\", \"Parametric Model\"])\nplt.show()","type":"content","url":"/inv-dcr-1d#plot-recovered-models-1","position":83},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion"},"type":"lvl1","url":"/inv-dcr-2d","position":0},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: DC resistivity, 2.5D inversion, sparse norm, tree mesh.\n\nSummary: Here we invert DC resistivity data on a tree mesh to recover the subsurface distribution of electric properties. To demonstrate a range of functionality within SimPEG, we apply two approaches:\n\nWeighted least-squares inversion, where we invert normalized voltage data to recover a log-conductivity model\n\nIteratively re-weighted least-squares (IRLS) inversion, where we invert apparent resistivity data to recover a log-resistivity model\n\nThe weighted least-squares approach is a great introduction to geophysical inversion with SimPEG. One drawback however, is that it recovers smooth structures which may not be representative of the true model. The iteratively re-weighted least-squares approach is able to recover sparse and/or blocky structures. Because this tutorial focusses primarily on\ninversion-related functionality, we urge the reader to become familiar with functionality explained in the \n\n2.5D Forward Simulation tutorial before working through this one.\n\nLearning Objectives:\n\nIntroduce geophysical inversion with SimPEG.\n\nAssigning appropriate uncertainties to normalized voltage and apparent resistivity data.\n\nDesigning a suitable mesh for 2.5D DC resistivity inversion.\n\nChoosing suitable parameters for the inversion.\n\nSpecifying directives that are applied throughout the inversion.\n\nApply the sensitivity weighting commonly used when inverting magnetic data.\n\nInversion with weighted least-squares and sparse-norm regularizations.\n\nAnalyzing inversion outputs.\n\n","type":"content","url":"/inv-dcr-2d","position":1},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Import Modules"},"type":"lvl2","url":"/inv-dcr-2d#import-modules","position":2},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to DC resistivity is imported from \n\nsimpeg​.electromagnetics​.static​.resistivity.\nWe also import some useful utility functions from \n\nsimpeg.utils. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import resistivity as dc\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    plot_pseudosection,\n    generate_survey_from_abmn_locations,\n    apparent_resistivity_from_voltage,\n)\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import read_dcip2d_ubc\nfrom simpeg.utils import download, model_builder\nfrom simpeg import (\n    maps,\n    data,\n    data_misfit,\n    regularization,\n    optimization,\n    inverse_problem,\n    inversion,\n    directives,\n)\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Basic Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\nimport tarfile\n\nmpl.rcParams.update({\"font.size\": 14})  # default font size\ncmap = mpl.cm.RdYlBu_r  # default colormap\n\n","type":"content","url":"/inv-dcr-2d#import-modules","position":3},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Load Tutorial Data and Plot"},"type":"lvl2","url":"/inv-dcr-2d#load-tutorial-data-and-plot","position":4},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Load Tutorial Data and Plot"},"content":"For most geophysical inversion projects, a reasonable inversion result can be obtained so long as the practitioner has observed data, the survey geometry and topography. For this tutorial, the observed data and topography files are provided. Here, we download and import the observed data and topography into the SimPEG framework.\n\n# URL to download from repository assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/05-dcr/inv_dcr_2d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"topo_2d.txt\"\ndata_filename = dir_path + \"dc_data.obs\"\n\n","type":"content","url":"/inv-dcr-2d#load-tutorial-data-and-plot","position":5},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Load the Topography","lvl2":"Load Tutorial Data and Plot"},"type":"lvl3","url":"/inv-dcr-2d#load-the-topography","position":6},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Load the Topography","lvl2":"Load Tutorial Data and Plot"},"content":"True surface topography is defined as an (N, 3) \n\nnumpy.ndarray.\nFor the 2.5D problem geometry however, topography is an (N, 2) \n\nnumpy.ndarray, where the first coordinate represent along-line position and the second coordinate represents the vertical position. In this tutorial, we assume the topography and electrode locations are defined according to the 2.5D geometry.\n\n# Load 2D topography\ntopo_2d = np.loadtxt(str(topo_filename))\n\n# Plot 2D topography\nfig = plt.figure(figsize=(10, 2))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\nax.plot(topo_2d[:, 0], topo_2d[:, -1], color=\"b\", linewidth=1)\nax.set_xlim([topo_2d[:, 0].min(), topo_2d[:, 0].max()])\nax.set_xlabel(\"x (m)\", labelpad=5)\nax.set_ylabel(\"z (m)\", labelpad=5)\nax.grid(True)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=10)\nplt.show(fig)\n\n","type":"content","url":"/inv-dcr-2d#load-the-topography","position":7},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Load DC Resistivity Data","lvl2":"Load Tutorial Data and Plot"},"type":"lvl3","url":"/inv-dcr-2d#load-dc-resistivity-data","position":8},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Load DC Resistivity Data","lvl2":"Load Tutorial Data and Plot"},"content":"\n\nOption A: DCIP2D formatted data\n\nFor this tutorial, the observed data are organized with a UBC-GIF DCIP2D formatted data file. We can use the \n\nread_dcip2d_ubc utility function to load data in this format. This function outputs a SimPEG \n\nData object. The data are normalized voltages in units V/A.\n\nvoltage_data = read_dcip2d_ubc(data_filename, \"volt\", \"general\")\n\nOption B: Survey from ABMN electrode locations\n\nIf you have CSV-formatted data containing the ABMN electrode locations, you will need to:\n\nload the file into a \n\nnumpy.ndarray\n\nextract the data column and the A, B, M and N electrode locations\n\ntransform the electrode locations to the 2.5D geometry if necessary; i.e. (N, 2) \n\nnumpy.ndarray\n\nuse the \n\ngenerate​_survey​_from​_abmn​_locations to generate a \n\nsurvey object automatically.\n\nDefine a \n\nData object attached to the survey and observed data.\n\nE.g. for a file containing electrode locations already formatted for a 2.5D geometry:data_array = np.loadtxt(data_filename, skiprows=1)\n\ndobs = data_array[:, -1]\nA = data_array[:, 0:2]\nB = data_array[:, 2:4]\nM = data_array[:, 4:6]\nN = data_array[:, 6:8]\n\nsurvey = generate_survey_from_abmn_locations(\n    locations_a=A,\n    locations_b=B,\n    locations_m=M,\n    locations_n=M,\n    data_type='volt'\n)\n\ndc_data = data.Data(survey, dobs=dobs)\n\n","type":"content","url":"/inv-dcr-2d#load-dc-resistivity-data","position":9},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Plot DC Resistivity Data in Pseudo-Section","lvl2":"Load Tutorial Data and Plot"},"type":"lvl3","url":"/inv-dcr-2d#plot-dc-resistivity-data-in-pseudo-section","position":10},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Plot DC Resistivity Data in Pseudo-Section","lvl2":"Load Tutorial Data and Plot"},"content":"Here we use the \n\nplot_pseudosection utility function to plot the normalized voltage data in pseudosection. We also use the \n\napparent​_resistivity​_from​_voltage utility function to convert the data to apparent resistivities, which are also plotted in pseudosection.\n\n# Plot voltages pseudo-section\nfig = plt.figure(figsize=(8, 2.75))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    voltage_data,\n    plot_type=\"scatter\",\n    ax=ax1,\n    scale=\"log\",\n    cbar_label=\"V/A\",\n    scatter_opts={\"cmap\": mpl.cm.viridis},\n)\nax1.set_title(\"Normalized Voltages\")\nplt.show()\n\n# Get apparent conductivities from volts and survey geometry\napparent_resistivities = apparent_resistivity_from_voltage(\n    voltage_data.survey, voltage_data.dobs\n)\n\n# Plot apparent resistivity pseudo-section\nfig = plt.figure(figsize=(8, 2.75))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    voltage_data.survey,\n    apparent_resistivities,\n    plot_type=\"contourf\",\n    ax=ax1,\n    scale=\"log\",\n    cbar_label=r\"$\\Omega m$\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.RdYlBu},\n)\nax1.set_title(\"Apparent Resistivity\")\nplt.show()\n\n","type":"content","url":"/inv-dcr-2d#plot-dc-resistivity-data-in-pseudo-section","position":11},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-dcr-2d#assign-uncertainties","position":12},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor normalized voltage data, we generally apply a percent uncertainty and a very small floor uncertainty to all data. Differences in electrode spacing and subsurface conductivity result in measured voltages that span many orders of magnitude. A percent uncertainty ensures all data are fit equally. Depending on the quality of the data, we may choose a percent uncertainty between 2% - 10%. The floor uncertainty ensures stability when there are zero-crossings or erroneously small voltages. Here, we apply uncertainties of 1e-7 V/A + 5 %.\n\nFor apparent resistivity data, we also apply a percent uncertainty and a very small floor uncertainty to all data. A percent uncertainty will fit conductive and resistive structures equally; unlike a floor uncertainty which will prioritize fitting more resistive structures. Depending on the quality of the data, we may choose a percent uncertainty between 2% - 10%. The floor uncertainty ensures stability when there are zero-crossings or erroneously small voltages.\n\n# Apply uncertainties to normalized voltage data\nvoltage_data.standard_deviation = 1e-7 + 0.05 * np.abs(voltage_data.dobs)\n\n","type":"content","url":"/inv-dcr-2d#assign-uncertainties","position":13},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/inv-dcr-2d#design-a-tree-mesh","position":14},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Design a (Tree) Mesh"},"content":"The same rules for defining appropriate meshes for forward simulation of DC resistivity apply to inversion. Please visit the \n\n2.5D Forward Simulation tutorial to see the best practices for mesh design.\n\nTutorial mesh: Here, a minimum cell width of 4 m (or 1/10 the minimum electrode spacing) is used within our survey region. The largest electrode spacing was 400 m, so a the padding was extended at least 1200 m from the survey region. Using the \n\nrefine_surface method, we refine the tree mesh where there is significant topography. And using the \n\nrefine_points methods, we refine based on electrodes locations. Visit the \n\ntree mesh API to see additional refinement methods.\n\ndh = 4  # base cell width\ndom_width_x = 3200.0  # domain width x\ndom_width_z = 2400.0  # domain width z\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh with top at z = 0 m\nhx = [(dh, nbcx)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hz], x0=\"CN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, topo_2d[:, -1].max()]\n\n# Mesh refinement based on topography\nmesh.refine_surface(\n    topo_2d,\n    padding_cells_by_level=[0, 0, 4, 4],\n    finalize=False,\n)\n\n# Extract unique electrode locations.\nunique_locations = voltage_data.survey.unique_electrode_locations\n\n# Mesh refinement near electrodes.\nmesh.refine_points(\n    unique_locations, padding_cells_by_level=[8, 12, 6, 6], finalize=False\n)\n\nmesh.finalize()\n\n","type":"content","url":"/inv-dcr-2d#design-a-tree-mesh","position":15},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/inv-dcr-2d#define-the-active-cells","position":16},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Define the Active Cells"},"content":"Simulated geophysical data are dependent on the subsurface distribution of physical property values. As a result, the cells lying below the surface topography are commonly referred to as ‘active cells’. And air cells, whose physical property values are fixed, are commonly referred to as ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_2d)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/inv-dcr-2d#define-the-active-cells","position":17},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/inv-dcr-2d#project-electrodes-to-discretized-topography","position":18},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Project Electrodes to Discretized Topography"},"content":"Surface DC resistivity data will not be modeled accurately if the electrodes are modeled as living above or below the surface. It is especially problematic when electrodes are modeled as living in the air. Prior to inverting DC resistivity data, we must project the electrodes from their true elevation to the surface of the discretized topography. This is done using the \n\ndrape​_electrodes​_on​_topography method.\n\nvoltage_data.survey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/inv-dcr-2d#project-electrodes-to-discretized-topography","position":19},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-dcr-2d#weighted-least-squares-inversion","position":20},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, a weighted least-squares inversion approach is used to invert normalized voltage data to recover a log-conductivity model. We invert for log-conductivity because\n\nIt naturally enforces positive conductivity values in the recovered model\n\nElectrical conductivity is a physical property that spans many orders of magnitude\n\n","type":"content","url":"/inv-dcr-2d#weighted-least-squares-inversion","position":21},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Mapping from the Model to the Mesh","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#mapping-from-the-model-to-the-mesh","position":22},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Mapping from the Model to the Mesh","lvl2":"Weighted Least-Squares Inversion"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For whatever model we choose, we must define a mapping from the set of model parameters (a \n\n1D numpy.ndarray) to the physical property values of all cells in the mesh. Mappings are created using the \n\nsimpeg.maps module.\n\nFor DC resistivity, the model parameters define the subsurface electrical conductivity, and the electrical conductivities of the cells in the air are given a fixed value. Here, the model defines the log-conductivity values for all active cells. We use the \n\nsimpeg.maps.ExpMap to map from the model parameters to the conductivity values for all active cells. Then we use the \n\nsimpeg​.maps​.InjectActiveCells map to project the active cell conductivities to the entire mesh. As explained in the \n\n2.5D Forward Simulation tutorial, air cells are given a fixed value of 1e-8 S/m to ensure the forward problem is well-conditionned. And the * operator is used to combine the separate mapping objects into a single mapping.\n\n# Map model parameters to all cells\nlog_conductivity_map = maps.InjectActiveCells(mesh, active_cells, 1e-8) * maps.ExpMap(\n    nP=n_active\n)\n\n","type":"content","url":"/inv-dcr-2d#mapping-from-the-model-to-the-mesh","position":23},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#starting-reference-models","position":24},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"content":"The starting model defines a reasonable starting point for the inversion and does not necessarily represent an initial estimate of the true model. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration. For DC resistivity inversion, the starting model is frequently a halfspace estimated from the set of apparent resistivities/conductivities.\n\nThe reference model is used to include a-priori information. By default, the starting model is set as the reference model. The impact of the reference model on the inversion will be discussed in another tutorial.\n\nNotice that the length of the starting and reference models is equal to the number of model parameters!!!\n\n# Median apparent resistivity\nmedian_resistivity = np.median(apparent_resistivities)\n\n# Create starting model from log-conductivity\nstarting_conductivity_model = np.log(1 / median_resistivity) * np.ones(n_active)\n\n# Zero reference conductivity model\nreference_conductivity_model = starting_conductivity_model.copy()\n\n","type":"content","url":"/inv-dcr-2d#starting-reference-models","position":25},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-forward-simulation","position":26},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for 2.5D DC resistivity was discussed in the \n\n2.5D Forward Simulation tutorial. Here, we use the \n\nSimulation2DNodal simulation which solves for the electric potential on mesh nodes.\n\nSince our model consists of log-conductivities, we use sigmaMap to set the mapping from the model to the mesh cells. Except for in extreme cases, we can compute and store the Jacobian explicitly for 2.5D problems. By doing so, we drastically reduce the run-time of the inversion.\n\nvoltage_simulation = dc.simulation_2d.Simulation2DNodal(\n    mesh, survey=voltage_data.survey, sigmaMap=log_conductivity_map, storeJ=True\n)\n\n","type":"content","url":"/inv-dcr-2d#define-the-forward-simulation","position":27},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-data-misfit","position":28},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(simulation=voltage_simulation, data=voltage_data)\n\n","type":"content","url":"/inv-dcr-2d#define-the-data-misfit","position":29},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-regularization","position":30},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource. Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Here, the scaling constants that balance the smallness and smoothness terms are set directly. We use the inverse square of the smallest cell size to balance the smallness and smoothness terms. Setting alpha_s to a very small value will recover the smoothest model. And the reference model is only applied to the smallness term.\n\nBy default, the regularization acts on the model parameters; which in the case are the log-conductivities of the active cells. So we need to specify which cells are active in the regularization. And if we wanted to apply the regularization to a function of the model parameters, we would need to set an approprate mapping object using the mapping keyword argument.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    mesh,\n    active_cells=active_cells,\n    alpha_s=dh**-2,\n    alpha_x=1,\n    alpha_y=1,\n    reference_model=reference_conductivity_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-dcr-2d#define-the-regularization","position":31},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-optimization-algorithm","position":32},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the \n\nInexactGaussNewton class to solve the optimization problem using the inexact Gauss Newton with conjugate gradient solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches.\n\nopt_L2 = optimization.InexactGaussNewton(\n    maxIter=40, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-dcr-2d#define-the-optimization-algorithm","position":33},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-inverse-problem","position":34},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-dcr-2d#define-the-inverse-problem","position":35},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#provide-inversion-directives","position":36},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"content":"Directives represent operations that are carried out during the inversion. Here, we apply common directives for weighted least-squares inversion of DC resistivity data and describe their roles. These are:\n\nUpdateSensitivityWeights: Apply sensitivity weighting to counteract the natural tendency of DC resistivity inversion to place materials near the electrodes. Since the problem is non-linear and the sensitivities are updated with every model, we set every_iteration=True. For DC resistivity inversion, we do not want to use the entire dynamic range of the sensitivities to generate our weighting. So we generally set threshold_value to a value betwewen 1e-5 and 1e-3.\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem to reduce the number of conjugate gradient iterations. We set update_every_iteration=True because the ideal preconditioner is model-dependent.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta. In general, a coolingFactor between 1.5 and 2.5, and coolingRate of 2 or 3 works well for DC resistivity inversion. Cooling beta too quickly will result in portions of the model getting trapped in local minima. And we will not be finding the solution that minimizes the optimization problem if the cooling rate is too small.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nsensitivity_weights = directives.UpdateSensitivityWeights(\n    every_iteration=True, threshold_value=1e-2\n)\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=10)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=2)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [\n    sensitivity_weights,\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-dcr-2d#provide-inversion-directives","position":37},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-and-run-the-inversion","position":38},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run the inversion\n# recovered_model_L2 = inv_L2.run(np.log(0.01) * np.ones(n_param))\nrecovered_log_conductivity_model = inv_L2.run(starting_conductivity_model)\n\n","type":"content","url":"/inv-dcr-2d#define-and-run-the-inversion","position":39},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#plot-the-data-misfit","position":40},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"content":"This step is necessary for determining whether the recovered model accurately reproduces observed anomalies. Here, we plot the observed data, predicted data for the recovered model, and the normalized data misfit. As we can see, the recovered model reproduces the observed data quite well. And the normalized misfit map indicates we are not overfitting certain electrodes relative to others.\n\nIf desired, one could also use the \n\napparent​_resistivity​_from​_voltage utility function compare observed and predicted data as apparent resistivities.\n\n# Predicted data from recovered model\ndpred = inv_prob_L2.dpred\ndobs = voltage_data.dobs\nstd = voltage_data.standard_deviation\n\n# Plot\nfig = plt.figure(figsize=(9, 11))\ndata_array = [np.abs(dobs), np.abs(dpred), (dobs - dpred) / std]\nplot_title = [\"Observed Voltage\", \"Predicted Voltage\", \"Normalized Misfit\"]\nplot_units = [\"V/A\", \"V/A\", \"\"]\nscale = [\"log\", \"log\", \"linear\"]\ncmap_list = [mpl.cm.viridis, mpl.cm.viridis, mpl.cm.RdYlBu]\n\nax1 = 3 * [None]\ncax1 = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.15, 0.72 - 0.33 * ii, 0.65, 0.21])\n    cax1[ii] = fig.add_axes([0.81, 0.72 - 0.33 * ii, 0.03, 0.21])\n    cplot[ii] = plot_pseudosection(\n        voltage_data.survey,\n        data_array[ii],\n        \"contourf\",\n        ax=ax1[ii],\n        cax=cax1[ii],\n        scale=scale[ii],\n        cbar_label=plot_units[ii],\n        mask_topography=True,\n        contourf_opts={\"levels\": 25, \"cmap\": cmap_list[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n\nplt.show()\n\n","type":"content","url":"/inv-dcr-2d#plot-the-data-misfit","position":41},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#plot-the-recovered-model","position":42},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion"},"content":"As we can see, weighted least-squares regularization leads to the recovery of smooth models.\n\n# Convert log-conductivity values to conductivity values\nrecovered_conductivity_L2 = np.exp(recovered_log_conductivity_model)\n\n# Define a mapping to plot models and ignore inactive cells\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nnorm = LogNorm(vmin=5e-4, vmax=2e-1)\n\nfig = plt.figure(figsize=(9, 4))\n\nax1 = fig.add_axes([0.14, 0.17, 0.68, 0.7])\nmesh.plot_image(\n    plotting_map * recovered_conductivity_L2,\n    normal=\"Y\",\n    ax=ax1,\n    grid=False,\n    pcolor_opts={\"norm\": norm, \"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_xlim(-500, 500)\nax1.set_ylim(-300, 200)\nax1.set_title(\"Recovered Conductivity Model (L2)\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.84, 0.17, 0.03, 0.7])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(r\"$\\sigma$ (S/m)\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/inv-dcr-2d#plot-the-recovered-model","position":43},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-dcr-2d#iteratively-re-weighted-least-squares-inversion","position":44},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we provide a step-by-step best-practices approach for IRLS inversion of apparent resistivity data on a tree mesh to recover a log-resistivity model. Many of the steps are the same as our previous approach. As a result, we will avoid repeating information whenever possible.\n\n","type":"content","url":"/inv-dcr-2d#iteratively-re-weighted-least-squares-inversion","position":45},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define An Apparent Resistivity Survey","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-an-apparent-resistivity-survey","position":46},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define An Apparent Resistivity Survey","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"We cannot reuse a survey that was used to simulate a different data type. So we must define a new survey object for inverting apparent resistivity data. This can be done by extracting the ABMN electrode locations from the previous survey object and using the \n\ngenerate​_survey​_from​_abmn​_locations utility function.\n\n# Extract ABMN electrode locations from previous survey object\nlocations_a = voltage_data.survey.locations_a.copy()\nlocations_b = voltage_data.survey.locations_b.copy()\nlocations_m = voltage_data.survey.locations_m.copy()\nlocations_n = voltage_data.survey.locations_n.copy()\n\n# Define survey from ABMN locations\nresistivity_survey = generate_survey_from_abmn_locations(\n    locations_a=locations_a,\n    locations_b=locations_b,\n    locations_m=locations_m,\n    locations_n=locations_n,\n    data_type=\"apparent_resistivity\",\n)\n\n# Set geometric factor for survey (to be handled internally in future versions)\nresistivity_survey.set_geometric_factor()\n\n","type":"content","url":"/inv-dcr-2d#define-an-apparent-resistivity-survey","position":47},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Data","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-data","position":48},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Data","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nresistivity_data = data.Data(survey=resistivity_survey, dobs=apparent_resistivities)\n\n","type":"content","url":"/inv-dcr-2d#define-the-data","position":49},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Assign Uncertainties","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#assign-uncertainties-1","position":50},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Assign Uncertainties","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Uncertainties for apparent resistivity data were discussed earlier. Here we apply uncertainties of 1e-3 \\Omega m + 5 % to all data.\n\nresistivity_data.standard_deviation = 1e-3 + 0.05 * np.abs(resistivity_data.dobs)\n\n","type":"content","url":"/inv-dcr-2d#assign-uncertainties-1","position":51},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Mapping from the Model to the Mesh","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#mapping-from-the-model-to-the-mesh-1","position":52},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Mapping from the Model to the Mesh","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, the model defines the log-resistivity values for all active cells. We use the \n\nsimpeg.maps.ExpMap to map from the model parameters to the resistivity values for all active cells. Then we use the \n\nsimpeg​.maps​.InjectActiveCells map to project the active cell resisitivities to the entire mesh. As explained in the \n\n2.5D Forward Simulation tutorial, air cells are given a fixed value of 1e8 \\Omega m to ensure the forward problem is well-conditionned. And the * operator is used to combine the separate mapping objects into a single mapping.\n\nlog_resistivity_map = maps.InjectActiveCells(mesh, active_cells, 1e8) * maps.ExpMap(\n    nP=n_active\n)\n\n","type":"content","url":"/inv-dcr-2d#mapping-from-the-model-to-the-mesh-1","position":53},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Starting/Reference Models","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#starting-reference-models-1","position":54},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Starting/Reference Models","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"The starting model is defined according to the median apparent resistivity value. The reference model is equal to the starting model.\n\n# Create starting model from log-resistivities\nstarting_resistivity_model = np.log(median_resistivity) * np.ones(n_active)\n\n# Zero reference model\nreference_resistivity_model = starting_resistivity_model.copy()\n\n","type":"content","url":"/inv-dcr-2d#starting-reference-models-1","position":55},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-forward-simulation-1","position":56},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nresistivity_simulation = dc.simulation_2d.Simulation2DNodal(\n    mesh, survey=resistivity_data.survey, rhoMap=log_resistivity_map, storeJ=True\n)\n\n","type":"content","url":"/inv-dcr-2d#define-the-forward-simulation-1","position":57},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-data-misfit-1","position":58},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndmis_irls = data_misfit.L2DataMisfit(\n    simulation=resistivity_simulation, data=resistivity_data\n)\n\n","type":"content","url":"/inv-dcr-2d#define-the-data-misfit-1","position":59},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-regularization-1","position":60},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the \n\nSparse regularization class to constrain the inversion result using an IRLS approach. Length scales along x and y are used to balance the smallness and smoothness terms. Here, length scales of 100 are used to more strongly emphasize smoothness in the recovered model. The reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros. Here, we apply a 0-norm to the smallness and 2-norm to first-order smoothness along the x and y directions.\n\nreg_irls = regularization.Sparse(\n    mesh,\n    active_cells=active_cells,\n    length_scale_x=5.0,\n    length_scale_y=5.0,\n    norms=[0, 2, 2],\n    reference_model=reference_resistivity_model,\n)\n\n","type":"content","url":"/inv-dcr-2d#define-the-regularization-1","position":61},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-optimization-algorithm-1","position":62},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Optimization Algorithm","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nopt_irls = optimization.InexactGaussNewton(\n    maxIter=50, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-dcr-2d#define-the-optimization-algorithm-1","position":63},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-the-inverse-problem-1","position":64},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_prob_irls = inverse_problem.BaseInvProblem(dmis_irls, reg_irls, opt_irls)\n\n","type":"content","url":"/inv-dcr-2d#define-the-inverse-problem-1","position":65},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#provide-inversion-directives-1","position":66},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we create common directives for IRLS inversion of total magnetic intensity data and describe their roles. In additon to the \n\nUpdateSensitivityWeights, \n\nUpdatePreconditioner and \n\nBetaEstimate_ByEig  (described before), inversion with sparse-norms requires the \n\nUpdateIRLS directive.\n\nYou will notice that we don’t use the \n\nBetaSchedule and \n\nTargetMisfit directives. Here, the beta cooling schedule is set in the \n\nUpdateIRLS directive using the coolingFactor and coolingRate properties. The target misfit for the L2 portion of the IRLS approach is set with the chifact_start property.\n\nsensitivity_weights_irls = directives.UpdateSensitivityWeights(\n    every_iteration=True, threshold_value=1e-2\n)\nupdate_irls = directives.UpdateIRLS(\n    cooling_factor=2,\n    cooling_rate=2,\n    f_min_change=1e-4,\n    max_irls_iterations=30,\n    chifact_start=1.0,\n)\nstarting_beta_irls = directives.BetaEstimate_ByEig(beta0_ratio=10)\nupdate_jacobi_irls = directives.UpdatePreconditioner(update_every_iteration=True)\n\ndirectives_list_irls = [\n    update_irls,\n    sensitivity_weights_irls,\n    starting_beta_irls,\n    update_jacobi_irls,\n]\n\n","type":"content","url":"/inv-dcr-2d#provide-inversion-directives-1","position":67},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-dcr-2d#define-and-run-the-inversion-1","position":68},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_irls = inversion.BaseInversion(inv_prob_irls, directives_list_irls)\nrecovered_log_resistivity_model = inv_irls.run(starting_resistivity_model)\n\n","type":"content","url":"/inv-dcr-2d#define-and-run-the-inversion-1","position":69},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Plot True, L2 and IRLS Models"},"type":"lvl2","url":"/inv-dcr-2d#plot-true-l2-and-irls-models","position":70},{"hierarchy":{"lvl1":"2.5D DC Resistivity Inversion","lvl2":"Plot True, L2 and IRLS Models"},"content":"Here, we compare the models recovered from weighted least-squares and iteratively re-weighted least-squares inversion to the true model.\n\n# Recreate the true model\ntrue_background_conductivity = 1e-2\ntrue_conductor_conductivity = 1e-1\ntrue_resistor_conductivity = 1e-3\n\ntrue_conductivity_model = true_background_conductivity * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-120.0, 40.0], 60.0, mesh.cell_centers[active_cells, :]\n)\ntrue_conductivity_model[ind_conductor] = true_conductor_conductivity\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[120.0, 72.0], 60.0, mesh.cell_centers[active_cells, :]\n)\ntrue_conductivity_model[ind_resistor] = true_resistor_conductivity\n\n# Convert recovered log-resistivities to conductivities\nrecovered_conductivity_irls = 1 / np.exp(recovered_log_resistivity_model)\n\n# Convert to subsurface conductivity values\nplotting_model = [\n    true_conductivity_model,\n    recovered_conductivity_L2,\n    recovered_conductivity_irls,\n]\n\nfig = plt.figure(figsize=(9, 13))\nax1 = 3 * [None]\nax2 = 3 * [None]\ntitle_str = [\n    \"True Conductivity Model\",\n    \"Recovered Model (L2)\",\n    \"Recovered Model (IRLS)\",\n]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.14, 0.75 - 0.3 * ii, 0.68, 0.22])\n    mesh.plot_image(\n        plotting_map * plotting_model[ii],\n        ax=ax1[ii],\n        grid=False,\n        pcolor_opts={\"norm\": norm, \"cmap\": mpl.cm.RdYlBu_r},\n    )\n    ax1[ii].set_xlim(-500, 500)\n    ax1[ii].set_ylim(-300, 200)\n    ax1[ii].set_title(title_str[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    ax1[ii].set_ylabel(\"z (m)\")\n\n    ax2[ii] = fig.add_axes([0.84, 0.75 - 0.3 * ii, 0.03, 0.22])\n    cbar = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n    )\n    cbar.set_label(r\"$\\sigma$ (S/m)\", rotation=270, labelpad=15, size=12)\n\nplt.show()","type":"content","url":"/inv-dcr-2d#plot-true-l2-and-irls-models","position":71},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion"},"type":"lvl1","url":"/inv-dcr-3d","position":0},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nMedium-weight notebook\n\nRequires moderate computational resources. Run-times may exceed several minutes and require up to 8 GB of available RAM.\n\nKeywords: DC resistivity, 3D inversion, weighted least-squares, tree mesh.\n\nSummary: Here, DC resistivity data are inverted to recover a log-conductivity model using a weighted least-squares inversion approach. Most of the functionality required for this tutorial was presented in the \n\n3D Forward Simulation and \n\n2.5D Inversion tutorials. We strongly urge the reader to work through the aforementioned tutorials prior to working through this one, as we will avoid significant repitition of content.\n\nLearning Objectives:\n\nDemonstrate 3D DC resistivity inversion with SimPEG.\n\nDiscuss practical aspects of 3D DC resistivity inversion.\n\nAnalyzing inversion outputs.\n\n","type":"content","url":"/inv-dcr-3d","position":1},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Import Modules"},"type":"lvl2","url":"/inv-dcr-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to DC resistivity is imported from \n\nsimpeg​.electromagnetics​.static​.resistivity.\nWe also import some useful utility functions from \n\nsimpeg.utils. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import resistivity as dc\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    plot_pseudosection,\n    apparent_resistivity_from_voltage,\n    convert_survey_3d_to_2d_lines,\n)\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import read_dcip_xyz\nfrom simpeg.utils import download, model_builder\nfrom simpeg import (\n    maps,\n    data_misfit,\n    regularization,\n    optimization,\n    inverse_problem,\n    inversion,\n    directives,\n)\n\ntry:\n    import plotly\n    from simpeg.electromagnetics.static.utils.static_utils import plot_3d_pseudosection\n    from IPython.core.display import display, HTML\n\n    has_plotly = True\nexcept ImportError:\n    has_plotly = False\n    pass\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Basic Python functionality\nimport os\nimport tarfile\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\n\nmpl.rcParams.update({\"font.size\": 16})\n\n","type":"content","url":"/inv-dcr-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Load Tutorial Data and Plot"},"type":"lvl2","url":"/inv-dcr-3d#load-tutorial-data-and-plot","position":4},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Load Tutorial Data and Plot"},"content":"For most geophysical inversion projects, a reasonable inversion result can be obtained so long as the practitioner has observed data, the survey geometry and topography. For this tutorial, the observed data and topography files are provided. Here, we download and import the observed data and topography into the SimPEG framework.\n\n# URL to download from repository assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/05-dcr/inv_dcr_3d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"topo_xyz.txt\"\ndc_data_filename = dir_path + \"dc_data.xyz\"\n\n","type":"content","url":"/inv-dcr-3d#load-tutorial-data-and-plot","position":5},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Load the Topography","lvl2":"Load Tutorial Data and Plot"},"type":"lvl3","url":"/inv-dcr-3d#load-the-topography","position":6},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Load the Topography","lvl2":"Load Tutorial Data and Plot"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray.\n\ntopo_xyz = np.loadtxt(str(topo_filename))\n\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([-400, 400])\nax.scatter3D(topo_xyz[:, 0], topo_xyz[:, 1], topo_xyz[:, 2], s=0.25, c=\"b\")\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=45.0, azim=-125)\n\n","type":"content","url":"/inv-dcr-3d#load-the-topography","position":7},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Load DC Resistivity Data","lvl2":"Load Tutorial Data and Plot"},"type":"lvl3","url":"/inv-dcr-3d#load-dc-resistivity-data","position":8},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Load DC Resistivity Data","lvl2":"Load Tutorial Data and Plot"},"content":"Option A: DCIP3D formatted data\n\nThe \n\nread_dcip3d_ubc utility function can be used to load DC/IP data stored in a UBC-GIF formatted file. This function outputs a SimPEG \n\nData object.\n\nOption B: Load XYZ formatted data\n\nFor this tutorial, the observed data are organized within an XYZ formatted file. We can use the \n\nread_dcip_xyz utility function to load data in this format. This function outputs a SimPEG \n\nData object. The data are normalized voltages in units V/A.\n\nThe dict_headers input argument can be used to import other data columns that are not required to define the SimPEG data object. In this case, we import a column that defines the survey line associated with each datum. We will use this to plot pseudosections for individual survey lines.\n\ndc_data, out_dict = read_dcip_xyz(\n    dc_data_filename,\n    \"volt\",\n    data_header=\"V/A\",\n    uncertainties_header=\"UNCERT\",\n    is_surface_data=False,\n    dict_headers=[\"LINEID\"],\n)\n\n","type":"content","url":"/inv-dcr-3d#load-dc-resistivity-data","position":9},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot Observed Data in 3D Pseudosection","lvl2":"Load Tutorial Data and Plot"},"type":"lvl3","url":"/inv-dcr-3d#plot-observed-data-in-3d-pseudosection","position":10},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot Observed Data in 3D Pseudosection","lvl2":"Load Tutorial Data and Plot"},"content":"Here we use the \n\nplot​_3d​_pseudosection utility function to represent the observed data in pseudosection. Although our original data are normalized voltages, we use the \n\napparent​_resistivity​_from​_voltage utility function to convert the data to apparent resistivities.\n\napparent_conductivities = 1 / apparent_resistivity_from_voltage(\n    dc_data.survey,\n    dc_data.dobs,\n)\n\nif has_plotly:\n    fig = plot_3d_pseudosection(\n        dc_data.survey,\n        apparent_conductivities,\n        scale=\"log\",\n        units=\"S/m\",\n        marker_opts={\"colorscale\": \"RdYlBu_r\"},\n    )\n\n    fig.update_layout(\n        title_text=\"Apparent Conductivity\",\n        title_x=0.5,\n        title_font_size=24,\n        width=650,\n        height=500,\n        scene_camera=dict(\n            center=dict(x=0, y=0, z=-0.4), eye=dict(x=1.5, y=-1.5, z=1.8)\n        ),\n    )\n\n    #     plotly.io.show(fig)\n    html_str = plotly.io.to_html(fig)\n    display(HTML(html_str))\n\nelse:\n    print(\"INSTALL 'PLOTLY' TO VISUALIZE 3D PSEUDOSECTIONS\")\n\n","type":"content","url":"/inv-dcr-3d#plot-observed-data-in-3d-pseudosection","position":11},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot Observed Data in 2D Pseudosection","lvl2":"Load Tutorial Data and Plot"},"type":"lvl3","url":"/inv-dcr-3d#plot-observed-data-in-2d-pseudosection","position":12},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot Observed Data in 2D Pseudosection","lvl2":"Load Tutorial Data and Plot"},"content":"As demonstrated in the \n\n3D Forward Simulation tutorial, we can parse the 3D survey into a set of 2D survey lines if we know which survey line is associated with each datum. Then we can plot individual pseudosections for each survey line. We use the \n\nconvert​_survey​_3d​_to​_2d​_lines to generate the list of 2D surveys. And we use the \n\nplot​_2d​_pseudosection utility function to plot the pseudosection for the desired survey line.\n\n# Extract line IDs and make sure they are integers\nlineID = np.array(out_dict[\"LINEID\"], dtype=int)\n\nsurvey_2d_list, index_list = convert_survey_3d_to_2d_lines(\n    dc_data.survey, lineID, data_type=\"volt\", output_indexing=True\n)\n\ndobs_2d_list = []\napparent_conductivities_2d = []\nfor ind in index_list:\n    dobs_2d_list.append(dc_data.dobs[ind])\n    apparent_conductivities_2d.append(apparent_conductivities[ind])\n\nline_index = 0\n\nfig = plt.figure(figsize=(8, 2.75))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    survey_2d_list[line_index],\n    dobs=apparent_conductivities_2d[line_index],\n    plot_type=\"contourf\",\n    ax=ax1,\n    scale=\"log\",\n    cbar_label=\"S/m\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_title(\"Apparent Conductivity\")\nplt.show()\n\n","type":"content","url":"/inv-dcr-3d#plot-observed-data-in-2d-pseudosection","position":13},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-dcr-3d#assign-uncertainties","position":14},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Assign Uncertainties"},"content":"Approaches for applying reasonable uncertainties to normalized voltage and apparent resistivity data were presented in the \n\n2.5D Inversion tutorial. Here, we apply uncertainties of 1e-7 V/A + 10 % to the normalized voltage data being inverted.\n\ndc_data.standard_deviation = 1e-7 + 0.1 * np.abs(dc_data.dobs)\n\n","type":"content","url":"/inv-dcr-3d#assign-uncertainties","position":15},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/inv-dcr-3d#design-a-tree-mesh","position":16},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Design a (Tree) Mesh"},"content":"Please visit the \n\n2.5D Forward Simulation tutorial to see the best practices for mesh design. The same rules for defining appropriate meshes for 2.5D simulations and inversion apply to 3D simulations and inversion.\n\nTutorial mesh: Here, a minimum cell width of 25 m (or 1/4 the minimum electrode spacing) is used within our survey region. The largest electrode spacing was 1000 m, so a the padding was extended at least 3000 m from the survey region. Using the \n\nrefine_surface method, we refine the tree mesh where there is significant topography. And using the \n\nrefine_points methods, we refine based on electrodes locations. Visit the \n\ntree mesh API to see additional refinement methods.\n\n# Defining domain size and minimum cell size\ndh = 25.0  # base cell width\ndom_width_x = 8000.0  # domain width x\ndom_width_y = 8000.0  # domain width y\ndom_width_z = 4000.0  # domain width z\n\n# Number of base mesh cells in each direction. Must be a power of 2\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcy = 2 ** int(np.round(np.log(dom_width_y / dh) / np.log(2.0)))  # num. base cells y\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh\nhx = [(dh, nbcx)]\nhy = [(dh, nbcy)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, 0.0, topo_xyz[:, -1].max()]\n\n# Mesh refinement based on surface topography\nk = np.sqrt(np.sum(topo_xyz[:, 0:2] ** 2, axis=1)) < 1200\nmesh.refine_surface(topo_xyz[k, :], padding_cells_by_level=[0, 4, 4], finalize=False)\n\n# Extract unique electrode locations.\nunique_locations = dc_data.survey.unique_electrode_locations\n\n# Mesh refinement near electrodes.\nmesh.refine_points(unique_locations, padding_cells_by_level=[6, 6, 4], finalize=False)\n\n# Finalize the mesh\nmesh.finalize()\n\n","type":"content","url":"/inv-dcr-3d#design-a-tree-mesh","position":17},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/inv-dcr-3d#define-the-active-cells","position":18},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Active Cells"},"content":"Simulated geophysical data are dependent on the subsurface distribution of physical property values. As a result, the cells lying below the surface topography are commonly referred to as ‘active cells’. And air cells, whose physical property values are fixed, are commonly referred to as ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/inv-dcr-3d#define-the-active-cells","position":19},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/inv-dcr-3d#project-electrodes-to-discretized-topography","position":20},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Project Electrodes to Discretized Topography"},"content":"Surface DC resistivity data will not be modeled accurately if the electrodes are modeled as living above or below the surface. It is especially problematic when electrodes are modeled as living in the air. Prior to inverting surface DC resistivity data, we must project the electrodes from their true elevation to the surface of the discretized topography. This is done using the \n\ndrape​_electrodes​_on​_topography method.\n\ndc_data.survey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/inv-dcr-3d#project-electrodes-to-discretized-topography","position":21},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Mapping from the Model to the Mesh"},"type":"lvl2","url":"/inv-dcr-3d#mapping-from-the-model-to-the-mesh","position":22},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Mapping from the Model to the Mesh"},"content":"Here, the model defines the log-conductivity values for all active cells. We use the \n\nsimpeg.maps.ExpMap to map from the model parameters to the conductivity values for all active cells. Then we use the \n\nsimpeg​.maps​.InjectActiveCells map to project the active cell resisitivities to the entire mesh. As explained in the \n\n2.5D Forward Simulation tutorial, air cells are given a fixed value of 1e-8 S/m to ensure the forward problem is well-conditionned. And the * operator is used to combine the separate mapping objects into a single mapping.\n\n# Model parameters to all cells\nlog_conductivity_map = maps.InjectActiveCells(mesh, active_cells, 1e-8) * maps.ExpMap(\n    nP=n_active\n)\n\n","type":"content","url":"/inv-dcr-3d#mapping-from-the-model-to-the-mesh","position":23},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Starting/Reference Models"},"type":"lvl2","url":"/inv-dcr-3d#starting-reference-models","position":24},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Starting/Reference Models"},"content":"The starting model defines a reasonable starting point for the inversion and does not necessarily represent an initial estimate of the true model. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration. For DC resistivity inversion, the starting model is frequently a halfspace estimated from the set of apparent resistivities/conductivities.\n\nThe reference model is used to include a-priori information. By default, the starting model is set as the reference model. The impact of the reference model on the inversion will be discussed in another tutorial.\n\nNotice that the length of the starting and reference models is equal to the number of model parameters!!!\n\n# Median apparent resistivity\nmedian_conductivity = np.median(apparent_conductivities)\n\n# Create starting model from log-conductivity\nstarting_conductivity_model = np.log(median_conductivity) * np.ones(n_active)\n\n# Zero reference conductivity model\nreference_conductivity_model = starting_conductivity_model.copy()\n\n","type":"content","url":"/inv-dcr-3d#starting-reference-models","position":25},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/inv-dcr-3d#define-the-forward-simulation","position":26},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Forward Simulation"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for 3D DC resistivity was discussed in the \n\n3D Forward Simulation tutorial. Here, we use the \n\nSimulation3DNodal simulation which solves for the electric potential on mesh nodes.\n\nSince our model consists of log-conductivities, we use sigmaMap to set the mapping from the model to the mesh cells. For reasonable cases, we can compute and store the Jacobian explicitly for 3D problems by setting storeJ to True. By doing this, we drastically reduce the run-time of the inversion. For larger problems being run on computers with insufficient RAM, you may need to set storeJ to False and invert the data without storing the sensitivities explicitly.\n\ndc_simulation = dc.simulation.Simulation3DNodal(\n    mesh, survey=dc_data.survey, sigmaMap=log_conductivity_map, storeJ=True\n)\n\n","type":"content","url":"/inv-dcr-3d#define-the-forward-simulation","position":27},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Data Misfit"},"type":"lvl2","url":"/inv-dcr-3d#define-the-data-misfit","position":28},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Data Misfit"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(simulation=dc_simulation, data=dc_data)\n\n","type":"content","url":"/inv-dcr-3d#define-the-data-misfit","position":29},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Regularization"},"type":"lvl2","url":"/inv-dcr-3d#define-the-regularization","position":30},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Regularization"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource. Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Length scales along x, y and z are used to balance the smallness and smoothness terms. And the reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros.\n\nBy default, the regularization acts on the model parameters; which in the case are the log-conductivities of the active cells. So we need to specify which cells are active in the regularization. And if we wanted to apply the regularization to a function of the model parameters, we would need to set an approprate mapping object using the mapping keyword argument.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    mesh,\n    active_cells=active_cells,\n    length_scale_x=100.0,\n    length_scale_y=100.0,\n    length_scale_z=100.0,\n    reference_model=reference_conductivity_model,\n)\n\n","type":"content","url":"/inv-dcr-3d#define-the-regularization","position":31},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Optimization Algorithm"},"type":"lvl2","url":"/inv-dcr-3d#define-the-optimization-algorithm","position":32},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Optimization Algorithm"},"content":"Here, we use the \n\nInexactGaussNewton class to solve the optimization problem using the inexact Gauss Newton with conjugate gradient solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches.\n\nopt_L2 = optimization.InexactGaussNewton(\n    maxIter=40, maxIterLS=20, maxIterCG=30, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-dcr-3d#define-the-optimization-algorithm","position":33},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Inverse Problem"},"type":"lvl2","url":"/inv-dcr-3d#define-the-inverse-problem","position":34},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define the Inverse Problem"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-dcr-3d#define-the-inverse-problem","position":35},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Provide Inversion Directives"},"type":"lvl2","url":"/inv-dcr-3d#provide-inversion-directives","position":36},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Provide Inversion Directives"},"content":"Directives represent operations that are carried out during the inversion. Here, we apply common directives for weighted least-squares inversion of DC resistivity data and describe their roles. These are:\n\nUpdateSensitivityWeights: apply sensitivity weighting to counteract the natural tendency of DC resistivity inversion to place materials near the electrodes. Since the problem is non-linear and the sensitivities are updated with every model, we set every_iteration=True. For DC resistivity inversion, we do not want to use the entire dynamic range of the sensitivities to generate our weighting. So we generally set threshold_value to a value betwewen 1e-4 and 1e-1. Warning: should not be used if storeJ set to False in the simulation class.\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem to reduce the number of conjugate gradient iterations. We set update_every_iteration=True because the ideal preconditioner is model-dependent. Warning: should not be used if storeJ set to False in the simulation class.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta. In general, a coolingFactor between 1.5 and 2.5, and coolingRate of 2 or 3 works well for DC resistivity inversion. Cooling beta too quickly will result in portions of the model getting trapped in local minima. And we will not be finding the solution that minimizes the optimization problem if the cooling rate is too small.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nif dc_simulation.storeJ:\n    sensitivity_weights = directives.UpdateSensitivityWeights(\n        every_iteration=True, threshold_value=1e-2\n    )\n    update_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\n    directives_list_L2 = [\n        sensitivity_weights,\n        update_jacobi,\n    ]\nelse:\n    directives_list_L2 = []\n\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=100)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=2)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 += [starting_beta, beta_schedule, target_misfit]\n\n","type":"content","url":"/inv-dcr-3d#provide-inversion-directives","position":37},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define and Run the Inversion"},"type":"lvl2","url":"/inv-dcr-3d#define-and-run-the-inversion","position":38},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Define and Run the Inversion"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run the inversion\nrecovered_log_conductivity_model = inv_L2.run(starting_conductivity_model)\n\n","type":"content","url":"/inv-dcr-3d#define-and-run-the-inversion","position":39},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Analyzing Inversion Outputs"},"type":"lvl2","url":"/inv-dcr-3d#analyzing-inversion-outputs","position":40},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl2":"Analyzing Inversion Outputs"},"content":"\n\n","type":"content","url":"/inv-dcr-3d#analyzing-inversion-outputs","position":41},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot Normalized Data Misfit in 3D Pseudosection","lvl2":"Analyzing Inversion Outputs"},"type":"lvl3","url":"/inv-dcr-3d#plot-normalized-data-misfit-in-3d-pseudosection","position":42},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot Normalized Data Misfit in 3D Pseudosection","lvl2":"Analyzing Inversion Outputs"},"content":"To see how well the recovered model reproduces the observed data, it is a good idea to compare the predicted and observed data.\nHere, we plot the normalized data misfit to determine whether the observed data are fit evenly. Correlated signatures in the normalized data misfits indicate we are overfitting/underfitting certain data. And that we must modify our uncertainties and re-run the inversion.\n\n# Predicted data from recovered model\ndpred_dc = inv_prob_L2.dpred\n\n# Compute the normalized data misfit\ndc_normalized_misfit = (dc_data.dobs - dpred_dc) / dc_data.standard_deviation\n\nif has_plotly:\n    fig = plot_3d_pseudosection(\n        dc_data.survey,\n        dc_normalized_misfit,\n        scale=\"linear\",\n        units=\"\",\n        vlim=[-2.5, 2.5],\n        marker_opts={\"colorscale\": \"RdBu\"},\n    )\n\n    fig.update_layout(\n        title_text=\"Normalized Data Misfit\",\n        title_x=0.5,\n        title_font_size=24,\n        width=650,\n        height=500,\n        scene_camera=dict(\n            center=dict(x=0, y=0, z=-0.4), eye=dict(x=1.5, y=-1.5, z=1.8)\n        ),\n    )\n\n    #     plotly.io.show(fig)\n    html_str = plotly.io.to_html(fig)\n    display(HTML(html_str))\n\nelse:\n    print(\"INSTALL 'PLOTLY' TO VISUALIZE 3D PSEUDOSECTIONS\")\n\n","type":"content","url":"/inv-dcr-3d#plot-normalized-data-misfit-in-3d-pseudosection","position":43},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot 2D Pseudosections for Individual Survey Lines","lvl2":"Analyzing Inversion Outputs"},"type":"lvl3","url":"/inv-dcr-3d#plot-2d-pseudosections-for-individual-survey-lines","position":44},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot 2D Pseudosections for Individual Survey Lines","lvl2":"Analyzing Inversion Outputs"},"content":"For large datasets comprised of many survey lines, interpretation can be challenging if we plot every datum. Here, we plot the observed data, predicted data and normalized data misfit for a specified survey line.\n\n# Data associated with the line index provided\nline_index = 0\nk = lineID == line_index + 1\ndata_array = [\n    np.abs(dc_data.dobs[k]),\n    np.abs(dpred_dc[k]),\n    (dc_data.dobs[k] - dpred_dc[k]) / dc_data.standard_deviation[k],\n]\n\n# Plot 2D pseudosections (observed, predicted, normalized misfit)\nfig = plt.figure(figsize=(9, 11))\nplot_title = [\"Observed Voltage\", \"Predicted Voltage\", \"Normalized Misfit\"]\nplot_units = [\"V/A\", \"V/A\", \"\"]\nscale = [\"log\", \"log\", \"linear\"]\ncmap_list = [mpl.cm.viridis, mpl.cm.viridis, mpl.cm.RdYlBu]\n\nax1 = 3 * [None]\ncax1 = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.15, 0.72 - 0.33 * ii, 0.65, 0.21])\n    cax1[ii] = fig.add_axes([0.81, 0.72 - 0.33 * ii, 0.03, 0.21])\n    cplot[ii] = plot_pseudosection(\n        survey_2d_list[line_index],\n        data_array[ii],\n        \"contourf\",\n        ax=ax1[ii],\n        cax=cax1[ii],\n        scale=scale[ii],\n        cbar_label=plot_units[ii],\n        mask_topography=True,\n        contourf_opts={\"levels\": 25, \"cmap\": cmap_list[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n\nplt.show()\n\n","type":"content","url":"/inv-dcr-3d#plot-2d-pseudosections-for-individual-survey-lines","position":45},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot True and Recovered Conductivity Model","lvl2":"Analyzing Inversion Outputs"},"type":"lvl3","url":"/inv-dcr-3d#plot-true-and-recovered-conductivity-model","position":46},{"hierarchy":{"lvl1":"3D DC Resistivity Inversion","lvl3":"Plot True and Recovered Conductivity Model","lvl2":"Analyzing Inversion Outputs"},"content":"\n\n# Define conductivity model in S/m\nbackground_value = 1e-2\nconductor_value = 1e-1\nresistor_value = 1e-3\n\n# Define true model\ntrue_conductivity_model = background_value * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\ntrue_conductivity_model[ind_conductor] = conductor_value\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\ntrue_conductivity_model[ind_resistor] = resistor_value\n\n# Convert log-conductivities to conductivities\nrecovered_conductivity_L2 = np.exp(recovered_log_conductivity_model)\n\n# Define a mapping to ignore inactive cells in plot\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nnorm = LogNorm(vmin=1e-3, vmax=1e-1)\n\nfig = plt.figure(figsize=(10, 9))\nax1 = 2 * [None]\nax2 = 2 * [None]\ncbar = 2 * [None]\ntitle_str = [\n    \"True Conductivity Model\",\n    \"Recovered Model (L2)\",\n]\nplotting_model = [\n    true_conductivity_model,\n    recovered_conductivity_L2,\n]\n\nfor ii in range(0, 2):\n    ax1[ii] = fig.add_axes([0.14, 0.6 - 0.5 * ii, 0.68, 0.35])\n\n    temp = plotting_map * plotting_model[ii]\n\n    mesh.plot_slice(\n        temp,\n        ax=ax1[ii],\n        normal=\"Y\",\n        ind=int(len(mesh.h[1]) / 2),\n        grid=False,\n        pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": norm},\n    )\n    ax1[ii].set_title(title_str[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    ax1[ii].set_ylabel(\"z (m)\")\n    ax1[ii].set_xlim([-1200, 1200])\n    ax1[ii].set_ylim([topo_xyz[:, -1].max() - 1200, topo_xyz[:, -1].max()])\n\n    ax2[ii] = fig.add_axes([0.84, 0.6 - 0.5 * ii, 0.03, 0.35])\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n    )\n    cbar[ii].set_label(r\"$\\sigma$ (S/m)\", rotation=270, labelpad=15, size=16)","type":"content","url":"/inv-dcr-3d#plot-true-and-recovered-conductivity-model","position":47},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation"},"type":"lvl1","url":"/fwd-ip-2d","position":0},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: Induced polarization, 2.5D forward simulation, apparent chargeability, tree mesh.\n\nSummary: Here, we use the \n\nsimpeg​.electromagnetics​.static​.induced​_polarization module to simulate 2.5D DC induced polarization (IP) data on a tree mesh. This approach is ideal when the local geology doesn’t change along the strike direction, as we can leverage the symmetry of the problem to reduce computational cost.\n\nBecause the same survey geometry, mesh and topography that are used to simulate DC resistivity data are used simulate IP data, almost all of the fundamental functionality used in this tutorial is described in detail in the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial. In this tutorial, we focus primarily on functionality related to the simulation of IP data. More specifically, we discuss:\n\nDefining the chargeability model\n\nHow to simulate IP data\n\nUnits of the apparent chargeability model and predicted data\n\n","type":"content","url":"/fwd-ip-2d","position":1},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-ip-2d#import-modules","position":2},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to IP is imported from \n\nsimpeg​.electromagnetics​.static​.induced​_polarization.\nWe also import some useful utility functions from \n\nsimpeg.utils. To simulate DC and IP data, we need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we used the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import induced_polarization as ip\nfrom simpeg.utils import model_builder\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import write_dcip2d_ubc\nfrom simpeg import maps, data\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    generate_dcip_sources_line,\n    pseudo_locations,\n    plot_pseudosection,\n)\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Common Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm, Normalize\n\nmpl.rcParams.update({\"font.size\": 14})\n\nwrite_output = False  # Optional\n\n","type":"content","url":"/fwd-ip-2d#import-modules","position":3},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-ip-2d#define-the-topography","position":4},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Topography"},"content":"True surface topography is defined as an (N, 3) \n\nnumpy.ndarray.\nFor use in a 2.5D simulation however, topography is defined as an (N, 2) \n\nnumpy.ndarray, where the first coordinate represent along-line position and the second coordinate represents the vertical position. Here, we define the 2D topography used for the 2.5D simulation.\n\n# Along-line locations\nx_topo = np.linspace(-2000, 2000, 401)\n\n# Elevation as a function of along-line location\nT = 800.0\nz_topo = 20.0 * np.sin(2 * np.pi * x_topo / T) + 140.0\nz_topo[x_topo < -3 * T / 4] = 160.0\nz_topo[x_topo > 3 * T / 4] = 120.0\nz_topo += 50.0 * (1.0 + np.tanh(-3 * (x_topo + 1200.0) / T))\nz_topo -= 50.0 * (1.0 + np.tanh(3 * (x_topo - 1200.0) / T))\n\n# Define full 2D topography\ntopo_2d = np.c_[x_topo, z_topo]\n\n# Plot 2D topography\nfig = plt.figure(figsize=(10, 2))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\nax.plot(x_topo, z_topo, color=\"b\", linewidth=2)\nax.set_xlabel(\"x (m)\", labelpad=5)\nax.set_ylabel(\"z (m)\", labelpad=5)\nax.grid(True)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=10)\nplt.show(fig)\n\n","type":"content","url":"/fwd-ip-2d#define-the-topography","position":5},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the IP Survey"},"type":"lvl2","url":"/fwd-ip-2d#define-the-ip-survey","position":6},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the IP Survey"},"content":"A full description of elements required to define DC and IP surveys was presented in the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial. Here, we take the same approach. The only difference is that our receivers are defined to measure apparent chargeabilities. Because SimPEG uses a linearized formulation for simulating IP data; see \n\nSimulation2DCellCentered or \n\nSimulation2DNodal, the units of the apparent chargeability data are the same as the units chosen to represent the subsurface chargeabilities.\n\nThe survey line is an 800 m long EW dipole-dipole line with an electrode spacing of 40 m. There is a maximum of 10 potential electrodes per current electrode.\n\n# Define survey line parameters\nsurvey_type = \"dipole-dipole\"\ndimension_type = \"2D\"\ndata_type = \"apparent_chargeability\"\nend_locations = np.r_[-400.0, 400.0]\nstation_separation = 40.0\nnum_rx_per_src = 10\n\nip_source_list = generate_dcip_sources_line(\n    survey_type,\n    data_type,\n    dimension_type,\n    end_locations,\n    topo_2d,\n    num_rx_per_src,\n    station_separation,\n)\n\nip_survey = ip.survey.Survey(ip_source_list)\n\npseudo_locations_xz = pseudo_locations(ip_survey)\nfig = plt.figure(figsize=(8, 2.75))\nax = fig.add_axes([0.1, 0.1, 0.85, 0.8])\nax.scatter(pseudo_locations_xz[:, 0], pseudo_locations_xz[:, -1], 8, \"r\")\nax.set_xlabel(\"x (m)\")\nax.set_ylabel(\"z (m)\")\nax.set_title(\"Pseudo-locations\")\nplt.show()\n\n","type":"content","url":"/fwd-ip-2d#define-the-ip-survey","position":7},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/fwd-ip-2d#design-a-tree-mesh","position":8},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Design a (Tree) Mesh"},"content":"Here, we generate a tree mesh based on the survey geometry. The best-practice approach for generating meshes for DC/IP simulations is provided in the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial.\n\ndh = 4  # base cell width\ndom_width_x = 3200.0  # domain width x\ndom_width_z = 2400.0  # domain width z\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh with top at z = 0 m.\nhx = [(dh, nbcx)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hz], x0=\"CN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, z_topo.max()]\n\n# Mesh refinement based on topography\nmesh.refine_surface(\n    topo_2d,\n    padding_cells_by_level=[0, 0, 4, 4],\n    finalize=False,\n)\n\n# Extract unique electrode locations.\nunique_locations = ip_survey.unique_electrode_locations\n\n# Mesh refinement near electrodes.\nmesh.refine_points(\n    unique_locations, padding_cells_by_level=[8, 12, 6, 6], finalize=False\n)\n\nmesh.finalize()\n\n","type":"content","url":"/fwd-ip-2d#design-a-tree-mesh","position":9},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-ip-2d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Active Cells"},"content":"Use the \n\nactive_from_xyz utility function to obtain the indices of the active mesh cells from topography (e.g. cells below surface).\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_2d)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/fwd-ip-2d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Background Conductivity/Resistivity"},"type":"lvl2","url":"/fwd-ip-2d#define-the-background-conductivity-resistivity","position":12},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Background Conductivity/Resistivity"},"content":"In order to simulate IP data, we require the background conductivity/resistivity defined on the entire mesh. You can generate this directly, or apply the appropriate mapping to a different parameterization of the conductivity/resistivity.\n\nFor the tutorial, we generate the conductivity model that was used for the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial; i.e. the electrical conductivities of all active cells. And so we must use the \n\nsimpeg​.maps​.InjectActiveCells mapping to map from the model space to the conductivities on the entire mesh.\n\n# Define electrical conductivities in S/m\nair_conductivity = 1e-8\nbackground_conductivity = 1e-2\nconductor_conductivity = 1e-1\nresistor_conductivity = 1e-3\n\n# Define conductivity model\nconductivity_model = background_conductivity * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-120.0, 40.0], 60.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_conductor] = conductor_conductivity\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[120.0, 72.0], 60.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_resistor] = resistor_conductivity\n\n# Mapping from conductivity model to mesh\nconductivity_map = maps.InjectActiveCells(mesh, active_cells, air_conductivity)\n\n# Mapping to neglect air cells when plotting\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nfig = plt.figure(figsize=(9, 4))\nnorm = LogNorm(vmin=1e-3, vmax=1e-1)\n\nax1 = fig.add_axes([0.14, 0.17, 0.68, 0.7])\nmesh.plot_image(\n    plotting_map * conductivity_model,\n    ax=ax1,\n    grid=False,\n    pcolor_opts={\"norm\": norm, \"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_xlim(-500, 500)\nax1.set_ylim(-300, 200)\nax1.set_title(\"Background Conductivity Model\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.84, 0.17, 0.03, 0.7])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(r\"$\\sigma$ (S/m)\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/fwd-ip-2d#define-the-background-conductivity-resistivity","position":13},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Chargeability Model and Mapping"},"type":"lvl2","url":"/fwd-ip-2d#define-the-chargeability-model-and-mapping","position":14},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the Chargeability Model and Mapping"},"content":"The model does not need to be synonymous with the physical property values. But it is common to define chargeability models as the chargeabilities for all subsurface (active) cells. So, what are the units?\n\nSimPEG uses a linearized formulation for simulating IP data; see \n\nSimulation2DCellCentered or \n\nSimulation2DNodal. In this formulation, any standard definition of the chargeability can be used. And the resulting apparent chargeability data will be in terms of the same units; e.g. intrinsic chargeability (V/V or mV/V) or integrated chargeability (ms). If you are simulating secondary voltages, the chargeability model must represent intrinsic chargeabilities (0 \\leq \\eta \\leq 1) in V/V.\n\nFor this tutorial, we use the intrinsic chargeability in units V/V. Here, the conductive sphere is chargeable, but the resistive sphere and the host are not. Note that unlike DC resistivity, the physical property value defining air cells for IP simulation can be set to zero.\n\n# Intrinsic chargeability in V/V (unitless).\nair_chargeability = 0.0\nbackground_chargeability = 0.0\nsphere_chargeability = 1e-1\n\n# Define chargeability model\nchargeability_model = background_chargeability * np.ones(n_active)\n\nind_chargeable = model_builder.get_indices_sphere(\n    np.r_[-120.0, 40.0], 60.0, mesh.cell_centers[active_cells, :]\n)\nchargeability_model[ind_chargeable] = sphere_chargeability\n\n# Define mapping for chargeability\nchargeability_map = maps.InjectActiveCells(mesh, active_cells, air_chargeability)\n\n# Plot Chargeability Model\nfig = plt.figure(figsize=(9, 4))\n\nnorm = Normalize(vmin=0.0, vmax=0.1)\n\nax1 = fig.add_axes([0.14, 0.17, 0.68, 0.7])\nmesh.plot_image(\n    plotting_map * chargeability_model,\n    ax=ax1,\n    grid=False,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n)\nax1.set_xlim(-500, 500)\nax1.set_ylim(-300, 200)\nax1.set_title(\"Intrinsic Chargeability\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.84, 0.17, 0.03, 0.7])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.plasma\n)\ncbar.set_label(\"Intrinsic Chargeability (V/V)\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/fwd-ip-2d#define-the-chargeability-model-and-mapping","position":15},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/fwd-ip-2d#project-electrodes-to-discretized-topography","position":16},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"content":"As explained in the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial, we use the \n\ndrape​_electrodes​_on​_topography method to project the electrodes to the discrete surface topography.\n\nip_survey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/fwd-ip-2d#project-electrodes-to-discretized-topography","position":17},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the IP Simulation"},"type":"lvl2","url":"/fwd-ip-2d#define-the-ip-simulation","position":18},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Define the IP Simulation"},"content":"There are two simulation classes which may be used to simulate 2.5D IP data:\n\nSimulation2DNodel, which defines the discrete electric potentials on mesh nodes.\n\nSimulation2DCellCentered, which defines the discrete electric potentials at cell centers.\n\nFor surface DC and IP data, the nodal formulation is more well-suited and will be used here. The cell-centered formulation works well for simulating borehole DC and IP data. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe mesh\n\na background conductivity or resistivity model\n\nthe mapping from the chargeability model to the mesh\n\nIf working with electrical conductivity, use the sigma keyword argument to define the background conductivity on the entire mesh. If working with electrical resistivity, use the rho keyword argument to define the background resistivity on the entire mesh. The etaMap is used to define the mapping from the chargeability model to the chargeabilities on the entire mesh.\n\nip_simulation = ip.Simulation2DNodal(\n    mesh,\n    survey=ip_survey,\n    etaMap=chargeability_map,\n    sigma=conductivity_map * conductivity_model,\n)\n\n","type":"content","url":"/fwd-ip-2d#define-the-ip-simulation","position":19},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Simulate IP Data"},"type":"lvl2","url":"/fwd-ip-2d#simulate-ip-data","position":20},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Simulate IP Data"},"content":"\n\ndpred_ip = ip_simulation.dpred(chargeability_model)\n\n","type":"content","url":"/fwd-ip-2d#simulate-ip-data","position":21},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Plot IP Data in Pseudosection"},"type":"lvl2","url":"/fwd-ip-2d#plot-ip-data-in-pseudosection","position":22},{"hierarchy":{"lvl1":"2.5D IP Forward Simulation","lvl2":"Plot IP Data in Pseudosection"},"content":"Here we use the \n\nplot_pseudosection utility function to represent predicted data on pseudosection plots.\n\nfig = plt.figure(figsize=(9, 4))\n\nax1 = fig.add_axes([0.1, 0.1, 0.7, 0.8])\ncax1 = fig.add_axes([0.82, 0.1, 0.025, 0.8])\nplot_pseudosection(\n    ip_survey,\n    dpred_ip,\n    \"contourf\",\n    ax=ax1,\n    cax=cax1,\n    scale=\"linear\",\n    cbar_label=\"V/V\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.plasma},\n)\nax1.set_title(\"Apparent Chargeability (V/V)\")\n\nplt.show()\n\nOptional: Write data and topography\n\nif write_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_ip_2d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    # Add 5% Gaussian noise to each datum\n    rng = np.random.default_rng(seed=225)\n    std = 5e-3 * np.ones_like(dpred_ip)\n    ip_noise = rng.normal(scale=std, size=len(dpred_ip))\n    dobs = dpred_ip + ip_noise\n\n    # Create a survey with the original electrode locations\n    # and not the shifted ones\n    # Generate source list for DC survey line\n    source_list = generate_dcip_sources_line(\n        survey_type,\n        data_type,\n        dimension_type,\n        end_locations,\n        topo_2d,\n        num_rx_per_src,\n        station_separation,\n    )\n    survey_original = ip.survey.Survey(source_list)\n\n    # Write out data at their original electrode locations (not shifted)\n    data_obj = data.Data(survey_original, dobs=dobs, standard_deviation=std)\n    fname = dir_path + \"ip_data.obs\"\n    write_dcip2d_ubc(fname, data_obj, \"apparent_chargeability\", \"dobs\")\n\n    fname = dir_path + \"topo_2d.txt\"\n    np.savetxt(fname, topo_2d, fmt=\"%.4e\")","type":"content","url":"/fwd-ip-2d#plot-ip-data-in-pseudosection","position":23},{"hierarchy":{"lvl1":"3D IP Forward Simulation"},"type":"lvl1","url":"/fwd-ip-3d","position":0},{"hierarchy":{"lvl1":"3D IP Forward Simulation"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nMedium-weight notebook\n\nRequires moderate computational resources. Run-times may exceed several minutes and require up to 8 GB of available RAM.\n\nKeywords: Induced polarization, 3D forward simulation, apparent chargeability, tree mesh.\n\nSummary: Here, we use the \n\nsimpeg​.electromagnetics​.static​.induced​_polarization module to simulate 3D DC induced polarization (IP) data on a tree mesh. This approach is ideal when the local geology doesn’t change along the strike direction, as we can leverage the symmetry of the problem to reduce computational cost.\n\nBecause the same survey geometry, mesh and topography that are used to simulate DC resistivity data are used simulate IP data, almost all of the fundamental functionality used in this tutorial is described in detail in the \n\n3D Forward Simulation of DC Resistivity Data tutorial. In this tutorial, we focus primarily on functionality related to the simulation of IP data. More specifically, we discuss:\n\nDefining the chargeability model\n\nHow to simulate IP data\n\nUnits of the apparent chargeability model and predicted data\n\n","type":"content","url":"/fwd-ip-3d","position":1},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Import Modules"},"type":"lvl2","url":"/fwd-ip-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to IP is imported from \n\nsimpeg​.electromagnetics​.static​.induced​_polarization.\nWe also import some useful utility functions from \n\nsimpeg.utils. To simulate DC and IP data, we need to define our problem geometry on a numerical grid (or mesh).\nTo generate the mesh, we used the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg import maps, data\nfrom simpeg.utils import model_builder\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import write_dcip_xyz\nfrom simpeg.electromagnetics.static import induced_polarization as ip\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    generate_dcip_sources_line,\n    pseudo_locations,\n    plot_pseudosection,\n    convert_survey_3d_to_2d_lines,\n)\n\ntry:\n    import plotly\n    from simpeg.electromagnetics.static.utils.static_utils import plot_3d_pseudosection\n    from IPython.core.display import display, HTML\n\n    has_plotly = True\nexcept ImportError:\n    has_plotly = False\n    pass\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import mkvc, active_from_xyz\n\n# Common Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm, Normalize\n\nmpl.rcParams.update({\"font.size\": 14})\n\nwrite_output = False  # Optional\n\n","type":"content","url":"/fwd-ip-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-ip-3d#define-the-topography","position":4},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Topography"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray for 3D simulations.\nHere, we create basic topography for the forward simulation.\nFor user-specific simulations, you may load topography from an XYZ file.\n\n# Generate some topography\nx_topo, y_topo = np.meshgrid(\n    np.linspace(-2100, 2100, 141), np.linspace(-2100, 2100, 141)\n)\nz_topo = 410.0 + 140.0 * (1 / np.pi) * (\n    np.arctan((x_topo - 500 * np.sin(np.pi * y_topo / 2800) - 400.0) / 200.0)\n    - np.arctan((x_topo - 500 * np.sin(np.pi * y_topo / 2800) + 400.0) / 200.0)\n)\n\n# Turn into a (N, 3) numpy.ndarray\nx_topo, y_topo, z_topo = mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)\ntopo_xyz = np.c_[mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)]\n\n# Plot the topography\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([-400, 400])\nax.scatter3D(topo_xyz[:, 0], topo_xyz[:, 1], topo_xyz[:, 2], s=0.25, c=\"b\")\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=45.0, azim=-125)\n\n","type":"content","url":"/fwd-ip-3d#define-the-topography","position":5},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the IP Survey"},"type":"lvl2","url":"/fwd-ip-3d#define-the-ip-survey","position":6},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the IP Survey"},"content":"A full description of elements required to define DC and IP surveys was presented in the \n\n3D Forward Simulation of DC Resistivity Data tutorial. Here, we take the same approach. The only difference is that our receivers are defined to measure apparent chargeabilities. Because SimPEG uses a linearized formulation for simulating IP data; see \n\nSimulation3DCellCentered or \n\nSimulation3DNodal, the units of the apparent chargeability data are the same as the units chosen to represent the subsurface chargeabilities..\n\nHere, the survey consists of 5 IP lines that use a dipole-dipole electrode configuration; 1 line along the East-West direction and 2 lines along the North-South direction. Each line is 2000 m in length and has an electrode spacing of 100 m.\n\n# Define the parameters for each survey line\nsurvey_type = \"dipole-dipole\"\ndimension_type = \"3D\"\ndata_type = \"apparent_chargeability\"\nend_locations_list = [\n    np.r_[-1000.0, 1000.0, 0.0, 0.0],\n    np.r_[-600.0, -600.0, -1000.0, 1000.0],\n    np.r_[-300.0, -300.0, -1000.0, 1000.0],\n    np.r_[0.0, 0.0, -1000.0, 1000.0],\n    np.r_[300.0, 300.0, -1000.0, 1000.0],\n    np.r_[600.0, 600.0, -1000.0, 1000.0],\n]\nstation_separation = 100.0\nnum_rx_per_src = 8\n\nip_source_list = []\nfor ii in range(0, len(end_locations_list)):\n    ip_source_list += generate_dcip_sources_line(\n        survey_type,\n        \"apparent_chargeability\",\n        dimension_type,\n        end_locations_list[ii],\n        topo_xyz,\n        num_rx_per_src,\n        station_separation,\n    )\n\n# Define the survey\nsurvey = ip.survey.Survey(ip_source_list)\n\nunique_locations = survey.unique_electrode_locations\nfig = plt.figure(figsize=(12, 2.75))\nax1 = fig.add_axes([0.1, 0.1, 0.2, 0.8])\nax1.scatter(unique_locations[:, 0], unique_locations[:, 1], 8, \"r\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\nax1.set_title(\"Horizontal locations\")\n\npseudo_locations = pseudo_locations(survey)\ninds = (pseudo_locations[:, 1] == 0.0) & (np.abs(pseudo_locations[:, 0]) != 350)\nax2 = fig.add_axes([0.4, 0.1, 0.55, 0.8])\nax2.scatter(pseudo_locations[inds, 0], pseudo_locations[inds, -1], 8, \"r\")\nax2.set_xlabel(\"x (m)\")\nax2.set_ylabel(\"z (m)\")\nax2.set_title(\"Pseudo-locations (EW line)\")\nplt.show()\n\n","type":"content","url":"/fwd-ip-3d#define-the-ip-survey","position":7},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/fwd-ip-3d#design-a-tree-mesh","position":8},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Design a (Tree) Mesh"},"content":"Here, we generate a tree mesh based on the survey geometry. We use the same mesh that was generated for the \n\n3D Forward Simulation of DC Resistivity Data tutorial. The best-practices for generating meshes for DC/IP simulations is presented in the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial.\n\n# Defining domain size and minimum cell size\ndh = 25.0  # base cell width\ndom_width_x = 8000.0  # domain width x\ndom_width_y = 8000.0  # domain width y\ndom_width_z = 4000.0  # domain width z\n\n# Number of base mesh cells in each direction. Must be a power of 2\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcy = 2 ** int(np.round(np.log(dom_width_y / dh) / np.log(2.0)))  # num. base cells y\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh\nhx = [(dh, nbcx)]\nhy = [(dh, nbcy)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, 0.0, z_topo.max()]\n\n# Mesh refinement based on surface topography\nk = np.sqrt(np.sum(topo_xyz[:, 0:2] ** 2, axis=1)) < 1200\nmesh.refine_surface(topo_xyz[k, :], padding_cells_by_level=[0, 4, 4], finalize=False)\n\n# Mesh refinement near electrodes.\nmesh.refine_points(unique_locations, padding_cells_by_level=[6, 6, 4], finalize=False)\n\n# Finalize the mesh\nmesh.finalize()\n\n","type":"content","url":"/fwd-ip-3d#design-a-tree-mesh","position":9},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-ip-3d#define-the-active-cells","position":10},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Active Cells"},"content":"Use the \n\nactive_from_xyz utility function to obtain the indices of the active mesh cells from topography (e.g. cells below surface).\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/fwd-ip-3d#define-the-active-cells","position":11},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Background Conductivity/Resistivity"},"type":"lvl2","url":"/fwd-ip-3d#define-the-background-conductivity-resistivity","position":12},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Background Conductivity/Resistivity"},"content":"In order to simulate IP data, we require the background conductivity/resistivity defined on the entire mesh. You can generate this directly, or apply the appropriate mapping to different parameterization of the conductivity/resistivity. Here, we generate the same conuductivity model that was used for the \n\n3D Forward Simulation of DC Resistivity Data tutorial.\n\n# Define electrical conductivities in S/m\nair_conductivity = 1e-8\nbackground_conductivity = 1e-2\nconductor_conductivity = 1e-1\nresistor_conductivity = 1e-3\n\n# Define conductivity model\nconductivity_model = background_conductivity * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_conductor] = conductor_conductivity\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_resistor] = resistor_conductivity\n\n# Mapping from conductivity to all mesh cells.\nconductivity_map = maps.InjectActiveCells(mesh, active_cells, air_conductivity)\n\n# Mapping to neglect air cells when plotting\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nfig = plt.figure(figsize=(10, 4.5))\n\nnorm = LogNorm(vmin=1e-3, vmax=1e-1)\n\nax1 = fig.add_axes([0.15, 0.15, 0.68, 0.75])\nmesh.plot_slice(\n    plotting_map * conductivity_model,\n    ax=ax1,\n    normal=\"Y\",\n    ind=int(len(mesh.h[1]) / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": norm},\n)\nax1.set_title(\"Conductivity Model\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\nax1.set_xlim([-1500, 1500])\nax1.set_ylim([z_topo.max() - 1500, z_topo.max()])\n\nax2 = fig.add_axes([0.84, 0.15, 0.03, 0.75])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, cmap=mpl.cm.RdYlBu_r, norm=norm, orientation=\"vertical\"\n)\ncbar.set_label(r\"$\\sigma$ [S/m]\", rotation=270, labelpad=15, size=16)\n\n","type":"content","url":"/fwd-ip-3d#define-the-background-conductivity-resistivity","position":13},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Chargeability Model and Mapping"},"type":"lvl2","url":"/fwd-ip-3d#define-the-chargeability-model-and-mapping","position":14},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the Chargeability Model and Mapping"},"content":"The model does not need to be synonymous with the physical property values. But it is common to define chargeability models as the chargeabilities for all subsurface (active) cells. So, what are the units?\n\nSimPEG uses a linearized formulation for simulating IP data; see \n\nSimulation2DCellCentered or \n\nSimulation2DNodal. In this formulation, any standard definition of the chargeability can be used. And the resulting apparent chargeability data will be in terms of the same units; e.g. intrinsic chargeability (V/V or mV/V) or integrated chargeability (ms). If you are simulating secondary voltages, the chargeability model must represent intrinsic chargeabilities (0 \\leq \\eta \\leq 1) in V/V.\n\nFor this tutorial, we use the intrinsic chargeability in units V/V. Here, the conductive sphere is chargeable, but the resistive sphere and the host are not. Note that unlike DC resistivity, the physical property value defining air cells for IP simulation can be set to zero.\n\n# Define intrinsic chargeability model (V/V)\nair_value = 0.0\nbackground_value = 1e-6\nchargeable_value = 0.1\n\n# Define chargeability model\nchargeability_model = background_value * np.ones(n_active)\n\nind_chargeable = model_builder.get_indices_sphere(\n    np.r_[-350.0, 0.0, 100.0], 160.0, mesh.cell_centers[active_cells, :]\n)\n\nchargeability_model[ind_chargeable] = chargeable_value\n\n# Define mapping from model to mesh cells\nchargeability_map = maps.InjectActiveCells(mesh, active_cells, air_value)\n\n# Plot Chargeability Model\nfig = plt.figure(figsize=(10, 4))\n\nnorm = Normalize(vmin=0.0, vmax=0.1)\n\nax1 = fig.add_axes([0.15, 0.15, 0.67, 0.75])\nmesh.plot_slice(\n    plotting_map * chargeability_model,\n    ax=ax1,\n    normal=\"Y\",\n    ind=int(len(mesh.h[1]) / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n)\nax1.set_title(\"Chargeability Model\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\nax1.set_xlim([-1500, 1500])\nax1.set_ylim([z_topo.max() - 1500, z_topo.max()])\n\nax2 = fig.add_axes([0.84, 0.15, 0.03, 0.75])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, cmap=mpl.cm.plasma, norm=norm, orientation=\"vertical\", format=\"%.2f\"\n)\ncbar.set_label(\"Intrinsic Chargeability [V/V]\", rotation=270, labelpad=15, size=12)\n\n","type":"content","url":"/fwd-ip-3d#define-the-chargeability-model-and-mapping","position":15},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/fwd-ip-3d#project-electrodes-to-discretized-topography","position":16},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Project Electrodes to Discretized Topography"},"content":"As explained in the \n\n3D Forward Simulation of DC Resistivity Data tutorial, we use the \n\ndrape​_electrodes​_on​_topography method to project the electrodes to the discrete surface topography.\n\nsurvey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/fwd-ip-3d#project-electrodes-to-discretized-topography","position":17},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the IP Simulation"},"type":"lvl2","url":"/fwd-ip-3d#define-the-ip-simulation","position":18},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Define the IP Simulation"},"content":"There are two simulation classes which may be used to simulate 2.5D IP data:\n\nSimulation3DNodel, which defines the discrete electric potentials on mesh nodes.\n\nSimulation3DCellCentered, which defines the discrete electric potentials at cell centers.\n\nFor surface DC and IP data, the nodal formulation is more well-suited and will be used here. The cell-centered formulation works well for simulating borehole DC and IP data. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe mesh\n\na background conductivity or resistivity model\n\nthe mapping from the chargeability model to the mesh\n\nIf working with electrical conductivity, use the sigma keyword argument to define the background conductivity on the entire mesh. If working with electrical resistivity, use the rho keyword argument to define the background resistivity on the entire mesh. The etaMap is used to define the mapping from the chargeability model to the chargeabilities on the entire mesh.\n\nip_simulation = ip.Simulation3DNodal(\n    mesh,\n    survey=survey,\n    etaMap=chargeability_map,\n    sigma=conductivity_map * conductivity_model,\n)\n\n","type":"content","url":"/fwd-ip-3d#define-the-ip-simulation","position":19},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Simulate IP Data"},"type":"lvl2","url":"/fwd-ip-3d#simulate-ip-data","position":20},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Simulate IP Data"},"content":"\n\ndpred_ip = ip_simulation.dpred(chargeability_model)\n\n","type":"content","url":"/fwd-ip-3d#simulate-ip-data","position":21},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Plot IP Data in Pseudosection"},"type":"lvl2","url":"/fwd-ip-3d#plot-ip-data-in-pseudosection","position":22},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl2":"Plot IP Data in Pseudosection"},"content":"\n\n","type":"content","url":"/fwd-ip-3d#plot-ip-data-in-pseudosection","position":23},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl3":"Plot 3D Pseudosection","lvl2":"Plot IP Data in Pseudosection"},"type":"lvl3","url":"/fwd-ip-3d#plot-3d-pseudosection","position":24},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl3":"Plot 3D Pseudosection","lvl2":"Plot IP Data in Pseudosection"},"content":"For general 3D survey configurations, we can use the \n\nplot​_3d​_pseudosection utility function to plot 3D pseudosection data. For large datasets or for surveys with unconventional electrode geometry, interpretation can be challenging if we plot every datum. Here, we plot 3 out of the 6 survey lines to better image anomalous structures. To plot ALL of the data, simply remove the keyword argument plane_points when calling plot_3d_pseudosection. To use this utility, you must have Python’s \n\nplotly package.\n\n# Empty list for plane points\nplane_points = []\n\n# 3-points defining the plane for EW survey line\np1, p2, p3 = np.array([-1000, 0, 0]), np.array([1000, 0, 0]), np.array([0, 0, -1000])\nplane_points.append([p1, p2, p3])\n\n# NS at x = -300 m\np1, p2, p3 = (\n    np.array([-300, -1000, 0]),\n    np.array([-300, 1000, 0]),\n    np.array([-300, 0, -1000]),\n)\nplane_points.append([p1, p2, p3])\n\n# NS at x = 300 m\np1, p2, p3 = (\n    np.array([300, -1000, 0]),\n    np.array([300, 1000, 0]),\n    np.array([300, 0, -1000]),\n)\nplane_points.append([p1, p2, p3])\n\nif has_plotly:\n    fig = plot_3d_pseudosection(\n        survey,\n        dpred_ip,\n        vlim=[0.0, np.max(dpred_ip)],\n        scale=\"linear\",\n        units=\"V/V\",\n        plane_points=plane_points,\n        plane_distance=15,\n        marker_opts={\"colorscale\": \"plasma\"},\n    )\n\n    fig.update_layout(\n        title_text=\"Apparent Chargeability\",\n        title_x=0.5,\n        title_font_size=24,\n        width=650,\n        height=500,\n        scene_camera=dict(center=dict(x=0.05, y=0, z=-0.4)),\n    )\n\n    #     plotly.io.show(fig)\n    html_str = plotly.io.to_html(fig)\n    display(HTML(html_str))\n\nelse:\n    print(\"INSTALL 'PLOTLY' TO VISUALIZE 3D PSEUDOSECTIONS\")\n\n","type":"content","url":"/fwd-ip-3d#plot-3d-pseudosection","position":25},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl3":"Plot Individual Lines in 2D Pseudosection","lvl2":"Plot IP Data in Pseudosection"},"type":"lvl3","url":"/fwd-ip-3d#plot-individual-lines-in-2d-pseudosection","position":26},{"hierarchy":{"lvl1":"3D IP Forward Simulation","lvl3":"Plot Individual Lines in 2D Pseudosection","lvl2":"Plot IP Data in Pseudosection"},"content":"For conventional DC resistivity surveys, the electrodes are located along a set of survey lines. If we know which the survey line associated with each datum, we can parse the 3D survey into a set of 2D survey lines. Then we can plot individual pseudosections for each survey line. This was detailed in the \n\n3D Forward Simulation of DC Resistivity Data tutorial. Here, we have 6 survey lines, each of which has the same number of data. So assigning a line ID to each datum is easy. You may need to do something more sophisticated in other cases.\n\n# Define the line IDs for all data\nn_lines = len(end_locations_list)\nn_data_per_line = int(survey.nD / n_lines)\nlineID = np.hstack([(ii + 1) * np.ones(n_data_per_line) for ii in range(n_lines)])\n\nHere, we use the \n\nconvert​_survey​_3d​_to​_2d​_lines to generate the list of 2D surveys.\n\nsurvey_2d_list, index_list = convert_survey_3d_to_2d_lines(\n    survey, lineID, data_type=\"apparent_chargeability\", output_indexing=True\n)\n\nNext, we create list of 2D apparent chargeabilities.\n\ndobs_2d_list = []\napparent_chargeability_2d = []\nfor ind in index_list:\n    dobs_2d_list.append(dpred_ip[ind])\n    apparent_chargeability_2d.append(dpred_ip[ind])\n\nNow we can use the \n\nplot​_2d​_pseudosection utility function to plot the pseudosection for the desired survey line.\n\nline_index = 0\n\nfig = plt.figure(figsize=(8, 2.75))\n\nax1 = fig.add_axes([0.1, 0.1, 0.7, 0.8])\ncax1 = fig.add_axes([0.82, 0.1, 0.025, 0.8])\nplot_pseudosection(\n    survey_2d_list[line_index],\n    apparent_chargeability_2d[line_index],\n    \"contourf\",\n    ax=ax1,\n    cax=cax1,\n    scale=\"linear\",\n    cbar_label=\"V/V\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.plasma},\n)\nax1.set_title(\"Apparent Chargeability (V/V)\")\n\nplt.show()\n\nOptional: Write data and topography\n\nif write_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_ip_3d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    # Add 10% Gaussian noise to each datum\n    rng = np.random.default_rng(seed=433)\n    std = 5e-3 * np.ones_like(dpred_ip)\n    noise = rng.normal(scale=std, size=len(dpred_ip))\n    dobs = dpred_ip + noise\n\n    # Create dictionary that stores line IDs\n    out_dict = {\"LINEID\": lineID}\n\n    # Create a survey with the original electrode locations\n    # and not the shifted ones\n    source_list = []\n    for ii in range(0, len(end_locations_list)):\n        source_list += generate_dcip_sources_line(\n            survey_type,\n            data_type,\n            dimension_type,\n            end_locations_list[ii],\n            topo_xyz,\n            num_rx_per_src,\n            station_separation,\n        )\n    survey_original = ip.survey.Survey(source_list)\n\n    # Write out data at their original electrode locations (not shifted)\n    data_obj = data.Data(survey_original, dobs=dobs, standard_deviation=std)\n\n    fname = dir_path + \"ip_data.xyz\"\n    write_dcip_xyz(\n        fname,\n        data_obj,\n        data_header=\"APP_CHG\",\n        uncertainties_header=\"UNCERT\",\n        out_dict=out_dict,\n    )\n\n    fname = dir_path + \"topo_xyz.txt\"\n    np.savetxt(fname, topo_xyz, fmt=\"%.4e\")","type":"content","url":"/fwd-ip-3d#plot-individual-lines-in-2d-pseudosection","position":27},{"hierarchy":{"lvl1":"2.5D IP Inversion"},"type":"lvl1","url":"/inv-ip-2d","position":0},{"hierarchy":{"lvl1":"2.5D IP Inversion"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: induced polarization, 2.5D inversion, sparse norm, tree mesh.\n\nSummary: Here we invert IP data to recover the subsurface chargeability distribution on a tree mesh. We demonstrate two inversion approaches for recovering a chargeability model:\n\nWeighted least-squares inversion\n\nIteratively re-weighted least-squares (IRLS) inversion\n\nAlmost all of the details of defining and carrying out weighted least-squares and iteratively weighted least squares inversion were covered in the \n\n2.5D DC Resistivity Inversion tutorial. And functionality specific to defining the IP forward simulation was covered in the \n\n2.5D IP Forward Simulation tutorial. As we will focus primarily on content specific to IP inversion, we strongly urge the reader to work through the aforementioned tutorials prior to working through this one.\n\nLearning Objectives:\n\nAssigning appropriate uncertainties to IP data\n\nDesigning a mesh for IP inversion\n\nObtaining a background conductivity/resistivity model for the IP inversion\n\nAnalyzing inversion results\n\n","type":"content","url":"/inv-ip-2d","position":1},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Import Modules"},"type":"lvl2","url":"/inv-ip-2d#import-modules","position":2},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to IP is imported from \n\nsimpeg​.electromagnetics​.static​.induced​_polarization.\nWe also import some useful utility functions from \n\nsimpeg.utils. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import induced_polarization as ip\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    plot_pseudosection,\n)\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import read_dcip2d_ubc\nfrom simpeg.utils import download, model_builder\nfrom simpeg import (\n    maps,\n    data_misfit,\n    regularization,\n    optimization,\n    inverse_problem,\n    inversion,\n    directives,\n)\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Basic Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import Normalize, LogNorm\nimport tarfile\n\nmpl.rcParams.update({\"font.size\": 14})  # default font size\ncmap = mpl.cm.RdYlBu_r  # default colormap\n\n","type":"content","url":"/inv-ip-2d#import-modules","position":3},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Load and Plot Tutorial Data"},"type":"lvl2","url":"/inv-ip-2d#load-and-plot-tutorial-data","position":4},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Load and Plot Tutorial Data"},"content":"For most geophysical inversion projects, a reasonable inversion result can be obtained so long as the practitioner has observed data, the survey geometry and topography. For this tutorial, the observed data and topography files are provided. Here, we download and import the observed data and topography into the SimPEG framework.\n\n# URL to download from repository assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/06-ip/inv_ip_2d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"topo_2d.txt\"\ndata_filename = dir_path + \"ip_data.obs\"\n\n","type":"content","url":"/inv-ip-2d#load-and-plot-tutorial-data","position":5},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Load the Topography","lvl2":"Load and Plot Tutorial Data"},"type":"lvl3","url":"/inv-ip-2d#load-the-topography","position":6},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Load the Topography","lvl2":"Load and Plot Tutorial Data"},"content":"True surface topography is defined as an (N, 3) \n\nnumpy.ndarray.\nFor the 2.5D problem geometry however, topography is an (N, 2) \n\nnumpy.ndarray, where the first coordinate represent along-line position and the second coordinate represents the vertical position. In this tutorial, we assume the topography and electrode locations are defined according to the 2.5D geometry.\n\n# Load 2D topography\ntopo_2d = np.loadtxt(str(topo_filename))\n\n# Plot 2D topography\nfig = plt.figure(figsize=(10, 2))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\nax.plot(topo_2d[:, 0], topo_2d[:, -1], color=\"b\", linewidth=1)\nax.set_xlim([topo_2d[:, 0].min(), topo_2d[:, 0].max()])\nax.set_xlabel(\"x (m)\", labelpad=5)\nax.set_ylabel(\"z (m)\", labelpad=5)\nax.grid(True)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=10)\nplt.show(fig)\n\n","type":"content","url":"/inv-ip-2d#load-the-topography","position":7},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Load the IP Data","lvl2":"Load and Plot Tutorial Data"},"type":"lvl3","url":"/inv-ip-2d#load-the-ip-data","position":8},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Load the IP Data","lvl2":"Load and Plot Tutorial Data"},"content":"\n\nOption A: DCIP2D formatted data\n\nFor this tutorial, the observed data are organized with a UBC-GIF DCIP2D formatted data file. We can use the \n\nread_dcip2d_ubc utility function to load data in this format. This function outputs a SimPEG \n\nData object. The data are apparent chargeabilities in V/V.\n\nip_data = read_dcip2d_ubc(data_filename, \"apparent_chargeability\", \"general\")\n\nOption B: Survey from ABMN electrode locations\n\nIf you have CSV-formatted data containing the ABMN electrode locations, you will need to:\n\nload the file into a \n\nnumpy.ndarray\n\nextract the data column and the A, B, M and N electrode locations\n\ntransform the electrode locations to the 2.5D geometry if necessary; i.e. (N, 2) \n\nnumpy.ndarray\n\nuse the \n\ngenerate​_survey​_from​_abmn​_locations to generate a \n\nsurvey object automatically.\n\nDefine a \n\nData object attached to the survey and observed data.\n\nE.g. for a file containing electrode locations already formatted for a 2.5D geometry:data_array = np.loadtxt(data_filename, skiprows=1)\n\ndobs = data_array[:, -1]\nA = data_array[:, 0:2]\nB = data_array[:, 2:4]\nM = data_array[:, 4:6]\nN = data_array[:, 6:8]\n\nsurvey = generate_survey_from_abmn_locations(\n    locations_a=A,\n    locations_b=B,\n    locations_m=M,\n    locations_n=M,\n    data_type='apparent_chargeability'\n)\n\ndc_data = data.Data(survey, dobs=dobs)\n\n","type":"content","url":"/inv-ip-2d#load-the-ip-data","position":9},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Plot IP Data in Pseudo-Section","lvl2":"Load and Plot Tutorial Data"},"type":"lvl3","url":"/inv-ip-2d#plot-ip-data-in-pseudo-section","position":10},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Plot IP Data in Pseudo-Section","lvl2":"Load and Plot Tutorial Data"},"content":"Here we use the \n\nplot_pseudosection utility function to represent the observed apparent chargeability data in pseudosection. In this case, the apparent chargeabilities are represented in V/V.\n\nIn the case of secondary voltage data, you would need to convert the values to apparent chargeabilities. This accomplished by normalizing the secondary IP voltages by the DC voltages.\n\n# Plot apparent conductivity using pseudo-section\nmpl.rcParams.update({\"font.size\": 12})\n\napparent_chargeability = ip_data.dobs\n\nfig = plt.figure(figsize=(12, 5))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    ip_data.survey,\n    apparent_chargeability,\n    \"contourf\",\n    ax=ax1,\n    scale=\"linear\",\n    cbar_label=\"V/V\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.plasma},\n)\nax1.set_title(\"Apparent Chargeability\")\nplt.show()\n\n","type":"content","url":"/inv-ip-2d#plot-ip-data-in-pseudo-section","position":11},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-ip-2d#assign-uncertainties","position":12},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor secondary voltage data, we generally apply a percent uncertainty and a very small floor uncertainty to all data. Differences in electrode spacing and subsurface conductivity result in secondary voltage IP data that span many orders of magnitude. A percent uncertainty ensures all data are fit equally. Depending on the quality of the data, we may choose a percent uncertainty between 2% - 10%. The floor uncertainty ensures stability when there are zero-crossings or erroneously small voltages.\n\nFor apparent chargeability data, we generally apply a floor uncertainty to all data. This is because apparent chargeability data is obtained by normalizing the secondary voltage defining the IP signature by the DC voltage. This effectively removes the influence of electrode spacing on the amplitude of the datum. Here, we apply a floor uncertainty of 5e-3 V/V to all data.\n\nip_data.standard_deviation = 5e-3 * np.ones_like(ip_data.dobs)\n\n","type":"content","url":"/inv-ip-2d#assign-uncertainties","position":13},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/inv-ip-2d#design-a-tree-mesh","position":14},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Design a (Tree) Mesh"},"content":"IP inversion is carried out on the same mesh that is used for DC resistivity inversion. Here, we reproduce the survey-based meshing approach that was used in the  \n\n2.5D Inversion of DC Resistivity Data tutorial. The best-practices for meshes design for DC/IP problems is provided in the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial.\n\nTutorial mesh: Here, a minimum cell width of 4 m (or 1/10 the minimum electrode spacing) is used within our survey region. The largest electrode spacing was 400 m, so a the padding was extended at least 1200 m from the survey region. Using the \n\nrefine_surface method, we refine the tree mesh where there is significant topography. And using the \n\nrefine_points methods, we refine based on electrodes locations. Visit the \n\ntree mesh API to see additional refinement methods.\n\ndh = 4  # base cell width\ndom_width_x = 3200.0  # domain width x\ndom_width_z = 2400.0  # domain width z\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh with top at z = 0 m\nhx = [(dh, nbcx)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hz], x0=\"CN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, topo_2d[:, -1].max()]\n\n# Mesh refinement based on topography\nmesh.refine_surface(\n    topo_2d,\n    padding_cells_by_level=[0, 0, 4, 4],\n    finalize=False,\n)\n\n# Extract unique electrode locations.\nunique_locations = ip_data.survey.unique_electrode_locations\n\n# Mesh refinement near electrodes.\nmesh.refine_points(\n    unique_locations, padding_cells_by_level=[8, 12, 6, 6], finalize=False\n)\n\nmesh.finalize()\n\n","type":"content","url":"/inv-ip-2d#design-a-tree-mesh","position":15},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/inv-ip-2d#define-the-active-cells","position":16},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Define the Active Cells"},"content":"Use the \n\nactive_from_xyz utility function to obtain the indices of the active mesh cells from topography (e.g. cells below surface).\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_2d)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/inv-ip-2d#define-the-active-cells","position":17},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/inv-ip-2d#project-electrodes-to-discretized-topography","position":18},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Project Electrodes to Discretized Topography"},"content":"Surface IP data will not be modeled accurately if the electrodes are modeled as living above or below the surface. It is especially problematic when electrodes are modeled as living in the air. Prior to inverting surface IP data, we must project the electrodes from their true elevation to the surface of the discretized topography. This is done using the \n\ndrape​_electrodes​_on​_topography method.\n\nip_data.survey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/inv-ip-2d#project-electrodes-to-discretized-topography","position":19},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Define the Background Conductivity/Resistivity"},"type":"lvl2","url":"/inv-ip-2d#define-the-background-conductivity-resistivity","position":20},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Define the Background Conductivity/Resistivity"},"content":"In order to invert IP data, we require the background conductivity/resistivity model. In practice, a conductivity/resistivity model is recovered by inverting DC resistivity data; see the \n\n2.5D Inversion of DC Resistivity Data tutorial. Since the conductivity/resistivity model greatly impacts the sensitivities for the IP problem, IP inversion is most successful when the recovered conductivity/resistivity model accurately characterizes the true subsurface distribution of electrical properties.\n\nFor the tutorial, we will demonstrate the importance of using an appropriate background conductivity model for IP inversion. For our weighted least-squares inversion approach, we use a halfspace as the background conductivity model. For the iteratively re-weighted least-squares inversion approach, we use the true subsurface conductivity model. In both cases, the model is defined on the active mesh cells, and we must use the \n\nsimpeg​.maps​.InjectActiveCells mapping to map from the model space to the conductivities on the entire mesh.\n\n# Define electrical conductivities in S/m\nair_conductivity = 1e-8\nbackground_conductivity = 1e-2\nconductor_conductivity = 1e-1\nresistor_conductivity = 1e-3\n\n# Define halfspace conductivity model\nhalfspace_conductivity_model = background_conductivity * np.ones(n_active)\n\n# Define true conductivit model\ntrue_conductivity_model = halfspace_conductivity_model.copy()\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-120.0, 40.0], 60.0, mesh.cell_centers[active_cells, :]\n)\ntrue_conductivity_model[ind_conductor] = conductor_conductivity\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[120.0, 72.0], 60.0, mesh.cell_centers[active_cells, :]\n)\ntrue_conductivity_model[ind_resistor] = resistor_conductivity\n\n# Mapping from conductivity model to conductivity on all cells\nconductivity_map = maps.InjectActiveCells(mesh, active_cells, air_conductivity)\n\n# Mapping to neglect air cells in plot\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nfig = plt.figure(figsize=(9, 4))\n\nnorm = LogNorm(vmin=1e-3, vmax=1e-1)\n\nax1 = fig.add_axes([0.14, 0.17, 0.68, 0.7])\nmesh.plot_image(\n    plotting_map * true_conductivity_model,\n    ax=ax1,\n    grid=False,\n    pcolor_opts={\"norm\": norm, \"cmap\": mpl.cm.RdYlBu_r},\n)\nax1.set_xlim(-500, 500)\nax1.set_ylim(-300, 200)\nax1.set_title(\"True Background Conductivity\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.84, 0.17, 0.03, 0.7])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.RdYlBu_r\n)\ncbar.set_label(r\"$\\sigma$ (S/m)\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/inv-ip-2d#define-the-background-conductivity-resistivity","position":21},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-ip-2d#weighted-least-squares-inversion","position":22},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, a weighted least-squares inversion approach is used to apparent chargeability data to recover an intrinsic chargeability model.\n\n","type":"content","url":"/inv-ip-2d#weighted-least-squares-inversion","position":23},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Mapping from the Model to the Mesh","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#mapping-from-the-model-to-the-mesh","position":24},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Mapping from the Model to the Mesh","lvl2":"Weighted Least-Squares Inversion"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For whatever model we choose, we must define a mapping from the set of model parameters (a \n\n1D numpy.ndarray) to the physical property values of all cells in the mesh. Mappings are created using the \n\nsimpeg.maps module.\n\nSimPEG uses a linearized formulation for simulating IP data; see \n\nSimulation2DCellCentered or \n\nSimulation2DNodal. In this formulation, any standard definition of the chargeability can be inverted. And the units of the recovered chargeability values is the same as the data units; e.g. intrinsic chargeability (V/V or mV/V) or integrated chargeability (ms). If you are inverting secondary voltages however, the chargeability model must represent intrinsic chargeabilities (0 \\leq \\eta \\leq 1) in V/V.\n\nIn this tutorial, the model parameters are the subsurface chargeabilities (0 \\leq \\eta \\leq 1) in V/V. We use the \n\nsimpeg​.maps​.InjectActiveCells map to project the active cell chargeabilities to the entire mesh.\n\nchargeability_map = maps.InjectActiveCells(mesh, active_cells, 0.0)\n\n","type":"content","url":"/inv-ip-2d#mapping-from-the-model-to-the-mesh","position":25},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Starting and Reference Models for IP Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#starting-and-reference-models-for-ip-inversion","position":26},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Starting and Reference Models for IP Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we would create starting and/or reference models for the IP inversion as well as the mapping from the model space to the active cells. Starting and reference models can be a constant background value or contain a-priori structures. Here, the starting model is the 1e-6 V/V. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration.\n\n# Create starting model from log-conductivity\nstarting_chargeability_model = 1e-6 * np.ones(n_active)\n\n# Zero reference conductivity model\nreference_chargeability_model = np.zeros_like(starting_chargeability_model)\n\n","type":"content","url":"/inv-ip-2d#starting-and-reference-models-for-ip-inversion","position":27},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-forward-simulation","position":28},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for 2.5D IP was discussed in the \n\n2.5D IP Forward Simulation tutorial. Here, we use the \n\nSimulation2DNodal simulation which solves for the electric potential on mesh nodes.\n\nSince we are using a background conductivity model, we use sigma to define the background conductivity on the entire mesh. Because the IP problem has been linearized, we store the sensitivities for the inversion using storeJ.\n\nsimulation_L2 = ip.Simulation2DNodal(\n    mesh,\n    survey=ip_data.survey,\n    sigma=conductivity_map * halfspace_conductivity_model,\n    etaMap=chargeability_map,\n    storeJ=True,\n)\n\n","type":"content","url":"/inv-ip-2d#define-the-forward-simulation","position":29},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-data-misfit","position":30},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(simulation=simulation_L2, data=ip_data)\n\n","type":"content","url":"/inv-ip-2d#define-the-data-misfit","position":31},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-regularization","position":32},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Regularization","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource. Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Length scales along x and y are used to balance the smallness and smoothness terms. Here, length scales of 5 are used to emphasize more smoothness in the recovered model. The reference model is only applied to the smallness term.\n\nBy default, the regularization acts on the model parameters; which in the case are the chargeabilities of the active cells. So we need to specify which cells are active in the regularization. And if we wanted to apply the regularization to a function of the model parameters, we would need to set an approprate mapping object using the mapping keyword argument.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    mesh,\n    active_cells=active_cells,\n    length_scale_x=5.0,\n    length_scale_y=5.0,\n    reference_model=reference_chargeability_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-ip-2d#define-the-regularization","position":33},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-optimization-algorithm","position":34},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Optimization Algorithm","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the \n\nProjectedGNCG class to solve the optimization problem using projected Gauss-Newton with conjugate gradietn solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches. Here, the lower property is set to 0 to ensure recovered chargeability values are positive.\n\nopt_L2 = optimization.ProjectedGNCG(\n    maxIter=40, lower=0.0, maxIterLS=20, maxIterCG=20, tolCG=1e-2\n)\n\n","type":"content","url":"/inv-ip-2d#define-the-optimization-algorithm","position":35},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-inverse-problem","position":36},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-ip-2d#define-the-inverse-problem","position":37},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#provide-inversion-directives","position":38},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Provide Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"content":"Directives represent operations that are applied while the inversion is running. Here, we apply common directives for weighted least-squares inversion of IP data and describe their roles. These are:\n\nUpdateSensitivityWeights: Apply sensitivity weighting to counteract the natural tendency of IP inversion to place materials near the electrodes. Since the IP problem has been linearized, we do not need to update the sensitivities and we set every_iteration=False. For IP inversion, we do not want to use the entire dynamic range of the sensitivities to generate our weighting. So we generally set threshold_value to a value betwewen 1e-4 and 1e-1.\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem to reduce the number of conjugate gradient iterations. We set update_every_iteration=False because the ideal preconditioner because the forward problem and regularization are not model-dependent.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta. In general, a coolingFactor between 1.5 and 2.5, and coolingRate of 2 or 3 works well for DC resistivity inversion. Cooling beta too quickly will result in portions of the model getting trapped in local minima. And we will not be finding the solution that minimizes the optimization problem if the cooling rate is too small.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nsensitivity_weights = directives.UpdateSensitivityWeights(\n    every_iteration=False, threshold_value=1e-2\n)\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=False)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=20)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=2)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [\n    sensitivity_weights,\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-ip-2d#provide-inversion-directives","position":39},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-and-run-the-inversion","position":40},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run the inversion\n# recovered_model_L2 = inv_L2.run(np.log(0.01) * np.ones(n_param))\nrecovered_chargeability_L2 = inv_L2.run(starting_chargeability_model)\n\n","type":"content","url":"/inv-ip-2d#define-and-run-the-inversion","position":41},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#plot-the-data-misfit","position":42},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Plot the Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"content":"This step is necessary for determining whether the recovered model accurately reproduces observed anomalies. Here, we plot the observed data, predicted data for the recovered model, and the data misfit. As we can see, the recovered model reproduces the observed data quite well. And the data misfit map indicates we are not overfitting certain electrodes relative to others. We applied a uniform floor uncertainty to all data. However, if the uncertainty on each datum is different, we may choose to plot the normalized data misfit; i.e. the misfit normalized by the uncertainties.\n\n# Predicted data from recovered model\ndpred = inv_prob_L2.dpred\ndobs = ip_data.dobs\nstd = ip_data.standard_deviation\n\n# Plot\nfig = plt.figure(figsize=(9, 11))\ndata_array = [np.abs(dobs), np.abs(dpred), (dobs - dpred)]\nplot_title = [\"Observed\", \"Predicted\", \"Data Misfit\"]\nplot_units = [\"V/V\", \"V/V\", \"V/V\"]\nscale = [\"linear\", \"linear\", \"lindear\"]\ncmap_list = [mpl.cm.plasma, mpl.cm.plasma, mpl.cm.RdYlBu_r]\n\nax1 = 3 * [None]\ncax1 = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.15, 0.72 - 0.33 * ii, 0.65, 0.21])\n    cax1[ii] = fig.add_axes([0.81, 0.72 - 0.33 * ii, 0.03, 0.21])\n    cplot[ii] = plot_pseudosection(\n        ip_data.survey,\n        data_array[ii],\n        \"contourf\",\n        ax=ax1[ii],\n        cax=cax1[ii],\n        scale=scale[ii],\n        cbar_label=plot_units[ii],\n        mask_topography=True,\n        contourf_opts={\"levels\": 25, \"cmap\": cmap_list[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n\nplt.show()\n\n","type":"content","url":"/inv-ip-2d#plot-the-data-misfit","position":43},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#plot-the-recovered-model","position":44},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Plot the Recovered Model","lvl2":"Weighted Least-Squares Inversion"},"content":"As we can see, the inversion recovers a smooth model. We recover a confined chargeable structure centered at (-160, 50). We also recover an extreme chargeable feature at depth at x < 0 m. Where sensitivity is low, we expect the inversion to default to the reference model values (i.e. zero) given the regularization we chose. As we will see, the second feature is an artifact of choosing an inappropriate background conductivity model\n\nfig = plt.figure(figsize=(9, 4))\n\nnorm = Normalize(vmin=0.0, vmax=0.2)\n\nax1 = fig.add_axes([0.14, 0.17, 0.68, 0.7])\nmesh.plot_image(\n    plotting_map * recovered_chargeability_L2,\n    normal=\"Y\",\n    ax=ax1,\n    grid=False,\n    pcolor_opts={\"norm\": norm, \"cmap\": mpl.cm.plasma},\n)\nax1.set_xlim(-500, 500)\nax1.set_ylim(-300, 200)\nax1.set_title(\"Recovered L2-Model (Halfspace Background Conductivity)\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\n\nax2 = fig.add_axes([0.84, 0.17, 0.03, 0.7])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.plasma\n)\ncbar.set_label(\"V/V\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/inv-ip-2d#plot-the-recovered-model","position":45},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-ip-2d#iteratively-re-weighted-least-squares-inversion","position":46},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we provide a step-by-step best-practices approach for IRLS inversion of apparent chargeability data on a tree mesh to recover a chargeability model. Many of the steps are the same as our previous approach. As a result, we will avoid repeating information whenever possible. It should be noted that once the IRLS inversion is complete, we can extract the least-squares model the is recovered prior to performing the IRLS step. This will be done to compare least-squares inversion results for poor and appropriate background conductivity models.\n\nBecause we are changing the background conductivity, the sensitivities used for the L2 inversion cannot be reused for the IRLS inversion. Here, we define the simulation that can be used for the IRLS inversion, where the true background conductivity is true.\n\nsimulation_irls = ip.Simulation2DNodal(\n    mesh,\n    survey=ip_data.survey,\n    sigma=conductivity_map * true_conductivity_model,\n    etaMap=chargeability_map,\n    storeJ=True,\n)\n\n","type":"content","url":"/inv-ip-2d#iteratively-re-weighted-least-squares-inversion","position":47},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-data-misfit-1","position":48},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndmis_irls = data_misfit.L2DataMisfit(simulation=simulation_irls, data=ip_data)\n\n","type":"content","url":"/inv-ip-2d#define-the-data-misfit-1","position":49},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-regularization-1","position":50},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the \n\nSparse regularization class to constrain the inversion result using an IRLS approach. Length scales along x and y are used to balance the smallness and smoothness terms. We use the same length scales that were used in the weighted least-squares inversion. Here, we apply a 0-norm on the smallness and a 2-norm on the smoothness.\n\nreg_irls = regularization.Sparse(\n    mesh,\n    active_cells=active_cells,\n    length_scale_x=5.0,\n    length_scale_y=5.0,\n    norms=[0, 2, 2],\n    reference_model=reference_chargeability_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-ip-2d#define-the-regularization-1","position":51},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Optimization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-optimization","position":52},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Optimization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nopt_irls = optimization.ProjectedGNCG(\n    maxIter=40, lower=0.0, maxIterLS=20, maxIterCG=20, tolCG=1e-2\n)\n\n","type":"content","url":"/inv-ip-2d#define-the-optimization","position":53},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-the-inverse-problem-1","position":54},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define the Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_prob_irls = inverse_problem.BaseInvProblem(dmis_irls, reg_irls, opt_irls)\n\n","type":"content","url":"/inv-ip-2d#define-the-inverse-problem-1","position":55},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#provide-inversion-directives-1","position":56},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Provide Inversion Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we create common directives for IRLS inversion of IP data and describe their roles. In additon to the \n\nUpdateSensitivityWeights, \n\nUpdatePreconditioner and \n\nBetaEstimate_ByEig  (described before), inversion with sparse-norms requires the \n\nUpdateIRLS directive. Note that every_iteration has been set to True for the Jacobi preconditioner. This is because the IRLS regularization is model-dependent.\n\nYou will notice that we don’t use the \n\nBetaSchedule and \n\nTargetMisfit directives. Here, the beta cooling schedule is set in the \n\nUpdateIRLS directive using the coolingFactor and coolingRate properties. The target misfit for the L2 portion of the IRLS approach is set with the chifact_start property.\n\nsensitivity_weights_irls = directives.UpdateSensitivityWeights(\n    every_iteration=False, threshold_value=1e-2\n)\nupdate_irls = directives.UpdateIRLS(\n    cooling_factor=2,\n    cooling_rate=2,\n    f_min_change=1e-4,\n    max_irls_iterations=30,\n    chifact_start=1.0,\n)\nstarting_beta_irls = directives.BetaEstimate_ByEig(beta0_ratio=20)\nupdate_jacobi_irls = directives.UpdatePreconditioner(update_every_iteration=True)\n\ndirectives_list_irls = [\n    update_irls,\n    sensitivity_weights_irls,\n    starting_beta_irls,\n    update_jacobi_irls,\n]\n\n","type":"content","url":"/inv-ip-2d#provide-inversion-directives-1","position":57},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-ip-2d#define-and-run-the-inversion-1","position":58},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_irls = inversion.BaseInversion(inv_prob_irls, directives_list_irls)\nrecovered_chargeability_irls = inv_irls.run(starting_chargeability_model)\n\n","type":"content","url":"/inv-ip-2d#define-and-run-the-inversion-1","position":59},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Plot True, L2 and IRLS Models"},"type":"lvl2","url":"/inv-ip-2d#plot-true-l2-and-irls-models","position":60},{"hierarchy":{"lvl1":"2.5D IP Inversion","lvl2":"Plot True, L2 and IRLS Models"},"content":"Here, we compare the models recovered from weighted least-squares and iteratively re-weighted least-squares inversion to the true model. As we will see, the L2-model extracted from the IRLS inversion is a great improvement over the L2-model we recovered via weighted least-squares inversion. And the only difference is the background conductivity model.\n\n# Recreate True Model on a Tensor Mesh\ntrue_background_chargeability = 0.0\ntrue_conductor_chargeability = 1e-1\n\ntrue_chargeability_model = true_background_chargeability * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-120.0, 40.0], 60.0, mesh.cell_centers[active_cells, :]\n)\ntrue_chargeability_model[ind_conductor] = true_conductor_chargeability\n\n# Extract the L2 Model from the IRLS Inversion\nrecovered_chargeability_L2_good = inv_prob_irls.l2model\n\nnorm = Normalize(vmin=0.0, vmax=0.1)\n\nfig = plt.figure(figsize=(9, 16))\nax1 = 4 * [None]\nax2 = 4 * [None]\ntitle_str = [\n    \"True chargeability Model\",\n    \"Recovered L2-Model (halfspace background)\",\n    \"Recovered L2-Model (true background)\",\n    \"Recovered IRLS-Model (true background)\",\n]\nplotting_model = [\n    true_chargeability_model,\n    recovered_chargeability_L2,\n    recovered_chargeability_L2_good,\n    recovered_chargeability_irls,\n]\n\nfor ii in range(0, 4):\n    ax1[ii] = fig.add_axes([0.14, 0.78 - 0.25 * ii, 0.68, 0.18])\n    mesh.plot_image(\n        plotting_map * plotting_model[ii],\n        ax=ax1[ii],\n        grid=False,\n        pcolor_opts={\"norm\": norm, \"cmap\": mpl.cm.plasma},\n    )\n    ax1[ii].set_xlim(-500, 500)\n    ax1[ii].set_ylim(-300, 200)\n    ax1[ii].set_title(title_str[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    ax1[ii].set_ylabel(\"z (m)\")\n\n    ax2[ii] = fig.add_axes([0.84, 0.78 - 0.25 * ii, 0.03, 0.18])\n    cbar = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm, orientation=\"vertical\", cmap=mpl.cm.plasma\n    )\n    cbar.set_label(\"V/V\", rotation=270, labelpad=15, size=12)\n\nplt.show()","type":"content","url":"/inv-ip-2d#plot-true-l2-and-irls-models","position":61},{"hierarchy":{"lvl1":"3D IP Inversion"},"type":"lvl1","url":"/inv-ip-3d","position":0},{"hierarchy":{"lvl1":"3D IP Inversion"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nMedium-weight notebook\n\nRequires moderate computational resources. Run-times may exceed several minutes and require up to 8 GB of available RAM.\n\nKeywords: induced polarization, 3D inversion, sparse norm, tree mesh.\n\nSummary: Here we invert apparent chargeability data to recover the subsurface chargeability distribution on a tree mesh. We demonstrate two inversion approaches for recovering a chargeability model:\n\nWeighted least-squares inversion\n\nIteratively re-weighted least-squares (IRLS) inversion\n\nAlmost all of the details of defining and carrying out weighted least-squares and iteratively weighted least squares inversion were covered in the \n\n3D DC Resistivity Inversion tutorial. And functionality specific to defining the IP forward simulation was covered in the \n\n3D IP Forward Simulation tutorial. As we will focus primarily on content specific to IP inversion, we strongly urge the reader to work through the aforementioned tutorials prior to working through this one.\n\nLearning Objectives:\n\nAssigning appropriate uncertainties to IP data\n\nDesigning a mesh for IP inversion\n\nObtaining a background conductivity/resistivity model for the IP inversion\n\nAnalyzing inversion results\n\n","type":"content","url":"/inv-ip-3d","position":1},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Import Modules"},"type":"lvl2","url":"/inv-ip-3d#import-modules","position":2},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Import Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to IP is imported from \n\nsimpeg​.electromagnetics​.static​.induced​_polarization.\nWe also import some useful utility functions from \n\nsimpeg.utils. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nfrom simpeg.electromagnetics.static import induced_polarization as ip\nfrom simpeg.electromagnetics.static.utils.static_utils import (\n    plot_pseudosection,\n    convert_survey_3d_to_2d_lines,\n)\nfrom simpeg.utils.io_utils.io_utils_electromagnetics import read_dcip_xyz\nfrom simpeg.utils import download, model_builder\nfrom simpeg import (\n    maps,\n    data_misfit,\n    regularization,\n    optimization,\n    inverse_problem,\n    inversion,\n    directives,\n)\n\ntry:\n    import plotly\n    from simpeg.electromagnetics.static.utils.static_utils import plot_3d_pseudosection\n    from IPython.core.display import display, HTML\n\n    has_plotly = True\nexcept ImportError:\n    has_plotly = False\n    pass\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\n\n# Basic Python functionality\nimport os\nimport tarfile\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm, Normalize\n\nmpl.rcParams.update({\"font.size\": 16})\n\n","type":"content","url":"/inv-ip-3d#import-modules","position":3},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Load and Plot Tutorial Data"},"type":"lvl2","url":"/inv-ip-3d#load-and-plot-tutorial-data","position":4},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Load and Plot Tutorial Data"},"content":"For most geophysical inversion projects, a reasonable inversion result can be obtained so long as the practitioner has observed data, the survey geometry and topography. For this tutorial, the observed data and topography files are provided. Here, we download and import the observed data and topography into the SimPEG framework.\n\n# URL to download from repository assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/06-ip/inv_ip_3d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"topo_xyz.txt\"\ndata_filename = dir_path + \"ip_data.xyz\"\n\n","type":"content","url":"/inv-ip-3d#load-and-plot-tutorial-data","position":5},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Load the Topography","lvl2":"Load and Plot Tutorial Data"},"type":"lvl3","url":"/inv-ip-3d#load-the-topography","position":6},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Load the Topography","lvl2":"Load and Plot Tutorial Data"},"content":"For most geophysical inversion projects, a reasonable inversion result can be obtained so long as the practitioner has observed data, the survey geometry and topography. For this tutorial, the observed data and topography files are provided. Here, we download and import the observed data and topography into the SimPEG framework.\n\ntopo_xyz = np.loadtxt(str(topo_filename))\n\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([-400, 400])\nax.scatter3D(topo_xyz[:, 0], topo_xyz[:, 1], topo_xyz[:, 2], s=0.25, c=\"b\")\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=45.0, azim=-125)\n\n","type":"content","url":"/inv-ip-3d#load-the-topography","position":7},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Load IP Data","lvl2":"Load and Plot Tutorial Data"},"type":"lvl3","url":"/inv-ip-3d#load-ip-data","position":8},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Load IP Data","lvl2":"Load and Plot Tutorial Data"},"content":"Option A: DCIP3D formatted data\n\nThe \n\nread_dcip3d_ubc utility function can be used to load DC/IP data stored in a UBC-GIF formatted file. This function outputs a SimPEG \n\nData object.\n\nOption B: Load XYZ formatted data\n\nFor this tutorial, the observed data are organized within an XYZ formatted file. We can use the \n\nread_dcip_xyz utility function to load data in this format. This function outputs a SimPEG \n\nData object. The data are apparent chargeabilities in V/V.\n\nThe dict_headers input argument can be used to import other data columns that are not required to define the SimPEG data object. In this case, we import a column that defines the survey line associated with each datum. We will use this to plot pseudosections for individual survey lines.\n\nip_data, out_dict = read_dcip_xyz(\n    data_filename,\n    \"apparent_chargeability\",\n    data_header=\"APP_CHG\",\n    uncertainties_header=\"UNCERT\",\n    is_surface_data=False,\n    dict_headers=[\"LINEID\"],\n)\n\n","type":"content","url":"/inv-ip-3d#load-ip-data","position":9},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot Observed Data in 3D Pseudosection","lvl2":"Load and Plot Tutorial Data"},"type":"lvl3","url":"/inv-ip-3d#plot-observed-data-in-3d-pseudosection","position":10},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot Observed Data in 3D Pseudosection","lvl2":"Load and Plot Tutorial Data"},"content":"Here we use the \n\nplot​_3d​_pseudosection utility function to represent the observed data in pseudosection. In this case, the apparent chargeabilities are represented in V/V.\n\nIn the case of secondary voltage data, you would need to convert the values to apparent chargeabilities. This accomplished by normalizing the secondary IP voltages by the DC voltages.\n\nif has_plotly:\n    fig = plot_3d_pseudosection(\n        ip_data.survey,\n        ip_data.dobs,\n        scale=\"linear\",\n        units=\"V/V\",\n        vlim=[0, np.max(ip_data.dobs)],\n        marker_opts={\"colorscale\": \"plasma\"},\n    )\n\n    fig.update_layout(\n        title_text=\"Apparent Chargeability\",\n        title_x=0.5,\n        title_font_size=24,\n        width=650,\n        height=500,\n        scene_camera=dict(\n            center=dict(x=0, y=0, z=-0.4), eye=dict(x=1.5, y=-1.5, z=1.8)\n        ),\n    )\n\n    #     plotly.io.show(fig)\n    html_str = plotly.io.to_html(fig)\n    display(HTML(html_str))\n\nelse:\n    print(\"INSTALL 'PLOTLY' TO VISUALIZE 3D PSEUDOSECTIONS\")\n\n","type":"content","url":"/inv-ip-3d#plot-observed-data-in-3d-pseudosection","position":11},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot Observed Data in 2D Pseudosection","lvl2":"Load and Plot Tutorial Data"},"type":"lvl3","url":"/inv-ip-3d#plot-observed-data-in-2d-pseudosection","position":12},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot Observed Data in 2D Pseudosection","lvl2":"Load and Plot Tutorial Data"},"content":"As demonstrated in the \n\n3D Forward Simulation tutorial, we can parse the 3D survey into a set of 2D survey lines if we know which survey line is associated with each datum. Then we can plot individual pseudosections for each survey line. We use the \n\nconvert​_survey​_3d​_to​_2d​_lines to generate the list of 2D surveys. And we use the \n\nplot​_2d​_pseudosection utility function to plot the pseudosection for the desired survey line.\n\n# Extract line IDs and make sure they are integers\nlineID = np.array(out_dict[\"LINEID\"], dtype=int)\n\n# Create list of 2D surveys\nsurvey_2d_list, index_list = convert_survey_3d_to_2d_lines(\n    ip_data.survey, lineID, data_type=\"apparent_chargeability\", output_indexing=True\n)\n\ndobs_2d_list = []\napparent_chargeabilities_2d = []\nfor ind in index_list:\n    dobs_2d_list.append(ip_data.dobs[ind])\n    apparent_chargeabilities_2d.append(ip_data.dobs[ind])\n\nline_index = 0\n\nfig = plt.figure(figsize=(8, 2.75))\nax1 = fig.add_axes([0.1, 0.15, 0.75, 0.78])\nplot_pseudosection(\n    survey_2d_list[line_index],\n    dobs=apparent_chargeabilities_2d[line_index],\n    plot_type=\"contourf\",\n    ax=ax1,\n    scale=\"linear\",\n    cbar_label=\"V/V\",\n    mask_topography=True,\n    contourf_opts={\"levels\": 20, \"cmap\": mpl.cm.plasma},\n)\nax1.set_title(\"Apparent Chargeability\")\nplt.show()\n\n","type":"content","url":"/inv-ip-3d#plot-observed-data-in-2d-pseudosection","position":13},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-ip-3d#assign-uncertainties","position":14},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor secondary voltage data, we generally apply a percent uncertainty and a very small floor uncertainty to all data. Differences in electrode spacing and subsurface conductivity result in secondary voltage IP data that span many orders of magnitude. A percent uncertainty ensures all data are fit equally. Depending on the quality of the data, we may choose a percent uncertainty between 2% - 10%. The floor uncertainty ensures stability when there are zero-crossings or erroneously small voltages.\n\nFor apparent chargeability data, we generally apply a floor uncertainty to all data. This is because apparent chargeability data is obtained by normalizing the secondary voltage defining the IP signature by the DC voltage. This effectively removes the influence of electrode spacing on the amplitude of the datum. Here, we apply a floor uncertainty of 5e-3 V/V to all data.\n\nip_data.standard_deviation = 5e-3 * np.ones_like(ip_data.dobs)\n\n","type":"content","url":"/inv-ip-3d#assign-uncertainties","position":15},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/inv-ip-3d#design-a-tree-mesh","position":16},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Design a (Tree) Mesh"},"content":"IP inversion is carried out on the same mesh that is used for DC resistivity inversion. Here, we reproduce the survey-based meshing approach that was used in the  \n\n3D Inversion of DC Resistivity Data tutorial. The best-practices for meshes design for DC/IP problems is provided in the \n\n2.5D Forward Simulation of DC Resistivity Data tutorial. The same rules for defining appropriate meshes for 2.5D simulations and inversion apply to 3D simulations and inversion.\n\nTutorial mesh: Here, a minimum cell width of 25 m (or 1/4 the minimum electrode spacing) is used within our survey region. The largest electrode spacing was 1000 m, so a the padding was extended at least 3000 m from the survey region. Using the \n\nrefine_surface method, we refine the tree mesh where there is significant topography. And using the \n\nrefine_points methods, we refine based on electrodes locations. Visit the \n\ntree mesh API to see additional refinement methods.\n\n# Defining domain size and minimum cell size\ndh = 25.0  # base cell width\ndom_width_x = 8000.0  # domain width x\ndom_width_y = 8000.0  # domain width y\ndom_width_z = 4000.0  # domain width z\n\n# Number of base mesh cells in each direction. Must be a power of 2\nnbcx = 2 ** int(np.round(np.log(dom_width_x / dh) / np.log(2.0)))  # num. base cells x\nnbcy = 2 ** int(np.round(np.log(dom_width_y / dh) / np.log(2.0)))  # num. base cells y\nnbcz = 2 ** int(np.round(np.log(dom_width_z / dh) / np.log(2.0)))  # num. base cells z\n\n# Define the base mesh\nhx = [(dh, nbcx)]\nhy = [(dh, nbcy)]\nhz = [(dh, nbcz)]\nmesh = TreeMesh([hx, hy, hz], x0=\"CCN\", diagonal_balance=True)\n\n# Shift top to maximum topography\nmesh.origin = mesh.origin + np.r_[0.0, 0.0, topo_xyz[:, -1].max()]\n\n# Mesh refinement based on surface topography\nk = np.sqrt(np.sum(topo_xyz[:, 0:2] ** 2, axis=1)) < 1200\nmesh.refine_surface(topo_xyz[k, :], padding_cells_by_level=[0, 4, 4], finalize=False)\n\n# Extract unique electrode locations.\nunique_locations = ip_data.survey.unique_electrode_locations\n\n# Mesh refinement near electrodes.\nmesh.refine_points(unique_locations, padding_cells_by_level=[6, 6, 4], finalize=False)\n\n# Finalize the mesh\nmesh.finalize()\n\n","type":"content","url":"/inv-ip-3d#design-a-tree-mesh","position":17},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/inv-ip-3d#define-the-active-cells","position":18},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Active Cells"},"content":"Use the \n\nactive_from_xyz utility function to obtain the indices of the active mesh cells from topography (e.g. cells below surface).\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n# number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/inv-ip-3d#define-the-active-cells","position":19},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Project Electrodes to Discretized Topography"},"type":"lvl2","url":"/inv-ip-3d#project-electrodes-to-discretized-topography","position":20},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Project Electrodes to Discretized Topography"},"content":"Surface IP data will not be modeled accurately if the electrodes are modeled as living above or below the surface. It is especially problematic when electrodes are modeled as living in the air. Prior to inverting surface IP data, we must project the electrodes from their true elevation to the surface of the discretized topography. This is done using the \n\ndrape​_electrodes​_on​_topography method.\n\nip_data.survey.drape_electrodes_on_topography(mesh, active_cells, option=\"top\")\n\n","type":"content","url":"/inv-ip-3d#project-electrodes-to-discretized-topography","position":21},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Background Conductivity/Resistivity"},"type":"lvl2","url":"/inv-ip-3d#define-the-background-conductivity-resistivity","position":22},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Background Conductivity/Resistivity"},"content":"In order to invert IP data, we require the background conductivity/resistivity defined on the entire mesh. In practice, a conductivity/resistivity model is recovered via inverting DC resistivity data; see the \n\n3D Inversion of DC Resistivity Data tutorial. Since the conductivity/resistivity model greatly impacts the sensitivities for the IP problem, IP inversion is most successful when the recovered conductivity/resistivity model accurately characterizes the true subsurface distribution of electrical properties. For the tutorial, the true subsurface conductivity is used as the background conductivity for the IP inversion.\n\n# Define conductivity model in S/m\nair_conductivity = 1e-8\nbackground_conductivity = 1e-2\nconductor_conductivity = 1e-1\nresistor_conductivity = 1e-3\n\n# Define conductivity model\nconductivity_model = background_conductivity * np.ones(n_active)\n\nind_conductor = model_builder.get_indices_sphere(\n    np.r_[-300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_conductor] = conductor_conductivity\n\nind_resistor = model_builder.get_indices_sphere(\n    np.r_[300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\nconductivity_model[ind_resistor] = resistor_conductivity\n\n# Define the mapping from the model to conductivity for all mesh cells.\nconductivity_map = maps.InjectActiveCells(mesh, active_cells, air_conductivity)\n\n# Mapping to ignore inactive cells in plot\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nfig = plt.figure(figsize=(10, 4.5))\n\nlog_norm = LogNorm(vmin=1e-3, vmax=0.1)\n\nax1 = fig.add_axes([0.15, 0.15, 0.68, 0.75])\nmesh.plot_slice(\n    plotting_map * conductivity_model,\n    ax=ax1,\n    normal=\"Y\",\n    ind=int(len(mesh.h[1]) / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.RdYlBu_r, \"norm\": log_norm},\n)\nax1.set_title(\"True Background Conductivity\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\nax1.set_xlim([-1500, 1500])\nax1.set_ylim([topo_xyz[:, -1].max() - 1500, topo_xyz[:, -1].max()])\n\nax2 = fig.add_axes([0.84, 0.15, 0.03, 0.75])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, cmap=mpl.cm.RdYlBu_r, norm=log_norm, orientation=\"vertical\"\n)\ncbar.set_label(\"Conductivity [S/m]\", rotation=270, labelpad=15, size=12)\n\n","type":"content","url":"/inv-ip-3d#define-the-background-conductivity-resistivity","position":23},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Mapping from the Model to the Mesh"},"type":"lvl2","url":"/inv-ip-3d#mapping-from-the-model-to-the-mesh","position":24},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Mapping from the Model to the Mesh"},"content":"In SimPEG, the term ‘model’ is not synonymous with the physical property values defined on the mesh. For whatever model we choose, we must define a mapping from the set of model parameters (a \n\n1D numpy.ndarray) to the physical property values of all cells in the mesh. Mappings are created using the \n\nsimpeg.maps module.\n\nSimPEG uses a linearized formulation for simulating IP data; see \n\nSimulation2DCellCentered or \n\nSimulation2DNodal. In this formulation, any standard definition of the chargeability can be inverted. And the units of the recovered chargeability values is the same as the data units; e.g. intrinsic chargeability (V/V or mV/V) or integrated chargeability (ms). If you are inverting secondary voltages however, the chargeability model must represent intrinsic chargeabilities (0 \\leq \\eta \\leq 1) in V/V.\n\nIn this tutorial, the model parameters are the subsurface chargeabilities (0 \\leq \\eta \\leq 1) in V/V. We use the \n\nsimpeg​.maps​.InjectActiveCells map to project the active cell chargeabilities to the entire mesh.\n\n# Model parameters to all cells\nchargeability_map = maps.InjectActiveCells(mesh, active_cells, 0.0)\n\n","type":"content","url":"/inv-ip-3d#mapping-from-the-model-to-the-mesh","position":25},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Starting/Reference Model for IP Inversion"},"type":"lvl2","url":"/inv-ip-3d#starting-reference-model-for-ip-inversion","position":26},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Starting/Reference Model for IP Inversion"},"content":"Here, we would create starting and/or reference models for the IP inversion as well as the mapping from the model space to the active cells. Starting and reference models can be a constant background value or contain a-priori structures. Here, the starting model is the 1e-6 V/V. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration.\n\n# Create starting model from log-conductivity\nstarting_chargeability_model = 1e-4 * np.ones(n_active)\n\n# Zero reference conductivity model\nreference_chargeability_model = np.zeros_like(starting_chargeability_model)\n\n","type":"content","url":"/inv-ip-3d#starting-reference-model-for-ip-inversion","position":27},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Forward Simulation"},"type":"lvl2","url":"/inv-ip-3d#define-the-forward-simulation","position":28},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Forward Simulation"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for 3D IP was discussed in the \n\n3D IP Forward Simulation tutorial. Here, we use the \n\nSimulation3DNodal simulation which solves for the electric potential on mesh nodes.\n\nSince we are using a background conductivity model, we use sigma to define the background conductivity on the entire mesh. Because the IP problem has been linearized, we store the sensitivities for the inversion using storeJ.\n\nsimulation_L2 = ip.Simulation3DNodal(\n    mesh,\n    survey=ip_data.survey,\n    sigma=conductivity_map * conductivity_model,\n    etaMap=chargeability_map,\n    storeJ=True,\n)\n\n","type":"content","url":"/inv-ip-3d#define-the-forward-simulation","position":29},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Data Misfit"},"type":"lvl2","url":"/inv-ip-3d#define-the-data-misfit","position":30},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Data Misfit"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(simulation=simulation_L2, data=ip_data)\n\n","type":"content","url":"/inv-ip-3d#define-the-data-misfit","position":31},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Regularization"},"type":"lvl2","url":"/inv-ip-3d#define-the-regularization","position":32},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Regularization"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource. Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Length scales along x, y and z are used to balance the smallness and smoothness terms. And the reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros.\n\nBy default, the regularization acts on the model parameters; which in the case are the log-conductivities of the active cells. So we need to specify which cells are active in the regularization. And if we wanted to apply the regularization to a function of the model parameters, we would need to set an approprate mapping object using the mapping keyword argument.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    mesh,\n    active_cells=active_cells,\n    length_scale_x=10.0,\n    length_scale_y=10.0,\n    length_scale_z=10.0,\n    reference_model=reference_chargeability_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-ip-3d#define-the-regularization","position":33},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Optimization Algorithm"},"type":"lvl2","url":"/inv-ip-3d#define-the-optimization-algorithm","position":34},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Optimization Algorithm"},"content":"Here, we use the \n\nProjectedGNCG class to solve the optimization problem using projected Gauss-Newton with conjugate gradietn solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches. Here, the lower property is set to 0 to ensure recovered chargeability values are positive.\n\nopt_L2 = optimization.ProjectedGNCG(\n    maxIter=40, lower=0.0, maxIterLS=20, maxIterCG=20, tolCG=1e-2\n)\n\n","type":"content","url":"/inv-ip-3d#define-the-optimization-algorithm","position":35},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Inverse Problem"},"type":"lvl2","url":"/inv-ip-3d#define-the-inverse-problem","position":36},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define the Inverse Problem"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-ip-3d#define-the-inverse-problem","position":37},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Provide Inversion Directives","lvl2":"Define the Inverse Problem"},"type":"lvl3","url":"/inv-ip-3d#provide-inversion-directives","position":38},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Provide Inversion Directives","lvl2":"Define the Inverse Problem"},"content":"Directives represent operations that are applied while the inversion is running. Here, we apply common directives for weighted least-squares inversion of IP data and describe their roles. These are:\n\nUpdateSensitivityWeights: Apply sensitivity weighting to counteract the natural tendency of IP inversion to place materials near the electrodes. Since the IP problem has been linearized, we do not need to update the sensitivities and we set every_iteration=False. For IP inversion, we do not want to use the entire dynamic range of the sensitivities to generate our weighting. So we generally set threshold_value to a value betwewen 1e-4 and 1e-1.\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem to reduce the number of conjugate gradient iterations. We set update_every_iteration=False because the ideal preconditioner because the forward problem and regularization are not model-dependent.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta. In general, a coolingFactor between 1.5 and 2.5, and coolingRate of 2 or 3 works well for DC resistivity inversion. Cooling beta too quickly will result in portions of the model getting trapped in local minima. And we will not be finding the solution that minimizes the optimization problem if the cooling rate is too small.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nsensitivity_weights = directives.UpdateSensitivityWeights(\n    every_iteration=False, threshold_value=1e-2\n)\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=1000)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=2)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [\n    sensitivity_weights,\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-ip-3d#provide-inversion-directives","position":39},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define and Run the Inversion"},"type":"lvl2","url":"/inv-ip-3d#define-and-run-the-inversion","position":40},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Define and Run the Inversion"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run the inversion\nrecovered_chargeability_L2 = inv_L2.run(starting_chargeability_model)\n\n","type":"content","url":"/inv-ip-3d#define-and-run-the-inversion","position":41},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Analyze Inversion Outputs"},"type":"lvl2","url":"/inv-ip-3d#analyze-inversion-outputs","position":42},{"hierarchy":{"lvl1":"3D IP Inversion","lvl2":"Analyze Inversion Outputs"},"content":"\n\n","type":"content","url":"/inv-ip-3d#analyze-inversion-outputs","position":43},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot Normalized Data Misfit in 3D Pseudosection","lvl2":"Analyze Inversion Outputs"},"type":"lvl3","url":"/inv-ip-3d#plot-normalized-data-misfit-in-3d-pseudosection","position":44},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot Normalized Data Misfit in 3D Pseudosection","lvl2":"Analyze Inversion Outputs"},"content":"To see how well the recovered model reproduces the observed data, it is a good idea to compare the predicted and observed data.\nHere, we plot the normalized data misfit to determine whether the observed data are fit evenly. Correlated signatures in the normalized data misfits indicate we are overfitting/underfitting certain data. And that we must modify our uncertainties and re-run the inversion.\n\n# Predicted data from recovered model\ndpred_ip = inv_prob_L2.dpred\n\n# Compute the normalized data misfit\nip_normalized_misfit = (ip_data.dobs - dpred_ip) / ip_data.standard_deviation\n\nif has_plotly:\n    fig = plot_3d_pseudosection(\n        ip_data.survey,\n        ip_normalized_misfit,\n        scale=\"linear\",\n        units=\"\",\n        vlim=[-2.5, 2.5],\n        marker_opts={\"colorscale\": \"RdYlBu\"},\n    )\n\n    fig.update_layout(\n        title_text=\"Normalized Data Misfit\",\n        title_x=0.5,\n        title_font_size=24,\n        width=650,\n        height=500,\n        scene_camera=dict(\n            center=dict(x=0, y=0, z=-0.4), eye=dict(x=1.5, y=-1.5, z=1.8)\n        ),\n    )\n\n    #     plotly.io.show(fig)\n    html_str = plotly.io.to_html(fig)\n    display(HTML(html_str))\n\nelse:\n    print(\"INSTALL 'PLOTLY' TO VISUALIZE 3D PSEUDOSECTIONS\")\n\n","type":"content","url":"/inv-ip-3d#plot-normalized-data-misfit-in-3d-pseudosection","position":45},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot 2D Pseudsections for Individual Survey Lines","lvl2":"Analyze Inversion Outputs"},"type":"lvl3","url":"/inv-ip-3d#plot-2d-pseudsections-for-individual-survey-lines","position":46},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot 2D Pseudsections for Individual Survey Lines","lvl2":"Analyze Inversion Outputs"},"content":"For large datasets comprised of many survey lines, interpretation can be challenging if we plot every datum. Here, we plot the observed data, predicted data and data misfit for a specified survey line.\n\n# Data associated with the line index provided\nline_index = 0\nk = lineID == line_index + 1\ndata_array = [\n    np.abs(ip_data.dobs[k]),\n    np.abs(dpred_ip[k]),\n    ip_data.dobs[k] - dpred_ip[k],\n]\n\n# Plot 2D pseudosections (observed, predicted, normalized misfit)\nfig = plt.figure(figsize=(9, 11))\nplot_title = [\"Observed\", \"Predicted\", \"Misfit\"]\nplot_units = [\"V/V\", \"V/V\", \"V/V\"]\nscale = [\"linear\", \"linear\", \"linear\"]\ncmap_list = [mpl.cm.plasma, mpl.cm.plasma, mpl.cm.RdYlBu]\n\nax1 = 3 * [None]\ncax1 = 3 * [None]\ncbar = 3 * [None]\ncplot = 3 * [None]\n\nfor ii in range(0, 3):\n    ax1[ii] = fig.add_axes([0.15, 0.72 - 0.33 * ii, 0.65, 0.21])\n    cax1[ii] = fig.add_axes([0.81, 0.72 - 0.33 * ii, 0.03, 0.21])\n    cplot[ii] = plot_pseudosection(\n        survey_2d_list[line_index],\n        data_array[ii],\n        \"contourf\",\n        ax=ax1[ii],\n        cax=cax1[ii],\n        scale=scale[ii],\n        cbar_label=plot_units[ii],\n        mask_topography=True,\n        contourf_opts={\"levels\": 25, \"cmap\": cmap_list[ii]},\n    )\n    ax1[ii].set_title(plot_title[ii])\n\nplt.show()\n\n","type":"content","url":"/inv-ip-3d#plot-2d-pseudsections-for-individual-survey-lines","position":47},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot True and Recovered Chargeability Models","lvl2":"Analyze Inversion Outputs"},"type":"lvl3","url":"/inv-ip-3d#plot-true-and-recovered-chargeability-models","position":48},{"hierarchy":{"lvl1":"3D IP Inversion","lvl3":"Plot True and Recovered Chargeability Models","lvl2":"Analyze Inversion Outputs"},"content":"\n\n# Define intrinsic chargeability model (V/V)\nair_value = 0.0\nbackground_value = 1e-6\nchargeable_value = 0.1\n\n# Define true chargeability model\ntrue_chargeability_model = background_value * np.ones(n_active)\n\nind_chargeable = model_builder.get_indices_sphere(\n    np.r_[-300.0, 0.0, 100.0], 165.0, mesh.cell_centers[active_cells, :]\n)\n\ntrue_chargeability_model[ind_chargeable] = chargeable_value\n\nfig = plt.figure(figsize=(9, 9))\nax1 = 2 * [None]\nax2 = 2 * [None]\ncbar = 2 * [None]\nnorm = 2 * [None]\ntitle_str = [\n    \"True Chargeability Model\",\n    \"Recovered Chargeability (L2)\",\n]\n\nfor ii, m in enumerate([true_chargeability_model, recovered_chargeability_L2]):\n    norm[ii] = Normalize(vmin=0.0, vmax=np.max(m))\n\n    ax1[ii] = fig.add_axes([0.14, 0.6 - 0.5 * ii, 0.68, 0.35])\n\n    mesh.plot_slice(\n        plotting_map * m,\n        ax=ax1[ii],\n        normal=\"Y\",\n        ind=int(len(mesh.h[1]) / 2),\n        grid=False,\n        pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm[ii]},\n    )\n    ax1[ii].set_title(title_str[ii])\n    ax1[ii].set_xlabel(\"x (m)\")\n    ax1[ii].set_ylabel(\"z (m)\")\n    ax1[ii].set_xlim([-1500, 1500])\n    ax1[ii].set_ylim([topo_xyz[:, -1].max() - 1500, topo_xyz[:, -1].max()])\n\n    ax2[ii] = fig.add_axes([0.84, 0.6 - 0.5 * ii, 0.03, 0.35])\n    cbar[ii] = mpl.colorbar.ColorbarBase(\n        ax2[ii], norm=norm[ii], orientation=\"vertical\", cmap=mpl.cm.plasma\n    )\n    cbar[ii].set_label(r\"$\\sigma$ (S/m)\", rotation=270, labelpad=15, size=12)","type":"content","url":"/inv-ip-3d#plot-true-and-recovered-chargeability-models","position":49},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding"},"type":"lvl1","url":"/fwd-fdem-1d","position":0},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: FDEM, forward simulation, 1D sounding, inductive source, wires mapping.\n\nSummary: In this tutorial, we present the fundamentals of simulating FDEM data in SimPEG. We use the module \n\nsimpeg​.electromagnetics​.static​.frequency​_domain to simulate FDEM data for a 1D sounding. The \n\nSimulation1DLayered class is used to solve the problem via a semi-analytic Hankel transform solution. Note that almost all of what is learned here can be applied to simulating 3D FDEM data.\n\nLearning Objectives:\n\nThe fundamentals of simulating FDEM data with SimPEG.\n\nUnderstanding the way in which FDEM surveys are created in SimPEG, which includes:\n\nDefining receivers\n\nDefining controlled sources\n\nOrganizing sources and receivers into a survey object\n\nDefining the Earth’s electrical properties in terms of conductivity OR resistivity.\n\nThe ways in which we can define 1D layered Earth models.\n\nDefining appropriate mappings from the model parameters to parameters defining the simulation.\n\n","type":"content","url":"/fwd-fdem-1d","position":1},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Importing Modules"},"type":"lvl2","url":"/fwd-fdem-1d#importing-modules","position":2},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Importing Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to FDEM is imported from \n\nsimpeg​.electromagnetics​.frequency​_domain.\nWe also import some useful utility functions from \n\nsimpeg.utils.\n\n# SimPEG functionality\nimport simpeg.electromagnetics.frequency_domain as fdem\nfrom simpeg import maps\nfrom simpeg.utils import plot_1d_layer_model\n\n# Common Python functionality\nimport os\nimport numpy as np\nfrom scipy.constants import mu_0\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.rcParams.update({\"font.size\": 14})\n\nwrite_output = False  # Optional\n\n","type":"content","url":"/fwd-fdem-1d#importing-modules","position":3},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Survey"},"type":"lvl2","url":"/fwd-fdem-1d#defining-the-survey","position":4},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Survey"},"content":"FDEM surveys within SimPEG require the user to create and connect three types of objects:\n\nreceivers: There are a multitude of FDEM receiver classes within SimPEG, each of which is used to simulate data corresponding to a different field measurement; e.g. \n\nPointMagneticField and \n\nPointElectricField. The properties for each FDEM receiver object generally include: the orientation of the field being measured (x, y, z, other), the component (real or imaginary), the data type (field or ppm), and one or more associated observation locations.\n\nsources: There are a multitude of FDEM source classes within SimPEG, each of which corresponds to a different geometry; e.g. \n\nMagDipole, \n\nCircularLoop and \n\nLineCurrent. Source classes generally require the user to define the operating frequency (in Hz), its location and its geometry.\n\nsurvey: the object which stores and organizes all of the sources and receivers.\n\nFor a full description of all source and receiver classes, please visit API documentation for \n\nsimpeg​.electromagnetics​.frequency​_domain.\n\nTopography: When generating the survey for a 1D forward simulation, sources and receivers must be located above the Earth’s surface. By default, the Earth’s surface is at z = 0 m when defining the 1D simulation. So for 1D FDEM problems, it is easiest to define the z-locations of all sources and receivers as flight heights.\n\nFor this tutorial, the survey consists of a vertical magnetic dipole source operating at 5 frequencies. Real and imaginary data in ppm are measured by a vertically-oriented receiver coil offset 10 m from the source.\n\n# Source properties\nfrequencies = np.r_[382, 1822, 7970, 35920, 130100]  # frequencies in Hz\nsource_location = np.array([0.0, 0.0, 30.0])  # (3, ) numpy.array_like\nsource_orientation = \"z\"  # \"x\", \"y\" or \"z\"\nmoment = 1.0  # dipole moment in Am^2\n\n# Receiver properties\nreceiver_locations = np.array([10.0, 0.0, 30.0])  # or (N, 3) numpy.ndarray\nreceiver_orientation = \"z\"  # \"x\", \"y\" or \"z\"\ndata_type = \"ppm\"  # \"secondary\", \"total\" or \"ppm\"\n\nThe most general way to generate FDEM surveys is to loop over all sources. A new source object must be created whenever the source location, geometry and/or operating frequencies differs. For each source, we define and assign the associated receivers. A different receiver object must be created whenever geometry or data type differs. However, identical data being collected at a multitude of observation locations can be defined using a single receiver object.\n\nFor this tutorial, the location and geometry of the source remains the same, so we only need to loop over the operating frequencies. And since we have both real and imaginary data, we will need to define two receivers for each source. More complicated survey geometries are used in the \n\n3D Forward Simulation of FDEM Data on Cylindrical Mesh for a Galvanic Source and \n\nForward Simulation of 3D Airborne FDEM Data on a Tree Mesh tutorials.\n\nsource_list = []  # create empty list for source objects\n\n# loop over all sources\nfor freq in frequencies:\n    # Define receivers that measure real and imaginary component\n    # magnetic field data in ppm.\n    receiver_list = []\n    receiver_list.append(\n        fdem.receivers.PointMagneticFieldSecondary(\n            receiver_locations,\n            orientation=receiver_orientation,\n            data_type=data_type,\n            component=\"real\",\n        )\n    )\n    receiver_list.append(\n        fdem.receivers.PointMagneticFieldSecondary(\n            receiver_locations,\n            orientation=receiver_orientation,\n            data_type=data_type,\n            component=\"imag\",\n        )\n    )\n\n    # Define a magnetic dipole source at each frequency\n    source_list.append(\n        fdem.sources.MagDipole(\n            receiver_list=receiver_list,\n            frequency=freq,\n            location=source_location,\n            orientation=source_orientation,\n            moment=moment,\n        )\n    )\n\n# Define the FDEM survey\nsurvey = fdem.survey.Survey(source_list)\n\n","type":"content","url":"/fwd-fdem-1d#defining-the-survey","position":5},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining a 1D Layered Earth and the Model"},"type":"lvl2","url":"/fwd-fdem-1d#defining-a-1d-layered-earth-and-the-model","position":6},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining a 1D Layered Earth and the Model"},"content":"In SimPEG, a 1D layered Earth is defined by the set of layer thicknesses and the physical properties for each layer. Thicknesses and physical property values are defined from the top layer down. If we have N layers, we define N physical property values and N-1 layer thicknesses. The lowest layer is assumed to extend to infinity. In the case of a halfspace, the layer thicknesses would be an empty array.\n\n# Define layer thicknesses (m)\nlayer_thicknesses = np.array([20.0, 40.0])\n\n# Define layer conductivities (S/m)\nlayer_conductivities = np.r_[0.1, 1.0, 0.1]\n\n# Define layer susceptibilities (SI)\nlayer_susceptibilities = np.r_[0.0, 4.0, 0.0]\n\nfig = plt.figure(figsize=(8, 5))\n\nax1 = fig.add_axes([0.1, 0.1, 0.3, 0.8])\nax1 = plot_1d_layer_model(layer_thicknesses, layer_conductivities, scale=\"log\", ax=ax1)\nax1.grid(which=\"both\")\nax1.set_xlabel(r\"Conductivity ($S/m$)\")\n\nax2 = fig.add_axes([0.6, 0.1, 0.3, 0.8])\nax2 = plot_1d_layer_model(\n    layer_thicknesses, layer_susceptibilities, scale=\"linear\", ax=ax2\n)\nax2.grid(which=\"both\")\nax2.set_xlim([-0.05, 1.1 * np.max(layer_susceptibilities)])\nax2.set_xlabel(r\"Susceptibility ($SI$)\")\nplt.show()\n\n","type":"content","url":"/fwd-fdem-1d#defining-a-1d-layered-earth-and-the-model","position":7},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Models and Mappings for 1D Simulations"},"type":"lvl2","url":"/fwd-fdem-1d#models-and-mappings-for-1d-simulations","position":8},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Models and Mappings for 1D Simulations"},"content":"In SimPEG, the term ‘model’ is not necessarily synonymous with a set of physical property values. For example, the model may be defined as the logarithms of the physical property values, or be the parameters defining a layered Earth geometry. Models in SimPEG are 1D \n\nnumpy.ndarray whose lengths are equal to the number of model parameters. For 1D FDEM simulations, we can characterize the Earth’s electric properties according to electrical conductivity or electrical resistivity.\n\nClasses within the simpeg.maps module are used to define the mapping that connects the model to the parameters required to run the 1D FDEM simulation; i.e. layer conductivities/resistivities, magnetic permeabilities and/or layer thicknesses. In this tutorial, we demonstrate several types of mappings and models that may be used for 1D FDEM simulation.\n\nCASE 1: Conductivity model. The easiest case is when the layer thicknesses are fixed in the simulation, and by default we assume the Earth is non-permeable. Here, we define the model as the layer conductivities. And the mapping from the model to the conductivities is defined using the \n\nsimpeg​.maps​.IdentityMap class.\n\nCASE 2: Log-resistivity model with fixed magnetic permeability. Here, the model parameters are the log-resistivity values for the layers. In addition to fixing the layer thicknesses in the simulation, we need to fix the magnetic permeabilities. In this case, we need a mapping that converts log-resistivities to resistivities. To do this, we use the \n\nsimpeg.maps.ExpMap class.\n\nCASE 3: Log-conductivity, magnetic permeability and layer thicknesses. In this case, the model defines log-conductivities, magnetic permeabilities and layer thicknesses. We therefore need mappings that extract each parameter type from the model, and a converts to the appropriate quantity. For this, we require the \n\nsimpeg.maps.Wires mapping and \n\nsimpeg.maps.ExpMap mapping classes. Note that successive mappings can be chained together using the * operator.\n\n","type":"content","url":"/fwd-fdem-1d#models-and-mappings-for-1d-simulations","position":9},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Models","lvl2":"Models and Mappings for 1D Simulations"},"type":"lvl3","url":"/fwd-fdem-1d#define-the-models","position":10},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Models","lvl2":"Models and Mappings for 1D Simulations"},"content":"\n\nn_layers = len(layer_conductivities)\n\n# CASE 1: CONDUCTIVITY MODEL\nconductivity_model = layer_conductivities.copy()\n\n# CASE 2: LOG-RESISTIVITY MODEL\nlog_resistivity_model = np.log(1 / layer_conductivities)\n\n# CASE 3: LOG-CONDUCTIVITY, MAGNETIC PERMEABILITY AND LAYER THICKNESSES\nparametric_model = np.r_[\n    np.log(layer_conductivities), mu_0 * (1 + layer_susceptibilities), layer_thicknesses\n]\n\n","type":"content","url":"/fwd-fdem-1d#define-the-models","position":11},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Mappings","lvl2":"Models and Mappings for 1D Simulations"},"type":"lvl3","url":"/fwd-fdem-1d#define-the-mappings","position":12},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Mappings","lvl2":"Models and Mappings for 1D Simulations"},"content":"\n\n# CASE 1: CONDUCTIVITY MODEL\nconductivity_map = maps.IdentityMap()\n\n# CASE 2: LOG-RESISTIVITY MODEL\nlog_resistivity_map = maps.ExpMap()\n\n# CASE 3: LOG-CONDUCTIVITY, MAGNETIC PERMEABILITY AND LAYER THICKNEESSES\n# Note the ordering in which you defined the model parameters and the\n# order in which you defined the wire mappings matters!!!\nwire_map = maps.Wires(\n    (\"log_conductivity\", n_layers),\n    (\"permeability\", n_layers),\n    (\"thicknesses\", n_layers - 1),\n)\nlog_conductivity_map = maps.ExpMap() * wire_map.log_conductivity\npermeability_map = wire_map.permeability\nthicknesses_map = wire_map.thicknesses\n\n","type":"content","url":"/fwd-fdem-1d#define-the-mappings","position":13},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Forward Simulation"},"type":"lvl2","url":"/fwd-fdem-1d#defining-the-forward-simulation","position":14},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Forward Simulation"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class. Here, we use the \n\nSimulation1DLayered which simulates the data according to a 1D Hankel transform solution. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe layer thicknesses\n\nthe layer conductivities/resistivities\n\nthe layer magnetic permeabilities (optional)\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object. Since the parameters defining the model in each case are different, we must define a separate simulation object for each case.\n\nCASE 1: Conductivity model. Here, the model parameters are the layer conductivities. sigmaMap is used to define the mapping from the model to the layer conductivities. thicknessess is used to set the layer thicknesses as static parameters of the simulation. By default, the simulation assumes the Earth is non-permeable and we do not have to set this property.\n\nsimulation_conductivity = fdem.Simulation1DLayered(\n    survey=survey,\n    thicknesses=layer_thicknesses,\n    sigmaMap=conductivity_map,\n)\n\nCASE 2: Log-resistivity model with fixed magnetic permeability. Here, the model parameters are the log-resistivities of the layers. Because we are now working with electric resistivity, rhoMap is used to define the mapping for the Earth’s electrical properties; i.e. model parameters to layer resistivities. thicknessess is used to set the layer thicknesses as static parameters in the simulation. Likewise, mu is used to set the magnetic permeabilities.\n\nsimulation_log_resistivity = fdem.Simulation1DLayered(\n    survey=survey,\n    thicknesses=layer_thicknesses,\n    rhoMap=log_resistivity_map,\n)\n\nCASE 3: Log-conductivity, magnetic permeability and layer thicknesses. Here, sigmaMap is used to define the mapping from the model to the layer conductivities. muMap is used to define the mapping from the model to the layer permeabilities. And thicknessesMap is used to define the mapping from the model to the layer thicknesses.\n\nsimulation_parametric = fdem.Simulation1DLayered(\n    survey=survey,\n    thicknessesMap=thicknesses_map,\n    sigmaMap=log_conductivity_map,\n    muMap=permeability_map,\n)\n\n","type":"content","url":"/fwd-fdem-1d#defining-the-forward-simulation","position":15},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Predict 1D FDEM Data"},"type":"lvl2","url":"/fwd-fdem-1d#predict-1d-fdem-data","position":16},{"hierarchy":{"lvl1":"1D Forward Simulation of Frequency Domain EM Data for a Single Sounding","lvl2":"Predict 1D FDEM Data"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. Note that despite the difference in how we defined the model, the data predicted for CASE 1 and CASE 2 should be the same. And for CASE 3, we expect to see differences given the layer is now significantly permeable.\n\nFor surveys consisting of multiple sources, multiple receivers per source and multiple observation locations per receiver, the predicted data vector is organized:\n\nby source\n\nby receiver, then\n\nby observation location\n\ndpred_conductivity = simulation_conductivity.dpred(conductivity_model)\ndpred_log_resistivity = simulation_log_resistivity.dpred(log_resistivity_model)\ndpred_parametric = simulation_parametric.dpred(parametric_model)\n\nylim = [np.min(dpred_parametric), 1.1 * np.max(dpred_parametric)]\n\nfig = plt.figure(figsize=(10, 5))\n\nax1 = fig.add_axes([0.1, 0.1, 0.4, 0.85])\nax1.semilogx(frequencies, dpred_conductivity[0::2], \"b-o\", lw=3, ms=10)\nax1.semilogx(frequencies, dpred_log_resistivity[0::2], \"r--s\", lw=3, ms=6)\nax1.semilogx(frequencies, dpred_parametric[0::2], \"g:d\", lw=3, ms=6)\nax1.grid()\nax1.set_ylim(ylim)\nax1.set_xlabel(\"Frequency (Hz)\")\nax1.set_ylabel(\"Hs/Hp (ppm)\")\nax1.set_title(\"Real Component\")\nax1.legend([\"Conductivity model\", \"Log-resistivity model\", \"Parametric model\"])\n\nax2 = fig.add_axes([0.55, 0.1, 0.4, 0.85])\nax2.semilogx(frequencies, dpred_conductivity[1::2], \"b-o\", lw=3, ms=10)\nax2.semilogx(frequencies, dpred_log_resistivity[1::2], \"r--s\", lw=3, ms=6)\nax2.semilogx(frequencies, dpred_parametric[1::2], \"g:d\", lw=3, ms=6)\nax2.set_ylim(ylim)\nax2.grid()\nax2.set_xlabel(\"Frequency (Hz)\")\nax2.set_yticklabels(\"\")\nax2.set_title(\"Imaginary Component\")\nax2.legend([\"Conductivity model\", \"Log-resistivity model\", \"Parametric model\"])\n\nplt.show()\n\nOptional: Export data.\n\nif write_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_fdem_1d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    rng = np.random.default_rng(seed=222)\n    noise = rng.normal(\n        scale=0.05 * np.abs(dpred_conductivity),\n        size=len(dpred_conductivity),\n    )\n    dpred_out = dpred_conductivity + noise\n\n    fname = dir_path + \"em1dfm_data.txt\"\n    np.savetxt(\n        fname,\n        np.c_[frequencies, dpred_out[0::2], dpred_out[1::2]],\n        fmt=\"%.4e\",\n        header=\"FREQUENCY HZ_REAL HZ_IMAG\",\n    )","type":"content","url":"/fwd-fdem-1d#predict-1d-fdem-data","position":17},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding"},"type":"lvl1","url":"/inv-fdem-1d","position":0},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: frequency-domain EM, 1D sounding, inversion, parametric, sparse norm, wires mapping\n\nSummary: Here, we invert secondary magnetic field data for a single 1D FDEM sounding. We demonstrate 3 approaches for inverting the data:\n\nA weighted least-squares inversion where the number of layers and their thicknesses are fixed\n\nAn iteratively re-weighted least-squares (IRLS) inversion to recover sparse and/or blocky structures\n\nA parametric inversion where we invert for the layer thicknesses and electrical properties assuming a 3-layered Earth\n\nThe weighted least-squares approach is a great introduction to geophysical inversion with SimPEG. One drawback however, is that it recovers smooth structures which may not be representative of the true model. To recover sparse and/or blocky 1D structures, we demonstrate an iteratively re-weighted least-squares approach. If the number of layers is known, but their depths, thicknesses and conductivities are not, we can use a parametric inversion approach.\n\nLearning Objectives: Because this tutorial focusses primarily on inversion-related functionality, we urge the reader to become familiar with functionality explained in the \n\n1D Forward Simulation of Frequency-Domain EM Data for a Single Sounding tutorial before working through this one. For this tutorial, we focus on:\n\nHow to carry out 1D geophysical inversion with SimPEG.\n\nHow to assign appropriate uncertainties to FDEM data.\n\nChoosing suitable parameters for the inversion.\n\nSpecifying directives that are applied throughout the inversion.\n\nWeighted least-squares, sparse-norm and parametric inversion.\n\nAnalyzing inversion outputs.\n\n","type":"content","url":"/inv-fdem-1d","position":1},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Importing Modules"},"type":"lvl2","url":"/inv-fdem-1d#importing-modules","position":2},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Importing Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to the forward simulation of 1D frequency domain EM data are imported from the \n\nsimpeg​.electromagnetics​.frequency​_domain module. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nimport simpeg.electromagnetics.frequency_domain as fdem\nfrom simpeg.utils import plot_1d_layer_model, download, mkvc\nfrom simpeg import (\n    maps,\n    data,\n    data_misfit,\n    regularization,\n    optimization,\n    inverse_problem,\n    inversion,\n    directives,\n)\n\n# discretize functionality\nfrom discretize import TensorMesh\n\n# Basic Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport tarfile\n\nmpl.rcParams.update({\"font.size\": 14})\n\n","type":"content","url":"/inv-fdem-1d#importing-modules","position":3},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Download and Extract the Tutorial Data"},"type":"lvl2","url":"/inv-fdem-1d#download-and-extract-the-tutorial-data","position":4},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Download and Extract the Tutorial Data"},"content":"For this tutorial, the frequencies and observed data for 1D sounding are stored within a tar-file. Here, we download and extract the data file.\n\n# URL to assets\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/07-fdem/inv_fdem_1d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ndata_filename = dir_path + \"em1dfm_data.txt\"\n\n","type":"content","url":"/inv-fdem-1d#download-and-extract-the-tutorial-data","position":5},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Load and Plot the Data"},"type":"lvl2","url":"/inv-fdem-1d#load-and-plot-the-data","position":6},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Load and Plot the Data"},"content":"Here we load and plot the 1D sounding data. In this case, we have the\nsecondary field response in ppm for a set of frequencies. The columns of the data file are: frequency (Hz), real component (ppm) and imaginary component (ppm).\n\n# Load data\ndobs = np.loadtxt(str(data_filename), skiprows=1)\n\n# Extract frequency and observed data columns\nfrequencies = dobs[:, 0]\ndobs = mkvc(dobs[:, 1:].T)\n\n# Plot data\nfig, ax = plt.subplots(1, 1, figsize=(5, 5))\nax.loglog(frequencies, np.abs(dobs[0::2]), \"k-o\", lw=2)\nax.loglog(frequencies, np.abs(dobs[1::2]), \"k:o\", lw=2)\nax.grid(which=\"both\")\nax.set_xlabel(\"Frequency (Hz)\")\nax.set_ylabel(\"|Hs/Hp| (ppm)\")\nax.set_title(\"Sounding Data\")\nax.legend([\"Real\", \"Imaginary\"])\nplt.show()\n\n","type":"content","url":"/inv-fdem-1d#load-and-plot-the-data","position":7},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Survey"},"type":"lvl2","url":"/inv-fdem-1d#defining-the-survey","position":8},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Survey"},"content":"Here, we define the survey geometry. For a comprehensive description of constructing FDEM surveys in SimPEG, see the \n\n1D Forward Simulation of Frequency-Domain EM Data for a Single Sounding tutorial.\n\nHere, the survey consisted of a vertical magnetic dipole source located 30 m above the surface. The receiver measured the vertical component of the secondary field at a 10 m offset from the source in ppm.\n\nsource_location = np.array([0.0, 0.0, 30.0])\nsource_orientation = \"z\"\nmoment = 1.0\n\nreceiver_location = np.array([10.0, 0.0, 30.0])\nreceiver_orientation = \"z\"\ndata_type = \"ppm\"\n\n# Receiver list\nreceiver_list = []\nreceiver_list.append(\n    fdem.receivers.PointMagneticFieldSecondary(\n        receiver_location,\n        orientation=receiver_orientation,\n        data_type=data_type,\n        component=\"real\",\n    )\n)\nreceiver_list.append(\n    fdem.receivers.PointMagneticFieldSecondary(\n        receiver_location,\n        orientation=receiver_orientation,\n        data_type=data_type,\n        component=\"imag\",\n    )\n)\n\n# Define source list\nsource_list = []\nfor freq in frequencies:\n    source_list.append(\n        fdem.sources.MagDipole(\n            receiver_list=receiver_list,\n            frequency=freq,\n            location=source_location,\n            orientation=source_orientation,\n            moment=moment,\n        )\n    )\n\n# Survey\nsurvey = fdem.survey.Survey(source_list)\n\n","type":"content","url":"/inv-fdem-1d#defining-the-survey","position":9},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-fdem-1d#assign-uncertainties","position":10},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor secondary field and ppm data: In this case, we generally apply a percent uncertainty. Depending on many factors, a percent uncertainty between 5% and 20% may be applied. For systems where multiple field directions are measured for the same source, we may not want to apply a uniform percent uncertainty to all data. Doing so may cause the inversion to overfit weaker signals. In this case, the uncertainty may be a percent of the amplitude of the secondary field. If the data contain very small values, a small floor value should be added to ensure stability of the inversion.\n\nFor total field data: In this case, the real component contains both the primary and secondary fields, whereas the imaginary component contains only secondary fields. Because the primary field is orders of magnitude larger than the secondary field, applying a simple percent uncertainty to the real component data may result in us underfitting the real component of the EM response. Ideally, we would have defined the survey to perfectly simulate the primary fields, and assign uncertainties based on the secondary fields.\n\n# 5% of the absolute value\nuncertainties = 0.05 * np.abs(dobs) * np.ones(np.shape(dobs))\n\n","type":"content","url":"/inv-fdem-1d#assign-uncertainties","position":11},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Data"},"type":"lvl2","url":"/inv-fdem-1d#defining-the-data","position":12},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Defining the Data"},"content":"The SimPEG \n\nData class is required for inversion and connects the observed data, uncertainties and survey geometry.\n\ndata_object = data.Data(survey, dobs=dobs, noise_floor=uncertainties)\n\n","type":"content","url":"/inv-fdem-1d#defining-the-data","position":13},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-fdem-1d#weighted-least-squares-inversion","position":14},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the weighted least-squares inversion approach to recover the log-conductivities on a 1D layered Earth. We impose no a-priori information about the number of layers (geological units) or their thicknesses. Instead, we define a large number of layers with exponentially increasing thicknesses. And the depth, thickness and electrical properties of the Earth are inferred from the recovered model.\n\n","type":"content","url":"/inv-fdem-1d#weighted-least-squares-inversion","position":15},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Defining a 1D Layered Earth","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#defining-a-1d-layered-earth","position":16},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Defining a 1D Layered Earth","lvl2":"Weighted Least-Squares Inversion"},"content":"Let us assume we have a reasonable estimate of the regional conductivity within our area of interest. For the highest frequency and the estimated conductivity, we compute the minimum skin depth:d_{min} \\approx 500 \\sqrt{\\dfrac{1}{\\sigma \\, f_{max}}}\n\nThe minimum layer thickness is some fraction of the minimum skin depth. Next, we use the minimum frequency and the estimated conductivity to compute the maximum skin depth:d_{max} \\approx 500 \\sqrt{\\dfrac{1}{\\sigma \\, f_{min}}}\n\nStarting from our minimum layer thickness, we continue to add layers with exponentially increasing thicknesses. We do so until the layers extend to some multiple of the maximum skin depth.\n\n# estimated host conductivity (S/m)\nestimated_conductivity = 0.1\n\n# minimum skin depth\nd_min = 500.0 / np.sqrt(estimated_conductivity * frequencies.max())\nprint(\"MINIMUM SKIN DEPTH: {} m\".format(d_min))\n\n# maximum skin depth\nd_max = 500.0 / np.sqrt(estimated_conductivity * frequencies.min())\nprint(\"MAXIMUM SKIN DEPTH: {} m\".format(d_max))\n\ndepth_min = 0.5  # top layer thickness\ndepth_max = 200.0  # depth to lowest layer\ngeometric_factor = 1.1  # rate of thickness increase\n\n# Increase subsequent layer thicknesses by the geometric factors until\n# it reaches the maximum layer depth.\nlayer_thicknesses = [depth_min]\nwhile np.sum(layer_thicknesses) < depth_max:\n    layer_thicknesses.append(geometric_factor * layer_thicknesses[-1])\n\nn_layers = len(layer_thicknesses) + 1  # Number of layers\n\n","type":"content","url":"/inv-fdem-1d#defining-a-1d-layered-earth","position":17},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Model and Mapping to Layer Conductivities","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#model-and-mapping-to-layer-conductivities","position":18},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Model and Mapping to Layer Conductivities","lvl2":"Weighted Least-Squares Inversion"},"content":"Recall from the \n\n1D Forward Simulation of Frequency-Domain EM Data for a Single Sounding tutorial that the ‘model’ is not necessarily synonymous with physical property values. And that we need to define a mapping from the model to the set of input parameters required by the forward simulation. When inverting to recover electrical conductivities (or resistivities), it is best to use the log-value, as electrical conductivities of rocks span many order of magnitude.\n\nHere, the model defines the log-conductivity values for a defined set of subsurface layers. And we use the \n\nsimpeg.maps.ExpMap to map from the model parameters to the conductivity values required by the forward simulation.\n\nlog_conductivity_map = maps.ExpMap(nP=n_layers)\n\n","type":"content","url":"/inv-fdem-1d#model-and-mapping-to-layer-conductivities","position":19},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#starting-reference-models","position":20},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"content":"The starting model defines a reasonable starting point for the inversion. Because electromagnetic problems are non-linear, your choice in starting model does have an impact on the recovered model. For DC resistivity inversion, we generally choose our starting model based on apparent resistivities. For the tutorial example, the apparent resistivities were near 1000 \\Omega m. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration.\n\nThe reference model is used to include a-priori information. The impact of the reference model on the inversion will be discussed in another tutorial. The reference model for basic inversion approaches is either zero or equal to the starting model.\n\nNotice that the length of the starting and reference models is equal to the number of model parameters!!!\n\n# Starting model is log-conductivity values (S/m)\nstarting_conductivity_model = np.log(1e-1 * np.ones(n_layers))\n\n# Reference model is also log-resistivity values (S/m)\nreference_conductivity_model = starting_conductivity_model.copy()\n\n","type":"content","url":"/inv-fdem-1d#starting-reference-models","position":21},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#define-the-forward-simulation","position":22},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for 1D DC resistivity was discussed in the \n\n1D Forward Simulation of Frequency-Domain EM Data for a Single Sounding tutorial. Here, we use the \n\nSimulation1DLayered which simulates the data according to a 1D Hankel transform solution.\n\nThe layer thicknesses are a static property of the simulation, and we set them using the thicknessess keyword argument. Since our model consists of log-conductivities, we use sigmaMap to set the mapping from the model to the layer conductivities.\n\nsimulation_L2 = fdem.Simulation1DLayered(\n    survey=survey, thicknesses=layer_thicknesses, sigmaMap=log_conductivity_map\n)\n\n","type":"content","url":"/inv-fdem-1d#define-the-forward-simulation","position":23},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#data-misfit","position":24},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(simulation=simulation_L2, data=data_object)\n\n","type":"content","url":"/inv-fdem-1d#data-misfit","position":25},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Regularization","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#regularization","position":26},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Regularization","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource.\n\nTo define the regularization within SimPEG, we must define a 1D \n\ntensor mesh. Meshes are designed using the \n\ndiscretize package. Whereas layer thicknesses and our model are defined from our top-layer down, tensor meshes are defined from the bottom up. So to define a 1D tensor mesh for the regularization, we:\n\nadd an extra layer to the end of our thicknesses so that the number of cells in the 1D mesh equals the number of model parameters\n\nreverse the order so that the model parameters in the regularization match up with the appropriate cell\n\ndefine the tensor mesh from the cell widths\n\n# Define 1D cell widths\nh = np.r_[layer_thicknesses, layer_thicknesses[-1]]\nh = np.flipud(h)\n\n# Create regularization mesh\nregularization_mesh = TensorMesh([h], \"N\")\nprint(regularization_mesh)\n\nBy default, the regularization acts on the model parameters. In this case, the model parameters are the log-resistivities, not the electric resistivities!!! Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Here, length scale along x are used to balance the smallness and smoothness terms; yes, x is smoothness along the vertical direction. And the reference model is only applied to the smallness term. If we wanted to apply the regularization to a function of the model parameters, we would need to set an approprate mapping object using the mapping keyword argument.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    regularization_mesh,\n    length_scale_x=10.0,\n    reference_model=reference_conductivity_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-fdem-1d#regularization","position":27},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Optimization","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#optimization","position":28},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Optimization","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the \n\nInexactGaussNewton class to solve the optimization problem using the inexact Gauss Newton with conjugate gradient solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches.\n\nopt_L2 = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-fdem-1d#optimization","position":29},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#inverse-problem","position":30},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-fdem-1d#inverse-problem","position":31},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#inversion-directives","position":32},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of directives in the inversion, please visit this online resource. Here, we apply common directives for weighted least-squares inversion of gravity data and describe their roles. These are:\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem to reduce the number of conjugate gradient iterations. We set update_every_iteration=True because the ideal preconditioner is model-dependent.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta. In general, a coolingFactor between 1.5 and 2.5, and coolingRate of 3 works well for FDEM inversion. Cooling beta too quickly will result in portions of the model getting trapped in local minima. And we will not be finding the solution that minimizes the optimization problem if the cooling rate is too small.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=5)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=3)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [update_jacobi, starting_beta, beta_schedule, target_misfit]\n\n","type":"content","url":"/inv-fdem-1d#inversion-directives","position":33},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#define-and-run-the-inversion","position":34},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run the inversion\nrecovered_model_L2 = inv_L2.run(starting_conductivity_model)\n\n","type":"content","url":"/inv-fdem-1d#define-and-run-the-inversion","position":35},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Inversion Outputs"},"type":"lvl2","url":"/inv-fdem-1d#inversion-outputs","position":36},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Inversion Outputs"},"content":"\n\n","type":"content","url":"/inv-fdem-1d#inversion-outputs","position":37},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit","lvl2":"Inversion Outputs"},"type":"lvl3","url":"/inv-fdem-1d#data-misfit-1","position":38},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit","lvl2":"Inversion Outputs"},"content":"\n\ndpred_L2 = simulation_L2.dpred(recovered_model_L2)\n\nfig = plt.figure(figsize=(10, 5))\nax = [fig.add_axes([0.1 + ii * 0.5, 0.1, 0.37, 0.85]) for ii in range(2)]\nfor ii in range(2):\n    ax[ii].loglog(frequencies, np.abs(dobs[ii::2]), \"k-o\", lw=2)\n    ax[ii].loglog(frequencies, np.abs(dpred_L2[ii::2]), \"b-o\", lw=2)\n    ax[ii].grid(which=\"both\")\n    ax[ii].set_xlabel(\"Frequency (Hz)\")\n    ax[ii].set_ylabel(\"|Hs/Hp| (ppm)\")\n    ax[ii].legend([\"Observed\", \"L2 Inversion\"])\n    if ii == 1:\n        ax[ii].set_ylabel(\"\")\n\nax[0].set_title(\"Real Component\")\nax[1].set_title(\"Imaginary Component\")\nplt.show()\n\n","type":"content","url":"/inv-fdem-1d#data-misfit-1","position":39},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Recovered Model","lvl2":"Inversion Outputs"},"type":"lvl3","url":"/inv-fdem-1d#recovered-model","position":40},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Recovered Model","lvl2":"Inversion Outputs"},"content":"\n\n# true conductivities and layer thicknesses\ntrue_conductivities = np.array([0.1, 1.0, 0.1])\ntrue_layers = np.r_[20.0, 40.0, 160.0]\n\n# Plot true model and recovered model\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_conductivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nx_min, x_max = true_conductivities.min(), true_conductivities.max()\nax1.set_xlim(0.9 * x_min, 1.5 * x_max)\nax1.legend([\"True Model\", \"L2-Model\"])\nplt.show()\n\n","type":"content","url":"/inv-fdem-1d#recovered-model","position":41},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-fdem-1d#iteratively-re-weighted-least-squares-inversion","position":42},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the iteratively reweighted least-squares (IRLS) inversion approach to recover sparse and/or blocky models on the set layers.\n\n","type":"content","url":"/inv-fdem-1d#iteratively-re-weighted-least-squares-inversion","position":43},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#define-the-forward-simulation-1","position":44},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nsimulation_irls = fdem.simulation_1d.Simulation1DLayered(\n    survey=survey,\n    sigmaMap=log_conductivity_map,\n    thicknesses=layer_thicknesses,\n)\n\n","type":"content","url":"/inv-fdem-1d#define-the-forward-simulation-1","position":45},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#define-the-data-misfit","position":46},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndmis_irls = data_misfit.L2DataMisfit(simulation=simulation_irls, data=data_object)\n\n","type":"content","url":"/inv-fdem-1d#define-the-data-misfit","position":47},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#regularization-1","position":48},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the \n\nSparse regularization class to constrain the inversion result using an IRLS approach. Here, the scaling constants that balance the smallness and smoothness terms are set directly. Equal emphasis on smallness and smoothness is generally applied by using the inverse square of the smallest cell dimension. The reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros. Here, we apply a 1-norm to the smallness term and a 1-norm to first-order smoothness along the x (vertical direction).\n\nreg_irls = regularization.Sparse(\n    regularization_mesh,\n    alpha_s=0.01,\n    alpha_x=1,\n    reference_model_in_smooth=False,\n    norms=[1.0, 1.0],\n)\n\n","type":"content","url":"/inv-fdem-1d#regularization-1","position":49},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Optimization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#optimization-1","position":50},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Optimization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nopt_irls = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=30, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-fdem-1d#optimization-1","position":51},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#inverse-problem-1","position":52},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_prob_irls = inverse_problem.BaseInvProblem(dmis_irls, reg_irls, opt_irls)\n\n","type":"content","url":"/inv-fdem-1d#inverse-problem-1","position":53},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#directives","position":54},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we create common directives for IRLS inversion of total magnetic intensity data and describe their roles. In additon to the \n\nUpdateSensitivityWeights, \n\nUpdatePreconditioner and \n\nBetaEstimate_ByEig  (described before), inversion with sparse-norms requires the \n\nUpdateIRLS directive.\n\nYou will notice that we don’t use the \n\nBetaSchedule and \n\nTargetMisfit directives. Here, the beta cooling schedule is set in the \n\nUpdateIRLS directive using the coolingFactor and coolingRate properties. The target misfit for the L2 portion of the IRLS approach is set with the chifact_start property.\n\nstarting_beta_irls = directives.BetaEstimate_ByEig(beta0_ratio=5)\nupdate_jacobi_irls = directives.UpdatePreconditioner(update_every_iteration=True)\nupdate_irls = directives.UpdateIRLS(\n    cooling_factor=2,\n    cooling_rate=3,\n    f_min_change=1e-4,\n    max_irls_iterations=30,\n    chifact_start=1.0,\n)\n\ndirectives_list_irls = [update_irls, starting_beta_irls, update_jacobi_irls]\n\n","type":"content","url":"/inv-fdem-1d#directives","position":55},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#define-and-run-the-inversion-1","position":56},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\n# Here we combine the inverse problem and the set of directives\ninv_irls = inversion.BaseInversion(inv_prob_irls, directives_list_irls)\n\n# Run the inversion\nrecovered_model_irls = inv_irls.run(starting_conductivity_model)\n\n","type":"content","url":"/inv-fdem-1d#define-and-run-the-inversion-1","position":57},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-fdem-1d#data-misfit-and-recovered-model","position":58},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndpred_irls = simulation_irls.dpred(recovered_model_irls)\n\nfig = plt.figure(figsize=(10, 5))\nax = [fig.add_axes([0.1 + ii * 0.5, 0.1, 0.37, 0.85]) for ii in range(2)]\nfor ii in range(2):\n    ax[ii].loglog(frequencies, np.abs(dobs[ii::2]), \"k-o\", lw=2)\n    ax[ii].loglog(frequencies, np.abs(dpred_L2[ii::2]), \"b-o\", lw=2)\n    ax[ii].loglog(frequencies, np.abs(dpred_irls[ii::2]), \"r-o\", lw=2)\n    ax[ii].grid(which=\"both\")\n    ax[ii].set_xlabel(\"Frequency (Hz)\")\n    ax[ii].set_ylabel(\"|Hs/Hp| (ppm)\")\n    ax[ii].legend([\"True Sounding\", \"Predicted (L2-model)\", \"Predicted (IRLS)\"])\n    if ii == 1:\n        ax[ii].set_ylabel(\"\")\n\nax[0].set_title(\"Real Component\")\nax[1].set_title(\"Imaginary Component\")\nplt.show()\n\n# Plot true model and recovered model\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_conductivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_irls, ax=ax1, color=\"r\"\n)\nax1.grid()\nax1.set_xlabel(r\"Conductivity ($S/m$)\")\nx_min, x_max = true_conductivities.min(), true_conductivities.max()\nax1.set_xlim(0.8 * x_min, 2 * x_max)\nax1.legend([\"True Model\", \"L2 Model\", \"IRLS Model\"])\nplt.show()\n\n","type":"content","url":"/inv-fdem-1d#data-misfit-and-recovered-model","position":59},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Parametric Inversion"},"type":"lvl2","url":"/inv-fdem-1d#parametric-inversion","position":60},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl2":"Parametric Inversion"},"content":"Here, we assume the subsurface is defined by a 3-layered Earth. However, the electrical properties and thicknesses of the layers are unknown. Here, we define our model to include log-conductivities and log-thicknesses. When including quantities that span different scales, it is frequently best to define the model in terms of log values so that each quantity influences the predicted data evenly.\n\n","type":"content","url":"/inv-fdem-1d#parametric-inversion","position":61},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Model and Mapping","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#model-and-mapping","position":62},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Model and Mapping","lvl2":"Parametric Inversion"},"content":"For a 3-layered Earth model, the model consists of 2 log-thicknesses and 3 log-conductivities. Similar to the \n\n1D Forward Simulation of Frequency Domain EM Data for a Single Sounding tutorial, need a mapping that extract log-thicknesses and log-resistivities from the model, and mappings that convert log-values to property values. For this, we require the \n\nsimpeg.maps.Wires mapping and \n\nsimpeg.maps.ExpMap mapping classes. Note that successive mappings can be chained together using the * operator.\n\n# Wire maps to extract log-thicknesses and log-conductivities\nwire_map = maps.Wires((\"log_thicknesses\", 2), (\"log_resistivity\", 3))\n\n# Maping for layer thicknesses\nlog_thicknesses_map = maps.ExpMap() * wire_map.log_thicknesses\n\n# Mapping for conductivities\nlog_resistivity_map = maps.ExpMap() * wire_map.log_resistivity\n\n","type":"content","url":"/inv-fdem-1d#model-and-mapping","position":63},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Starting and Reference Model","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#starting-and-reference-model","position":64},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Starting and Reference Model","lvl2":"Parametric Inversion"},"content":"This problem is highly non-linear so it is important to have a reasonable estimate of the true model.\n\nstarting_parametric_model = np.log(np.r_[30.0, 20.0, 20, 0.5, 5])\n\nreference_parametric_model = starting_parametric_model.copy()\n\n","type":"content","url":"/inv-fdem-1d#starting-and-reference-model","position":65},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Forward Simulation","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#forward-simulation","position":66},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Forward Simulation","lvl2":"Parametric Inversion"},"content":"Because the layer thicknesses are part of the model, we define the thicknessesMap. Because we are working in terms of electrical resistivity, we must define the rhoMap.\n\nsimulation_parametric = fdem.simulation_1d.Simulation1DLayered(\n    survey=survey,\n    rhoMap=log_resistivity_map,\n    thicknessesMap=log_thicknesses_map,\n)\n\n","type":"content","url":"/inv-fdem-1d#forward-simulation","position":67},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#data-misfit-2","position":68},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit","lvl2":"Parametric Inversion"},"content":"\n\ndmis_parametric = data_misfit.L2DataMisfit(\n    simulation=simulation_parametric, data=data_object\n)\n\n","type":"content","url":"/inv-fdem-1d#data-misfit-2","position":69},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"(Combo) Regularization","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#id-combo-regularization","position":70},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"(Combo) Regularization","lvl2":"Parametric Inversion"},"content":"We need to define a regularization for each model parameter type. In this case, we have log-thicknesses and log-conductivities. For each model parameter type, we create a 1D \n\ntensor mesh with length equal to the number of parameters. In the mapping keyword argument, we used the wire map that extracts the specific model parameters from the model.\n\nUsing the * operator, separate regularizations can be summed to form a regularization that is also a \n\nComboObjectiveFunction. By setting the multipliers property, we can emphasize the relative contributions of the log-thicknesses and log-conductivities regularizations.\n\nreg_1 = regularization.Smallness(\n    TensorMesh([(np.ones(2))], \"0\"),\n    mapping=wire_map.log_thicknesses,\n    reference_model=reference_parametric_model,\n)\n\nreg_2 = regularization.Smallness(\n    TensorMesh([(np.ones(3))], \"0\"),\n    mapping=wire_map.log_resistivity,\n    reference_model=reference_parametric_model,\n)\n\nreg_parametric = reg_1 + reg_2\nreg_parametric.multipliers = [1.0, 0.1]\n\n","type":"content","url":"/inv-fdem-1d#id-combo-regularization","position":71},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Optimization","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#optimization-2","position":72},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Optimization","lvl2":"Parametric Inversion"},"content":"\n\nopt_parametric = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-fdem-1d#optimization-2","position":73},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#inverse-problem-2","position":74},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Parametric Inversion"},"content":"\n\ninv_prob_parametric = inverse_problem.BaseInvProblem(\n    dmis_parametric, reg_parametric, opt_parametric\n)\n\n","type":"content","url":"/inv-fdem-1d#inverse-problem-2","position":75},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Directives","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#directives-1","position":76},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Directives","lvl2":"Parametric Inversion"},"content":"\n\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=5)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=3)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_parametric = [\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-fdem-1d#directives-1","position":77},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define and Run Inversion","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#define-and-run-inversion","position":78},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Define and Run Inversion","lvl2":"Parametric Inversion"},"content":"\n\ninv_parametric = inversion.BaseInversion(\n    inv_prob_parametric, directives_list_parametric\n)\nrecovered_model_parametric = inv_parametric.run(starting_parametric_model)\n\n","type":"content","url":"/inv-fdem-1d#define-and-run-inversion","position":79},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-fdem-1d#data-misfit-and-recovered-model-1","position":80},{"hierarchy":{"lvl1":"1D Inversion of Frequency Domain EM Data for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Parametric Inversion"},"content":"\n\ndpred_parametric = simulation_parametric.dpred(recovered_model_parametric)\n\nfig = plt.figure(figsize=(10, 5))\nax = [fig.add_axes([0.1 + ii * 0.5, 0.1, 0.37, 0.85]) for ii in range(2)]\nfor ii in range(2):\n    ax[ii].loglog(frequencies, np.abs(dobs[ii::2]), \"k-o\", lw=2)\n    ax[ii].loglog(frequencies, np.abs(dpred_L2[ii::2]), \"b-o\", lw=2)\n    ax[ii].loglog(frequencies, np.abs(dpred_irls[ii::2]), \"r-o\", lw=2)\n    ax[ii].loglog(frequencies, np.abs(dpred_parametric[ii::2]), \"g-o\", lw=2)\n    ax[ii].grid(which=\"both\")\n    ax[ii].set_xlabel(\"Frequency (Hz)\")\n    ax[ii].set_ylabel(\"|Hs/Hp| (ppm)\")\n    ax[ii].legend(\n        [\n            \"True Sounding\",\n            \"Predicted (L2-model)\",\n            \"Predicted (IRLS)\",\n            \"Predicted (Parametric)\",\n        ]\n    )\n    if ii == 1:\n        ax[ii].set_ylabel(\"\")\n\nax[0].set_title(\"Real Component\")\nax[1].set_title(\"Imaginary Component\")\nplt.show()\n\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_conductivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_irls, ax=ax1, color=\"r\"\n)\nplot_1d_layer_model(\n    log_thicknesses_map * recovered_model_parametric,\n    1 / (log_resistivity_map * recovered_model_parametric),\n    ax=ax1,\n    color=\"g\",\n)\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nx_min, x_max = true_conductivities.min(), true_conductivities.max()\nax1.set_xlim(0.9 * x_min, 2 * x_max)\nax1.set_ylim([np.sum(layer_thicknesses), 0])\nax1.legend([\"True Model\", \"L2 Model\", \"IRLS Model\", \"Parametric Model\"])\nplt.show()","type":"content","url":"/inv-fdem-1d#data-misfit-and-recovered-model-1","position":81},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding"},"type":"lvl1","url":"/fwd-tdem-1d","position":0},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: TDEM, forward simulation, waveforms, 1D sounding, wires mapping.\n\nSummary: In this tutorial, we present the fundamentals of simulating TDEM data in SimPEG. We use the module \n\nsimpeg​.electromagnetics​.time​_domain to simulate TDEM data for a 1D sounding. The \n\nSimulation1DLayered class is used to solve the problem via a semi-analytic Hankel transform solution. Note that most of what is learned here can be applied to simulating 3D TDEM data.\n\nThe tutorial is organized into 3 parts. In part 1, we focus on the most fundamental aspects of simulating TDEM data. For a step-off waveform, we simulate TDEM data for a conductive and non-permeable layered Earth. In part 2, we demonstrate how to include dispersive electromagnetic properties in the 1D TDEM simulation. And in part 3, we demonstrate how data can be simulated for user-specified transmitter waveforms.\n\nLearning Objectives:\n\nThe fundamentals of simulating TDEM data with SimPEG.\n\nUnderstanding the way in which TDEM surveys are created in SimPEG, which includes:\n\nDefining receivers\n\nDefining controlled sources\n\nOrganizing sources and receivers into a survey object\n\nDefining the Earth’s electrical properties in terms of conductivity OR resistivity.\n\nThe ways in which we can define 1D layered Earth models.\n\nSimulating TDEM data for different transmitter waveforms\n\nSimulating TDEM data for dispersive electromagnetic properties (i.e. induced polarization, superparamagnetism)\n\n","type":"content","url":"/fwd-tdem-1d","position":1},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Importing Modules"},"type":"lvl2","url":"/fwd-tdem-1d#importing-modules","position":2},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Importing Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to TDEM is imported from \n\nsimpeg​.electromagnetics​.time​_domain.\nWe also import some useful utility functions from \n\nsimpeg.utils.\n\n# SimPEG functionality\nimport simpeg.electromagnetics.time_domain as tdem\nfrom simpeg import maps\nfrom simpeg.utils import plot_1d_layer_model\n\n# Common Python functionality\nimport os\nimport numpy as np\nfrom scipy.constants import mu_0\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.rcParams.update({\"font.size\": 14})\n\nwrite_output = False  # Optional\n\n","type":"content","url":"/fwd-tdem-1d#importing-modules","position":3},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"type":"lvl2","url":"/fwd-tdem-1d#part-1-step-off-response-for-a-conductive-layer","position":4},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"content":"In this part of the tutorial, we focus on the most fundamental aspects of simulating TDEM data in SimPEG. Here, the survey consists of a single circular loop located 1 m above the Earth’s surface. The vertical B-field is simulated at the loop’s centre for a step-off waveform.\n\n","type":"content","url":"/fwd-tdem-1d#part-1-step-off-response-for-a-conductive-layer","position":5},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining the Survey","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"type":"lvl3","url":"/fwd-tdem-1d#defining-the-survey","position":6},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining the Survey","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"content":"TDEM surveys within SimPEG require the user to create and connect four types of objects:\n\nreceivers: There are a multitude of TDEM receiver classes within SimPEG, each of which is used to simulate data corresponding to a different field measurement; e.g. \n\nPointMagneticField, \n\nPointMagneticFluxTimeDerivative and \n\nPointElectricField. The properties for each TDEM receiver object generally include: the orientation of the field being measured (x, y, z, other), the time channels, the data type, and one or more associated observation locations.\n\nsources: There are a multitude of TDEM source classes within SimPEG, each of which corresponds to a different geometry; e.g. \n\nMagDipole and \n\nLineCurrent. Source classes generally require the user to define the current waveform, location and geometry.\n\nwaveforms: The waveform defining the time-dependent current in the source is defined by an object in SimPEG. Some waveform classes include \n\nStepOffWaveform, \n\nVTEMWaveform and \n\nRawWaveform\n\nsurvey: The object which stores and organizes all of the sources and receivers.\n\nFor a full list of source types, waveform types and receiver types, please visit API documentation for \n\nsimpeg​.electromagnetics​.time​_domain.\n\nTopography: When generating the survey for a 1D forward simulation, sources and receivers must be located above the Earth’s surface. By default, the Earth’s surface is at z = 0 m when defining the 1D simulation. So for 1D FDEM problems, it is easiest to define the z-locations of all sources and receivers as flight heights.\n\nFor this tutorial, the survey consists of a circular source loop 1 m above the surface that uses a step-off waveform. The vertical component of the magnetic flux density is measured at the loop’s center at a number of time channels.\n\n# Source properties\nsource_location = np.array([0.0, 0.0, 1.0])  # (3, ) numpy.array_like\nsource_orientation = \"z\"  # \"x\", \"y\" or \"z\"\nsource_current = 1.0  # maximum on-time current (A)\nsource_radius = 10.0  # source loop radius (m)\n\n# Receiver properties\nreceiver_locations = np.array([0.0, 0.0, 1.0])  # or (N, 3) numpy.ndarray\nreceiver_orientation = \"z\"  # \"x\", \"y\" or \"z\"\ntimes = np.logspace(-5, -2, 31)  # time channels (s)\n\nA waveform must be assigned as a property of each TDEM source object. Here, we define a step-off waveform. By default, the off-time for the step-off waveform begins at 0 s. However, the keyword argument off_time can be used to change the start of the off-time.\n\nstepoff_waveform = tdem.sources.StepOffWaveform(off_time=0.0)\n\nThe most general way to generate TDEM surveys is to loop over all sources. A new source object must be created whenever the source location and/or geometry differs. For each source, we define and assign the associated receivers. A different receiver object must be created whenever geometry, data type and/or time channels differ. However, identical data being collected at a multitude of observation locations can be defined using a single receiver object.\n\nFor this tutorial, we only have a single source. And this source only has a single receiver. More complicated survey geometries are used in the \n\n3D Forward Simulation of TDEM Data on Cylindrical Mesh for a Galvanic Source and \n\nForward Simulation of 3D Airborne TDEM Data on a Tree Mesh tutorials. These tutorials demonstrate the more general construction of TDEM surveys.\n\n# Define receiver list. In our case, we have only a single receiver for each source.\n# When simulating the response for multiple data types for the same source,\n# the list consists of multiple receiver objects.\nreceiver_list = []\nreceiver_list.append(\n    tdem.receivers.PointMagneticFluxDensity(\n        receiver_locations, times, orientation=receiver_orientation\n    )\n)\n\n# Define source list. In our case, we have only a single source.\nsource_list = [\n    tdem.sources.CircularLoop(\n        receiver_list=receiver_list,\n        location=source_location,\n        waveform=stepoff_waveform,\n        current=source_current,\n        radius=source_radius,\n    )\n]\n\n# Define the survey\nsurvey = tdem.Survey(source_list)\n\n","type":"content","url":"/fwd-tdem-1d#defining-the-survey","position":7},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining a 1D Layered Earth and the Model","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"type":"lvl3","url":"/fwd-tdem-1d#defining-a-1d-layered-earth-and-the-model","position":8},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining a 1D Layered Earth and the Model","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"content":"In SimPEG, a 1D layered Earth is defined by the set of layer thicknesses and the physical properties for each layer. Thicknesses and physical property values are defined from the top layer down. If we have N layers, we define N physical property values and N-1 layer thicknesses. The lowest layer is assumed to extend to infinity. In the case of a halfspace, the layer thicknesses would be an empty array.\n\n# Layer conductivities\nlayer_conductivities = np.r_[0.1, 1.0, 0.1]\n\n# Layer thicknesses\nlayer_thicknesses = np.r_[40.0, 40.0]\n\n# Number of layers\nn_layers = len(layer_conductivities)\n\nfig = plt.figure(figsize=(4, 5))\nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.8])\nax1 = plot_1d_layer_model(layer_thicknesses, layer_conductivities, scale=\"log\", ax=ax1)\nax1.grid(which=\"both\")\nax1.set_xlabel(r\"Conductivity ($S/m$)\")\nplt.show()\n\n","type":"content","url":"/fwd-tdem-1d#defining-a-1d-layered-earth-and-the-model","position":9},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Models and Mappings for 1D Simulations","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"type":"lvl3","url":"/fwd-tdem-1d#models-and-mappings-for-1d-simulations","position":10},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Models and Mappings for 1D Simulations","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"content":"In SimPEG, the term ‘model’ is not necessarily synonymous with a set of physical property values. For example, the model may be defined as the logarithms of the physical property values, or be the parameters defining a layered Earth geometry. Models in SimPEG are 1D \n\nnumpy.ndarray whose lengths are equal to the number of model parameters. For 1D TDEM simulations, we can characterize the Earth’s electric properties according to electrical conductivity or electrical resistivity.\n\nClasses within the simpeg.maps module are used to define the mapping that connects the model to the parameters required to run the 1D TDEM simulation; e.g. layer conductivities/resistivities, magnetic permeabilities and/or layer thicknesses. In this part of the tutorial, we demonstrate 2 types of mappings and models that may be used for 1D TDEM simulation.\n\n1. Conductivity model: For forward simulation, the easiest approach is to define the model as the layer conductivities and set the layer thicknesses as a static property of the 1D simulation. In this case, the mapping from the model to the conductivities is defined using the \n\nsimpeg​.maps​.IdentityMap class.\n\n2. Parametric layered Earth model: In this case, the model parameters are log-resistivities and layer thicknesses. We therefore need a mapping that extracts log-resistivities from the model and converts them into resistivities, and a mapping that extracts layer thicknesses from the model. For this, we require the \n\nsimpeg.maps.Wires mapping and \n\nsimpeg.maps.ExpMap mapping classes. Note that successive mappings can be chained together using the * operator.\n\n# Define model and mapping for a conductivity model.\nconductivity_model = layer_conductivities.copy()\nconductivity_map = maps.IdentityMap(nP=n_layers)\n\n# Define model and mappings for the parametric model.\n# Note the ordering in which you defined the model parameters and the\n# order in which you defined the wire mappings matters!!!\nparametric_model = np.r_[layer_thicknesses, np.log(1 / layer_conductivities)]\nwire_map = maps.Wires((\"thicknesses\", n_layers - 1), (\"log_resistivity\", n_layers))\nthicknesses_map = wire_map.thicknesses\nlog_resistivity_map = maps.ExpMap() * wire_map.log_resistivity\n\n","type":"content","url":"/fwd-tdem-1d#models-and-mappings-for-1d-simulations","position":11},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining the Forward Simulation","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"type":"lvl3","url":"/fwd-tdem-1d#defining-the-forward-simulation","position":12},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining the Forward Simulation","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"content":"In SimPEG, the physics of the forward simulation is defined by creating an instance of an appropriate simulation class. Here, we use the \n\nSimulation1DLayered which simulates the data according to a 1D Hankel transform solution. To fully define the forward simulation, we need to connect the simulation object to:\n\nthe survey\n\nthe layer thicknesses\n\nthe physical properties of the layers (e.g. conductivity)\n\nThis is accomplished by setting each one of the aforementioned items as a property of the simulation object. Since the parameters defining the model in each case are different, we must define a separate simulation object for each case.\n\n1. Conductivity model simulation: Here, the model parameters are the layer conductivities. sigmaMap is used to define the mapping from the model to the layer conductivities. And thicknessess is used to set the layer thicknesses as a static property of the simulation.\n\n2. Parametric model simulation: Here, the model consists of the layer thicknesses and log-resistivities. Because we are now working with electric resistivity, rhoMap is used to define the mapping for the Earth’s electrical properties; i.e. model parameters to layer resistivities. And thicknessesMap is used to define the mapping from the model to the layer thicknesses.\n\nsimulation_conductivity = tdem.simulation_1d.Simulation1DLayered(\n    survey=survey,\n    sigmaMap=conductivity_map,\n    thicknesses=layer_thicknesses,\n)\n\nsimulation_parametric = tdem.simulation_1d.Simulation1DLayered(\n    survey=survey,\n    rhoMap=log_resistivity_map,\n    thicknessesMap=thicknesses_map,\n)\n\n","type":"content","url":"/fwd-tdem-1d#defining-the-forward-simulation","position":13},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Predict 1D TDEM Data","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"type":"lvl3","url":"/fwd-tdem-1d#predict-1d-tdem-data","position":14},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Predict 1D TDEM Data","lvl2":"Part 1: Step-Off Response for a Conductive Layer"},"content":"Once any simulation within SimPEG has been properly constructed, simulated data for a given model vector can be computed using the \n\ndpred method. Note that despite the difference in how we defined the model, the data predicted for the conductivity and parametric models is the same.\n\nFor surveys consisting of multiple sources, multiple receivers per source and multiple observation locations and time channels per receiver, the predicted data vector is organized:\n\nby source\n\nby receiver\n\nby time channel, then\n\nby observation location\n\ndpred_conductivity = simulation_conductivity.dpred(conductivity_model)\ndpred_parametric = simulation_parametric.dpred(parametric_model)\n\nfig = plt.figure(figsize=(5, 6))\nax = fig.add_axes([0.2, 0.15, 0.75, 0.78])\nax.loglog(times, dpred_conductivity, \"b-\", lw=3)\nax.loglog(times, dpred_parametric, \"r--\", lw=3)\nax.set_xlim([times.min(), times.max()])\nax.grid()\nax.set_xlabel(\"Times (s)\")\nax.set_ylabel(\"B (T)\")\nax.set_title(\"Magnetic Flux Density\")\nax.legend([\"Conductivity model\", \"Parametric model\"])\nplt.show()\n\n","type":"content","url":"/fwd-tdem-1d#predict-1d-tdem-data","position":15},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"type":"lvl2","url":"/fwd-tdem-1d#part-2-magnetic-permeability-and-dispersive-physical-properties","position":16},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"content":"In this part of the tutorial, we simulate TDEM data for 3 cases: 1) a conductive and magnetically permeable layer, 2) a conductive and chargeable layer, and 3) a conductive layer with a magnetically viscous top layer. In all cases, the set of model parameters are the layer conductivities from part 1.\n\n","type":"content","url":"/fwd-tdem-1d#part-2-magnetic-permeability-and-dispersive-physical-properties","position":17},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Case 1: the conductive layer is also magnetically permeable","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"type":"lvl3","url":"/fwd-tdem-1d#case-1-the-conductive-layer-is-also-magnetically-permeable","position":18},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Case 1: the conductive layer is also magnetically permeable","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"content":"In this case, the middle layer is magnetically permeable in addition to being more conductive than the host. For TDEM simulation classes within SimPEG, the Earth’s magnetic properties are defined as magnetic permeabilities (not susceptibilities). Here, the layer magnetic permeabilities are set as a static property of the simulation using the mu keyword argument. However, one could define a model whose parameters contain the layer magnetic permeabilities; see the \n\n1D Forward Simulation of Frequency Domain EM Data for a Single Sounding tutorial. This would require the user set muMap.\n\nlayer_susceptibilities = np.r_[0.0, 9.0, 0.0]\nlayer_permeabilities = mu_0 * (1 + layer_susceptibilities)\n\nsimulation_permeable = tdem.simulation_1d.Simulation1DLayered(\n    survey=survey,\n    sigmaMap=conductivity_map,\n    thicknesses=layer_thicknesses,\n    mu=layer_permeabilities,\n)\n\ndpred_permeable = simulation_permeable.dpred(conductivity_model)\n\n","type":"content","url":"/fwd-tdem-1d#case-1-the-conductive-layer-is-also-magnetically-permeable","position":19},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Case 2: the middle layer is also chargeable (induced polarization)","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"type":"lvl3","url":"/fwd-tdem-1d#case-2-the-middle-layer-is-also-chargeable-induced-polarization","position":20},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Case 2: the middle layer is also chargeable (induced polarization)","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"content":"In this case, the middle layer exhibits an induced polarization (IP) response. In SimPEG, we use the Cole-Cole model to characterize the dispersive conductivity, see \n\nEM GeoSci:\\sigma_{ip} (\\omega) = \\sigma \\left [ 1 - \\frac{\\eta}{1 + (1-\\eta )(i\\omega \\tau)^C} \\right ]\n\nwhere:\n\n\\omega is the radial frequency (rad/s)\n\n\\sigma is the electrical conductivity (S/m) at the infinite frequency limit\n\n0 < \\eta \\leq 1 is the intrinsic chargeability (unitless)\n\n0 < \\tau is the central time-relaxation constant (s)\n\n0 \\leq C \\leq 1 (unitless) defines the distribution of time-relaxation constants. A Debye model is C=1.\n\nWhen electrical conductivities \\sigma_\\infty are model parameters, sigmaMap sets the mapping from the model to the layer conductivities. In rare instances, electrical conductivities are set directly using the sigma keyword argument. Unfortunately, SimPEG does not currently have the ability to include the additional parameters used to define dispersive electrical conductivities in the model. As such, these parameters are set as static parameters of the simulation class using the eta, tau and C keyword arguments.\n\nImportant: In order for the 1D simulation to model dispersive conductivities correctly, none of the values used to set eta can be equal to zero, even if the layer is non-chargeable. To model non-chargeable layers, simply set the value to something small.\n\neta = 0.5  # intrinsic chargeability [0, 1]\ntau = 0.001  # central time-relaxation constant in seconds\nc = 0.8  # phase constant [0, 1]\n\nlayer_eta = np.r_[1e-10, eta, 1e-10]\nlayer_tau = np.r_[0.0, tau, 0.0]\nlayer_c = np.r_[0.0, c, 0.0]\n\nsimulation_ip = tdem.Simulation1DLayered(\n    survey=survey,\n    thicknesses=layer_thicknesses,\n    sigmaMap=conductivity_map,\n    eta=layer_eta,\n    tau=layer_tau,\n    c=layer_c,\n)\n\ndpred_ip = simulation_ip.dpred(conductivity_model)\n\n","type":"content","url":"/fwd-tdem-1d#case-2-the-middle-layer-is-also-chargeable-induced-polarization","position":21},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Case 3: the top layer exhibits superparamagnetism (SPM)","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"type":"lvl3","url":"/fwd-tdem-1d#case-3-the-top-layer-exhibits-superparamagnetism-spm","position":22},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Case 3: the top layer exhibits superparamagnetism (SPM)","lvl2":"Part 2: Magnetic Permeability and Dispersive Physical Properties"},"content":"In this case, the top layer exhibits superparamagnetism (or viscous remanent magnetization). In SimPEG, we use a log-uniform distribution of time relaxation constants to define the dispersive magnetization, see \n\nEM GeoSci:\\mu_{spm}(\\omega ) = \\mu + \\mu_0 \\Delta \\chi \\Bigg [\n1 - \\Bigg ( \\frac{1}{ln (\\tau_2 / \\tau_1 )} \\Bigg )\nln \\Bigg ( \\frac{1 + i\\omega \\tau_2}{1 + i\\omega \\tau_1} ) \\Bigg )\n\\Bigg ]\n\nwhere:\n\n\\omega is the radial frequency (rad/s)\n\n\\mu_0 is the permeability of free space\n\n\\mu is the magnetic permeability at the infinite frequency limit\n\n0\\leq \\Delta \\chi (unitless) is the DC susceptibility for the SPM effect\n\n0 < \\tau_1 < \\tau_2 are the lower and upper bounds for the log-uniform distribution of time-relaxation constants\n\nWhen magnetic permeabilities \\mu are model parameters, muMap sets the mapping from the model to the layer permeabilities. In rare instances, magnetic permeabilities are set directly using the mu keyword argument. Unfortunately, SimPEG does not currently have the ability to include the additional parameters used to define dispersive magnetic permeability in the model. As such, these parameters are set as static parameters of the simulation class using the dchi, tau1 and tau2 keyword arguments.\n\nchi = 0.01  # infinite susceptibility in SI\ndchi = 0.01  # amplitude of frequency-dependent susceptibility contribution\ntau1 = 1e-7  # lower limit for time relaxation constants in seconds\ntau2 = 1.0  # upper limit for time relaxation constants in seconds\n\nlayer_mu = mu_0 * (1 + chi * np.r_[1.0, 0.0, 0.0])  # convert to permeability\nlayer_dchi = chi * np.r_[1.0, 0.0, 0.0]\nlayer_tau1 = tau1 * np.r_[1.0, 0.0, 0.0]\nlayer_tau2 = tau1 * np.r_[1.0, 0.0, 0.0]\n\nsimulation_spm = tdem.Simulation1DLayered(\n    survey=survey,\n    thicknesses=layer_thicknesses,\n    sigmaMap=conductivity_map,\n    mu=mu_0,\n    dchi=dchi,\n    tau1=tau1,\n    tau2=tau2,\n)\n\ndpred_spm = simulation_spm.dpred(conductivity_model)\n\nfig = plt.figure(figsize=(5, 6))\nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.85])\nax1.loglog(times, np.abs(dpred_conductivity[0 : len(times)]), \"k\", lw=2)\nax1.loglog(times, np.abs(dpred_permeable[0 : len(times)]), \"r\", lw=2)\nax1.loglog(times, np.abs(dpred_ip[0 : len(times)]), \"b\", lw=2)\nax1.loglog(times, np.abs(dpred_spm[0 : len(times)]), \"g\", lw=2)\nax1.set_xlim([times.min(), times.max()])\nax1.grid()\nax1.legend(\n    [\n        \"Conductive layer\",\n        \"Conductive and permeable\",\n        \"Conductive and chargeable\",\n        \"Superparamagnetic case\",\n    ]\n)\nax1.set_xlabel(\"Times (s)\")\nax1.set_ylabel(\"B (T)\")\nax1.set_title(\"Magnetic Flux Density\")\nplt.show()\n\n","type":"content","url":"/fwd-tdem-1d#case-3-the-top-layer-exhibits-superparamagnetism-spm","position":23},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Part 3: Simulation for Different Waveforms"},"type":"lvl2","url":"/fwd-tdem-1d#part-3-simulation-for-different-waveforms","position":24},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl2":"Part 3: Simulation for Different Waveforms"},"content":"In this part of the tutorial, we simulate TDEM data for various transmitter waveforms using a single survey object. As we learned in part 1, each waveform will require the construction of a different source object. For any waveform object, the \n\neval method can be used to evaluate the waveform at the time provided.\n\n","type":"content","url":"/fwd-tdem-1d#part-3-simulation-for-different-waveforms","position":25},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining Different Waveforms","lvl2":"Part 3: Simulation for Different Waveforms"},"type":"lvl3","url":"/fwd-tdem-1d#defining-different-waveforms","position":26},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Defining Different Waveforms","lvl2":"Part 3: Simulation for Different Waveforms"},"content":"\n\n# Rectangular waveform. The user may customize the waveform by setting the start\n# time, end time and on time amplitude for the current waveform.\neps = 1e-6\nramp_on = np.r_[-0.004, -0.004 + eps]\nramp_off = np.r_[-eps, 0.0]\nrectangular_waveform = tdem.sources.TrapezoidWaveform(\n    ramp_on=ramp_on, ramp_off=ramp_off\n)\n\n# Triangular waveform. The user may customize the waveform by setting the start\n# time, peak time, end time and peak amplitude for the current waveform.\neps = 1e-8\nstart_time = -0.02\npeak_time = -0.01\noff_time = 0.0\ntriangle_waveform = tdem.sources.TriangularWaveform(\n    start_time=start_time, peak_time=peak_time, off_time=off_time\n)\n\n# General waveform. This is a fully general way to define the waveform.\n# The use simply provides times and the current.\n\n\ndef custom_waveform(t, tmax):\n    out = np.cos(0.5 * np.pi * (t - tmax) / (tmax + 0.02))\n    out[t >= tmax] = 1 + (t[t >= tmax] - tmax) / tmax\n    return out\n\n\nwaveform_times = np.r_[np.linspace(-0.02, -0.011, 10), -np.logspace(-2, -6, 61), 0.0]\nwaveform_current = custom_waveform(waveform_times, -0.0055)\ngeneral_waveform = tdem.sources.PiecewiseLinearWaveform(\n    times=waveform_times, currents=waveform_current\n)\n\nfig = plt.figure(figsize=(6, 4))\nax = fig.add_axes([0.1, 0.1, 0.85, 0.8])\n\nax.plot(np.r_[-2e-2, 0.0, 1e-10, 1e-3], np.r_[1.0, 1.0, 0.0, 0.0], \"k\", lw=2)\nplotting_current = [rectangular_waveform.eval(t) for t in waveform_times]\nax.plot(waveform_times, plotting_current, \"b\", lw=2)\nplotting_current = [triangle_waveform.eval(t) for t in waveform_times]\nax.plot(waveform_times, plotting_current, \"r\", lw=2)\nplotting_current = [general_waveform.eval(t) for t in waveform_times]\nax.plot(waveform_times, plotting_current, \"g\", lw=2)\n\nax.grid()\nax.set_xlim([waveform_times.min(), 1e-3])\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Current (A)\")\nax.set_title(\"Waveforms\")\nax.legend([\"Step-off\", \"Rectangular\", \"Triangle\", \"General\"], loc=\"lower left\")\nplt.show()\n\n","type":"content","url":"/fwd-tdem-1d#defining-different-waveforms","position":27},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Designing a Survey with Multiple Sources","lvl2":"Part 3: Simulation for Different Waveforms"},"type":"lvl3","url":"/fwd-tdem-1d#designing-a-survey-with-multiple-sources","position":28},{"hierarchy":{"lvl1":"1D Forward Simulation for a Single Sounding","lvl3":"Designing a Survey with Multiple Sources","lvl2":"Part 3: Simulation for Different Waveforms"},"content":"\n\nwaveforms_list = [\n    stepoff_waveform,\n    rectangular_waveform,\n    triangle_waveform,\n    general_waveform,\n]\n\nsource_list_multi = []\n\nfor w in waveforms_list:\n    receiver_list_multi = [\n        tdem.receivers.PointMagneticFluxDensity(\n            receiver_locations, times, orientation=receiver_orientation\n        )\n    ]\n\n    source_list_multi.append(\n        tdem.sources.CircularLoop(\n            receiver_list=receiver_list_multi,\n            location=source_location,\n            waveform=w,\n            current=source_current,\n            radius=source_radius,\n        )\n    )\n\n# Define the survey\nsurvey_multi = tdem.Survey(source_list_multi)\n\nsimulation_waveforms = tdem.Simulation1DLayered(\n    survey=survey_multi, thicknesses=layer_thicknesses, sigmaMap=conductivity_map\n)\n\ndpred_waveforms = simulation_waveforms.dpred(conductivity_model)\n\nfig = plt.figure(figsize=(5, 6))\nd = np.reshape(dpred_waveforms, (len(source_list_multi), len(times))).T\nax = fig.add_axes([0.15, 0.15, 0.8, 0.75])\ncolorlist = [\"k\", \"b\", \"r\", \"g\"]\nfor ii, k in enumerate(colorlist):\n    ax.loglog(times, np.abs(d[:, ii]), k, lw=2)\n\nax.set_xlim([times.min(), times.max()])\nax.grid()\nax.legend([\"Step-off\", \"Rectangular\", \"Triangle\", \"General\"])\nax.set_xlabel(\"Times (s)\")\nax.set_ylabel(\"B (T)\")\nax.set_title(\"Magnetic Flux Density\")\nplt.show()\n\nOptional: Write data\n\nif write_output:\n    dir_path = os.path.sep.join([\".\", \"fwd_tdem_1d_outputs\"]) + os.path.sep\n    if not os.path.exists(dir_path):\n        os.mkdir(dir_path)\n\n    rng = np.random.default_rng(seed=347)\n    noise = rng.normal(\n        scale=0.05 * np.abs(dpred_conductivity),\n        size=len(dpred_conductivity),\n    )\n    dpred_conductivity += noise\n    fname = dir_path + \"em1dtm_data.txt\"\n    np.savetxt(fname, np.c_[times, dpred_conductivity], fmt=\"%.4e\", header=\"TIME BZ\")","type":"content","url":"/fwd-tdem-1d#designing-a-survey-with-multiple-sources","position":29},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations"},"type":"lvl1","url":"/fwd-tdem-fundamentals","position":0},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations"},"content":"Introductory notebook\n\nThis tutorial teaches basic functionality within SimPEG and is a good entry point for new users.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nPrerequisite Tutorials\n\n1D Forward Simulation for a Single Sounding\n\nKeywords: finite volume fundamentals, TDEM, forward simulation, time discretization, mesh discretization.\n\nSummary: Successful forward simulation of TDEM data using mimetic finite volume requires reasonable values for a multitude of input parameters. More specifically, the parameters which determine how our numerical scheme is discretized in space and in time. When choosing parameters values for the TDEM forward simulation, we aim find an optimum balance between:\n\nnumerical accuracy, and\n\nrequired computational resources (e.g. run-time, memory)\n\nThis tutorial does not focus on the syntax for generating and using the SimPEG objects required for TDEM forward simulations. We assume the user has worked through the \n\n1D Forward Simulation for a Single Sounding tutorial and is already familiar with generating waveform, source, receiver, survey and simulation objects. Since designing the survey and choosing an appropriate simulation class are problem-dependent, we will cover this in separate tutorials.\n\nHere, we introduce guidelines for discretizing TDEM problems in space and in time that can be applied in most cases. We then demonstrate how our choices with regards to discretization impact TDEM forward simulations. To limit the computation time required to run the tutorial, all simulations are performed on a \n\nCylindrical Mesh. However, the knowledge gained here can be applied regardless of the mesh type (e.g. \n\nTensor Mesh, \n\nTree Mesh).\n\nLearning Objectives:\n\nUsing observation times and subsurface conductivity to generate an appropriate mesh.\n\nDefining the time discretization during the off-time.\n\nDefining the time discretization during a waveform’s on-time.\n\n","type":"content","url":"/fwd-tdem-fundamentals","position":1},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Importing Modules"},"type":"lvl2","url":"/fwd-tdem-fundamentals#importing-modules","position":2},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Importing Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to TDEM is imported from \n\nsimpeg​.electromagnetics​.time​_domain. We also import some useful utility functions from \n\nsimpeg.utils.\n\n# SimPEG functionality\nimport simpeg.electromagnetics.time_domain as tdem\nfrom simpeg import maps\n\n# discretize functionality\nfrom discretize import CylindricalMesh, TensorMesh\n\n# Common Python functionality\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nmpl.rcParams.update({\"font.size\": 14})\n\n","type":"content","url":"/fwd-tdem-fundamentals#importing-modules","position":3},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Defining the Simulation Geometry"},"type":"lvl2","url":"/fwd-tdem-fundamentals#defining-the-simulation-geometry","position":4},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Defining the Simulation Geometry"},"content":"Here, we define the problem geometry that will be used throughout the tutorial. The problem geometry consists of a horizontal circular transmitter loop with a radius of 25 m, located on the Earth’s surface. Data are simulated at the center of the loop for a set of logarithmically-spaced time channels between 1e-5 s and 1e-3 s. The subsurface electrical conductivity is characterized by a 1e-2 S/m halfspace.\n\n# Source properties\nsource_location = np.array([0.0, 0.0, 0.0])  # (3, ) numpy.array_like\nsource_orientation = \"z\"  # \"x\", \"y\" or \"z\"\nsource_current = 1.0  # maximum on-time current (A)\nsource_radius = 25.0  # source loop radius (m)\n\n# Receiver properties\nreceiver_locations = np.array([0.0, 0.0, 0.0])  # or (N, 3) numpy.ndarray\nreceiver_orientation = \"z\"  # \"x\", \"y\" or \"z\"\ntime_channels = np.logspace(-5, -3, 21)  # time channels (s)\n\n# Model properties\nhalfspace_conductivity = 1e-2  # Halfspace conductivity (S/m)\n\n","type":"content","url":"/fwd-tdem-fundamentals#defining-the-simulation-geometry","position":5},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Defining Some Useful Functions"},"type":"lvl2","url":"/fwd-tdem-fundamentals#defining-some-useful-functions","position":6},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Defining Some Useful Functions"},"content":"\n\n","type":"content","url":"/fwd-tdem-fundamentals#defining-some-useful-functions","position":7},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Generate the Survey","lvl2":"Defining Some Useful Functions"},"type":"lvl3","url":"/fwd-tdem-fundamentals#generate-the-survey","position":8},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Generate the Survey","lvl2":"Defining Some Useful Functions"},"content":"For the \n\nwaveform object and field type provided, this function generates the \n\nTDEM survey object for our problem geometry when called.\n\ndef generate_survey(waveform_object):\n    # Define receiver\n    receiver_list = [\n        tdem.receivers.PointMagneticFluxTimeDerivative(\n            receiver_locations, time_channels, orientation=receiver_orientation\n        )\n    ]\n\n    # Define loop source\n    source_list = [\n        tdem.sources.CircularLoop(\n            receiver_list=receiver_list,\n            location=source_location,\n            waveform=waveform_object,\n            current=source_current,\n            radius=source_radius,\n        )\n    ]\n\n    return tdem.Survey(source_list)\n\n","type":"content","url":"/fwd-tdem-fundamentals#generate-the-survey","position":9},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Generate the Mesh, Model and Mapping","lvl2":"Defining Some Useful Functions"},"type":"lvl3","url":"/fwd-tdem-fundamentals#generate-the-mesh-model-and-mapping","position":10},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Generate the Mesh, Model and Mapping","lvl2":"Defining Some Useful Functions"},"content":"For the minimum cell size dh, minimum diffusion distance d_min and maximum diffusion distance d_max, this function generates a \n\nCylindrical Mesh. The extent of the core region is 8 times the smallest diffusion distance. The padding thickness is 2 times the largest diffusion distance and a padding factor of 1.25 is used. For more, visit the \n\ndiscretize tutorial on cylindrical meshes.\n\ndef generate_discretization(dh, d_min, d_max):\n    # Number of core mesh cells\n    n_core = np.floor(8 * d_min / dh)\n\n    # Number of padding cells\n    n_pad = 1\n    pad_factor = 1.25\n    while sum(dh * pad_factor ** np.arange(n_pad)) < 2 * d_max:\n        n_pad += 1\n\n    # Radial and vertical discretization\n    hr = [(dh, n_core), (dh, n_pad, 1.2)]\n    hz = [(dh, n_pad, -pad_factor), (dh, 2 * n_core), (dh, n_pad, pad_factor)]\n\n    # Generate mesh\n    mesh = CylindricalMesh([hr, 1, hz], x0=\"00C\")\n\n    # Active cells\n    active_cells = mesh.cell_centers[:, -1] < 0.0\n\n    # Halfspace conductivity model\n    model = halfspace_conductivity * np.ones(np.sum(active_cells))\n\n    # Mapping from conductivity model to mesh\n    mapping = maps.InjectActiveCells(mesh, active_cells, 1e-8)\n\n    return mesh, model, mapping\n\n","type":"content","url":"/fwd-tdem-fundamentals#generate-the-mesh-model-and-mapping","position":11},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Part 1: Discretization in Space (cell size)"},"type":"lvl2","url":"/fwd-tdem-fundamentals#part-1-discretization-in-space-cell-size","position":12},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Part 1: Discretization in Space (cell size)"},"content":"Here, we investigate the impact of minimum cell size on the accuracy of the forward simulation. It is obvious that finer cells will reduce the error in the numerical forward simulation. However, overly fine discretization can produce meshes that make the numerical forward simulation untenable. For instance, by decreasing the widths of the cells in a mesh by a factor of 2, the number of cells in a 2D tensor mesh will increase by a factor of 4, and the number of cells in a 3D tensor mesh will increase by a factor of 8. So when choosing the parameters that define the mesh, we aim find an optimum balance between:\n\nnumerical accuracy, and\n\nrequired computational resources (e.g. run-time, memory)\n\nFor the problem geometry described in the introduction, we simulate \\partial b_z/\\partial t at the source loop’s center for a step-off excitation. When generating an appropriate mesh for the simulation, we consider the \n\ndiffusion distance:d = \\sqrt{\\frac{2 t}{\\mu \\sigma}} \\approx 1260 \\sqrt{\\frac{t}{\\sigma}}\n\nwhich defines the distance the peak amplitude of a planewave has traveled within a homogeneous medium at time t after an initial step excitation. For times 1e-6 s, 1e-5 s and 1e-4 s, this is illustrated in the figure below.\n\nAt early times, we see the signal is compact and the diffusion distance is small. So to model the physics accurately at early times, finer spatial sampling (i.e. discretization) within the region of the signal is required. At later times, the signal has diffused and become smooth, and the diffusion distance is larger. So at larger distances from the source, where the signal is smooth and is not present until later times, we can use a coarser discretization and still model the physics accurately. Note that in more conductive media, the diffusion distance is smaller and a finer discretization is required.\n\n\n\nPropagation and diffusion of a planewave within a homogeneous medium.\n\nStandard Approach:\n\n1) Minimum cell size: use the earliest time channel in the survey and the highest conductivity for your geophysical scenario to compute the minimum diffusion distance, i.e.:d_{min} \\approx 1260 \\sqrt{\\frac{t_{min}}{\\sigma_{max}}}\n\nThe minimum cell size must be equal or smaller than the minimum skin depth; i.e. \\Delta h_{min} \\leq d_{min}. Due to interpolation error, there should also be several cells between any controlled source and its receiver(s); which can result in minimum cell sizes that are much smaller than the minimum diffusion distance.\n\n2) Discretization within the core region: The core region describes the region containing structures whose responses you wish to simulate. Further away from any controlled source, the fields are smoother and we can use a coarser discretization. But what is the rate at which we can increase the cell widths?\n\nCylindrical Meshes and \n\nTensor Meshes: In this case, the minimum cell size is used throughout the entire core mesh region. Based on the size of the problem, the thickness of this region is some multiple of the minimum diffusion distance for the simulation.\n\nTree Meshes: In this case, cell size can increase linearly with respect to distance from any controlled source. However it is important not to increase the cell size too quickly. You should have a layer at least 4 cells thick before increasing the cell size again within the core mesh region.\n\nAs an additional note, the dimensions of the cells within the core mesh region should never exceed an aspect ratio of 2:1.\n\n3. Mesh boundaries: The natural boundary conditions for TDEM simulations in SimPEG require the user to define the boundaries of the mesh sufficiently far from any controlled source. To define appropriate boundaries for the mesh, use the latest time channel and host conductivity to compute the largest diffusion distance, i.e.:d_{max} \\approx 1260 \\sqrt{\\frac{t_{max}}{\\sigma_{host}}}\n\nThe padding region between the survey and the edge of the mesh must be 2-3 times the largest diffusion distance. Because the fields within this padding region are smooth, we can used a very coarse discretization.\n\nCylindrical Meshes and \n\nTensor Meshes: In this case, the widths of the cells along each direction are increased successively by a constant factor. We advise using a factor that is \\leq 1.5.\n\nTree Meshes: Tree meshes will pad out naturally. So long as the core mesh region extends sufficiently far, you can expect reasonable accuracy at late times.\n\n","type":"content","url":"/fwd-tdem-fundamentals#part-1-discretization-in-space-cell-size","position":13},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Compute the Diffusion Distances","lvl2":"Part 1: Discretization in Space (cell size)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#compute-the-diffusion-distances","position":14},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Compute the Diffusion Distances","lvl2":"Part 1: Discretization in Space (cell size)"},"content":"Here, we compute the minimum and maximum diffusion distances for the forward simulation. Here, we only have to consider the diffusion distances for a halfspace. As we can see, the minimum diffusion distance is 39.8 m. And the maximum diffusion distance is 398.4 m.\n\ndiffusion_distances = 1260 * np.sqrt(time_channels / halfspace_conductivity)\nd_min = diffusion_distances.min()\nd_max = diffusion_distances.max()\nprint(\"DIFFUSION DISTANCES: {}\".format(np.round(diffusion_distances, 1)))\n\n","type":"content","url":"/fwd-tdem-fundamentals#compute-the-diffusion-distances","position":15},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define Minimum Cell Widths","lvl2":"Part 1: Discretization in Space (cell size)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#define-minimum-cell-widths","position":16},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define Minimum Cell Widths","lvl2":"Part 1: Discretization in Space (cell size)"},"content":"To validate the standard approach, forward simulations are performed using minimum cell sizes equal to:\\Delta h_{min} = \\left \\{ 4\\, d_{min}, \\; 2\\, d_{min}, \\; d_{min}, \\; 0.5\\, d_{min}, \\; 0.25\\, d_{min} \\right \\}\n\nHere, we define the list containing the minimum cell size used in each forward simulation.\n\nsize_factor = [4.0, 2.0, 1.0, 0.5, 0.25]\ndh_min = [c * d_min for c in size_factor]\n\n","type":"content","url":"/fwd-tdem-fundamentals#define-minimum-cell-widths","position":17},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define the Waveform","lvl2":"Part 1: Discretization in Space (cell size)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#define-the-waveform","position":18},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define the Waveform","lvl2":"Part 1: Discretization in Space (cell size)"},"content":"Here, we define the \n\nstepoff waveform object that is used in the forward simulations. This waveform assumes a constant current of 1 A at time t \\leq 0.\n\nstepoff_waveform = tdem.sources.StepOffWaveform(off_time=0.0)\n\n","type":"content","url":"/fwd-tdem-fundamentals#define-the-waveform","position":19},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Numerical Solution","lvl2":"Part 1: Discretization in Space (cell size)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#numerical-solution","position":20},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Numerical Solution","lvl2":"Part 1: Discretization in Space (cell size)"},"content":"Here, we perform the forward simulation for the set of minimum cell widths \\Delta h_{min} and store the predicted data in list dpred_1. For minimum cell width, we must:\n\ndefine a new mesh, model and mapping.\n\ndefine the simulation.\n\npredict data for the halfspace conductivity model.\n\nWe have automatically set a reasonable time-discretization for the problem. The impact of time-discretization is demonstrated in Part 2.\n\ndpred_1 = []\n\nfor dh in dh_min:\n    # Generate mesh, model and mapping\n    mesh, model, mapping = generate_discretization(dh, d_min, d_max)\n\n    # Define the simulation\n    simulation = tdem.simulation.Simulation3DElectricField(\n        mesh,\n        survey=generate_survey(stepoff_waveform),\n        sigmaMap=mapping,\n        time_steps=[(5e-07, 40), (2.5e-06, 40), (1.25e-05, 81)],\n    )\n\n    # Simulate the data\n    dpred_1.append(simulation.dpred(model))\n\n    print(\"N_CELLS: {} | dh = {} m\".format(mesh.nC, dh))\n\n","type":"content","url":"/fwd-tdem-fundamentals#numerical-solution","position":21},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Semi-Analytic 1D Solution","lvl2":"Part 1: Discretization in Space (cell size)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#semi-analytic-1d-solution","position":22},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Semi-Analytic 1D Solution","lvl2":"Part 1: Discretization in Space (cell size)"},"content":"Here, the \n\nSimulation1DLayered simulation class is used to simulate the semi-analytic solution for our problem.\n\nsimulation_1d = tdem.simulation_1d.Simulation1DLayered(\n    survey=generate_survey(stepoff_waveform),\n    thicknesses=[],\n    sigmaMap=maps.IdentityMap(nP=1),\n)\n\ndtrue_stepoff = simulation_1d.dpred(np.array([halfspace_conductivity]))\n\n","type":"content","url":"/fwd-tdem-fundamentals#semi-analytic-1d-solution","position":23},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Results","lvl2":"Part 1: Discretization in Space (cell size)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#results","position":24},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Results","lvl2":"Part 1: Discretization in Space (cell size)"},"content":"Here, we plot the 1D solution and the numerical solutions for different minimum cell widths. As we can see, sufficient numerical accuracy is obtained when the minimum cell width is equal to or smaller than the minimum diffusion distance; i.e. when \\Delta h_{min} \\leq d_{min}.\n\nfig = plt.figure(figsize=(6, 6))\nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.85])\nax1.loglog(time_channels, -dtrue_stepoff, \"k\", lw=3)\nfor d in dpred_1:\n    ax1.loglog(time_channels, -d, \"-o\", lw=1, markersize=4)\nax1.set_xlim((np.min(time_channels), np.max(time_channels)))\nax1.grid()\nax1.set_xlabel(\"time [s]\")\nax1.set_ylabel(\"-dB/dz [T/s]\")\nax1.set_title(\"Transient Response\")\nax1.legend([\"Analytic\"] + [\"dh = {} x d_min\".format(c) for c in size_factor])\nplt.show()\n\n","type":"content","url":"/fwd-tdem-fundamentals#results","position":25},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Part 2: Discretization in Time (off-time)"},"type":"lvl2","url":"/fwd-tdem-fundamentals#part-2-discretization-in-time-off-time","position":26},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Part 2: Discretization in Time (off-time)"},"content":"In SimPEG, time-stepping is currently carried out using \n\nBackward Euler. Backward Euler is used because 1) it is stable when stepping forward in time regardless of step-length, and 2) it only requires the storage of a single factorization of a matrix inverse for each unique step length. Here, we investigate the impact of time-step size on the accuracy of the forward simulation.\n\nWhen choosing a time-stepping scheme, our goals are to:\n\nMinimize the number of time-steps\n\nMinimize the number of unique step lengths\n\nAlthough smaller time-steps will reduce the error in the numerical forward simulation, a linear system must be solves at every time-step. Run-times can therefore become very large when the step-size is too small. Since the Earth’s TDEM response is characterized by a set of exponential decays, we can reduced the total number of time-steps by using smaller time-steps at early times and larger time-steps at later times. However, a linear system must be factored and stored for each unique time-step length. Not only does each factorization take significant time, it may require significant computer memory.\n\nStandard Approach: Assume the off-time begins at t = 0 s.\n\nConsider your earliest time channel. The minimum time-step length should be 5-10% of the earliest time channel. Use this step length until just after your first time channel.\n\nIncrease the time-step length by a factor of 3-6; any more and you will produce artifacts. Use this step length over the next decade of time channels.\n\nRepeat until you have at least 1 time step beyond your latest time channel.\n\nIf applied correctly, and you have time channels spanning N decades, this will result in N+1 unique step lengths. Our suggested approach generally strikes a reasonable balance between limiting the number of time-steps and the number of unique time-step lengths.\n\n","type":"content","url":"/fwd-tdem-fundamentals#part-2-discretization-in-time-off-time","position":27},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define Minimum Time-Step Lengths","lvl2":"Part 2: Discretization in Time (off-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#define-minimum-time-step-lengths","position":28},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define Minimum Time-Step Lengths","lvl2":"Part 2: Discretization in Time (off-time)"},"content":"To validate the standard approach, forward simulations are performed using various minimum time-step lengths. Where t_{min} is the earliest time channel, we test minimum time-step lengths of:\\Delta t_{min} = \\left \\{ \\frac{t_{min}}{5}, \\; \\frac{t_{min}}{10}, \\; \\frac{t_{min}}{20}, \\; \\frac{t_{min}}{40}, \\; \\frac{t_{min}}{80} \\right \\}\n\nAt each decade, we increase the time-step size by a factor of 5.\n\nt_min = time_channels.min()  # Earliest time channel\n\nsize_factor = [5, 10, 20, 40, 80]\ndt_min = [t_min / c for c in size_factor]  # minimum time-step lengths\n\n","type":"content","url":"/fwd-tdem-fundamentals#define-minimum-time-step-lengths","position":29},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Numerical Solution","lvl2":"Part 2: Discretization in Time (off-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#numerical-solution-1","position":30},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Numerical Solution","lvl2":"Part 2: Discretization in Time (off-time)"},"content":"Here, we perform the forward simulation for a set of minimum time-step lengths \\Delta t_{min} and store the predicted data in list dpred_2. In accordance with our findings in Part 1, we use a minimum cell size \\Delta h_{min} equal to the smallest diffusion distance d_{min}.\n\n# Store the predicted data and time steps\ndpred_2 = []\nsimulation_times = []\n\n# Define the mesh, model and mapping\nmesh, model, mapping = generate_discretization(d_min, d_min, d_max)\n\nfor dt in dt_min:\n    # Define the simulation\n    simulation = tdem.simulation.Simulation3DElectricField(\n        mesh,\n        survey=generate_survey(stepoff_waveform),\n        sigmaMap=mapping,\n    )\n\n    # Set the time steps\n    time_steps = [\n        (dt, int(1.05 * t_min / dt)),\n        (5 * dt, int(10 * t_min / (5 * dt) + 1)),\n        (25 * dt, int(100 * t_min / (25 * dt) + 1)),\n    ]\n    simulation.time_steps = time_steps\n\n    # Store the time steps\n    simulation_times.append(simulation.times[1:])\n\n    # Simulate the data\n    dpred_2.append(simulation.dpred(model))\n\n    print(\"N_TIMES: {}\".format(simulation.nT))\n\n","type":"content","url":"/fwd-tdem-fundamentals#numerical-solution-1","position":31},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Results","lvl2":"Part 2: Discretization in Time (off-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#results-1","position":32},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Results","lvl2":"Part 2: Discretization in Time (off-time)"},"content":"Below, we plot the time-steps used for each simulation and the predicted data. As we can see, a minimum time-step length smaller than \\dfrac{t_{min}}{20} is required to produce reasonable accuracy.\n\nfig = plt.figure(figsize=(12, 6))\n\nax1 = fig.add_axes([0.05, 0.1, 0.4, 0.85])\nfor ii, tvec in enumerate(simulation_times):\n    ax1.semilogx(tvec, ii * np.ones_like(tvec), \"|\", markersize=10)\nax1.set_yticklabels([])\nax1.set_title(\"Time Steps\")\nax1.grid()\n\nax2 = fig.add_axes([0.55, 0.1, 0.4, 0.85])\nax2.loglog(time_channels, -dtrue_stepoff, \"k\", lw=3)\nfor d in dpred_2:\n    ax2.loglog(time_channels, -d, \"-o\", lw=1, markersize=3)\nax2.set_xlim((np.min(time_channels), np.max(time_channels)))\nax2.grid()\nax2.set_xlabel(\"time [s]\")\nax2.set_ylabel(\"-dB/dz [T/s]\")\nax2.set_title(\"Transient Response\")\nax2.legend([\"Analytic\"] + [\"t_min / {}\".format(c) for c in size_factor])\nplt.show()\n\n","type":"content","url":"/fwd-tdem-fundamentals#results-1","position":33},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Part 3: Time-Discretization (on-time)"},"type":"lvl2","url":"/fwd-tdem-fundamentals#part-3-time-discretization-on-time","position":34},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl2":"Part 3: Time-Discretization (on-time)"},"content":"For purely academic exercises, we frequently simulate the Earth’s response to step-off excitation. This simulation assume the source current is constant for t \\leq 0, and therefore we do not need to define any time-discretization during the source’s on-time. In practice, controlled EM sources have time-dependent waveforms. And in order to accurately simulate the Earth’s response, we must define appropriate time-discretization during the on-time and the off-time.\n\nStandard Approach:\n\nThe level of time-discretization during the on-time depends primarily on the features of the waveform. Consider the following:\n\nPiecewise linear features: Because the time-derivative of a piecewise linear feature is constant, we generally only need a few time-steps over the length of the feature to obtain numerically accurate results when data are measured during the off-time. Therefore the ideal time-step length depends on the length of the piecewise linear feature; e.g. a slow ramp-off vs. a fast ramp-off.\n\nPiecewise parabolic, cubic, etc...: For these features, the ideal time-step length depends on the curvature (2nd derivative) of feature. Where the curvature is large, smaller time-steps are needed. The approach for time-discretization of these features is analogous to the spacing one would use when approximating an intergral with a Riemann sum.\n\nSome other general considerations:\n\nFor waveforms that do not contain short linear segments or have regions with large curvatures (e.g. triangular waveform, half-sine waveform), we simply discretize the waveform using the largest time-step length used during the off-time. This provides sufficient time-discretization while avoiding additional factorizations of linear systems.\n\ntime-discretization near the beginning of the waveform has less of an impact on the simulated data as time-discretization just before the off-time. This is due to the nature of the Earth’s EM impulse response. So we can use coarser time-steps to discretize the waveform at the beginning of the on-time.\n\n","type":"content","url":"/fwd-tdem-fundamentals#part-3-time-discretization-on-time","position":35},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Defining the On-Time and Its Time-Steps","lvl2":"Part 3: Time-Discretization (on-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#defining-the-on-time-and-its-time-steps","position":36},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Defining the On-Time and Its Time-Steps","lvl2":"Part 3: Time-Discretization (on-time)"},"content":"For the tutorial example, the on-time for the current waveform begins at -1e-3 s and ends at 0 s. And data are simulated during the off-times at a logarithmically-spaced set of time channels between 1e-5 s and 1e-3 s. As a result, we must define a time-discretization for the simulation from the start of the on-time to the latest time channel.\n\nHere, we define the start of the on-time for the waveform, which is also the initial time for the TDEM simulation. Where t_0 defines the start of the on-time, we test time-step lengths of:\\Delta t_{on} = \\left \\{ \\frac{|t_{0}|}{10}, \\; \\frac{|t_{0}|}{20}, \\; \\frac{|t_{0}|}{40}, \\; \\frac{|t_{0}|}{80}, \\; \\frac{|t_{0}|}{160} \\right \\}\n\nfor the on-time step lengths.\n\nt0 = -1e-3  # Start of the on-time\n\nn_on_time_steps = [10, 20, 40, 80, 160]\non_time_steps_list = [(np.abs(t0) / n, n) for n in n_on_time_steps]\n\nHere, we define the time-step lengths for the off-times (t > 0 s). From results shown in Part 2, we have chosen a minimum time-step size for the off-time equal to 5% of the earliest time channel.\n\noff_time_steps = [(5e-07, 40), (2.5e-06, 40), (1.25e-05, 81)]\n\n","type":"content","url":"/fwd-tdem-fundamentals#defining-the-on-time-and-its-time-steps","position":37},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Defining the Waveforms","lvl2":"Part 3: Time-Discretization (on-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#defining-the-waveforms","position":38},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Defining the Waveforms","lvl2":"Part 3: Time-Discretization (on-time)"},"content":"Here, we define the waveforms that will be used to simulate data in this part of the tutorial. They are a:\n\ntriangular waveform with a peak current amplitude at -0.0005 s.\n\ntrapezoidal waveform with a linear ramp-on and a linear ramp-off that each lasts 2.5e-5 s.\n\ntriangular_waveform = tdem.sources.TriangularWaveform(\n    start_time=t0, peak_time=t0 / 2, off_time=0.0\n)\n\nramp_time = np.abs(t0) / 40\ntrapezoidal_waveform = tdem.sources.TrapezoidWaveform(\n    (t0, t0 + ramp_time), (-ramp_time, 0.0), off_time=0.0\n)\n\nfig = plt.figure(figsize=(10, 4))\n\nax1 = fig.add_axes([0.05, 0.1, 0.4, 0.85])\nfor ii in range(len(on_time_steps_list)):\n    t_mesh = TensorMesh([[on_time_steps_list[ii]]], origin=np.array([t0]))\n    ax1.plot(t_mesh.nodes_x, ii * np.ones_like(t_mesh.nodes_x), \"|\", markersize=10)\n\nax1.set_xticks([-1e-3, -5e-4, 0])\nax1.set_ylim([-0.5, 10])\nax1.set_yticklabels([])\nax1.set_xlabel(\"Times [s]\")\nax1.set_title(\"Time-Steps (on-times)\")\nax1.legend([\"dt = {} s\".format(x[0]) for x in on_time_steps_list], loc=\"upper left\")\nax1.grid()\n\nplotting_times = np.r_[t_mesh.nodes_x, simulation_times[0]]\nax2 = fig.add_axes([0.55, 0.1, 0.4, 0.85])\nax2.plot(plotting_times, [triangular_waveform.eval(t) for t in plotting_times], \"k-\")\nax2.plot(plotting_times, [trapezoidal_waveform.eval(t) for t in plotting_times], \"k--\")\nax2.set_xticks([-1e-3, 0, 1e-3])\nax2.set_xlabel(\"Times [s]\")\nax2.set_ylabel(\"Current [A]\")\nax2.set_title(\"Waveforms\")\nax2.grid()\nax2.legend([\"Triangular\", \"Trapezoidal\"], loc=\"upper right\")\n\nplt.show()\n\n","type":"content","url":"/fwd-tdem-fundamentals#defining-the-waveforms","position":39},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define the Mesh, Model and Mapping","lvl2":"Part 3: Time-Discretization (on-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#define-the-mesh-model-and-mapping","position":40},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Define the Mesh, Model and Mapping","lvl2":"Part 3: Time-Discretization (on-time)"},"content":"Because the spatial discretization of the problem is consistent for all simulations, the mesh, model and mapping only needs to be generated once. Here, we generate a mesh according to results in Part 1, where the minimum cell size is equal to the minimum diffusion distance.\n\nmesh, model, mapping = generate_discretization(d_min, d_min, d_max)\n\n","type":"content","url":"/fwd-tdem-fundamentals#define-the-mesh-model-and-mapping","position":41},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Simulation for a Triangular Waveform","lvl2":"Part 3: Time-Discretization (on-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#simulation-for-a-triangular-waveform","position":42},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Simulation for a Triangular Waveform","lvl2":"Part 3: Time-Discretization (on-time)"},"content":"Here, we simulate the data for a triangular waveform.\n\nsimulation_temp = tdem.simulation_1d.Simulation1DLayered(\n    survey=generate_survey(triangular_waveform),\n    thicknesses=[],\n    sigmaMap=maps.IdentityMap(nP=1),\n)\n\ndpred_triangular = [simulation_temp.dpred(np.array([halfspace_conductivity]))]\n\nfor w in on_time_steps_list:\n    full_time_steps = [w] + off_time_steps\n\n    simulation_temp = tdem.simulation.Simulation3DElectricField(\n        mesh,\n        survey=generate_survey(triangular_waveform),\n        sigmaMap=mapping,\n        time_steps=full_time_steps,\n        t0=t0,\n    )\n\n    dpred_triangular.append(simulation_temp.dpred(model))\n\n","type":"content","url":"/fwd-tdem-fundamentals#simulation-for-a-triangular-waveform","position":43},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Simulation for a Trapezoidal Waveform","lvl2":"Part 3: Time-Discretization (on-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#simulation-for-a-trapezoidal-waveform","position":44},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Simulation for a Trapezoidal Waveform","lvl2":"Part 3: Time-Discretization (on-time)"},"content":"Here, we simulate the data for the trapezoidal waveform.\n\nsimulation_temp = tdem.simulation_1d.Simulation1DLayered(\n    survey=generate_survey(trapezoidal_waveform),\n    thicknesses=[],\n    sigmaMap=maps.IdentityMap(nP=1),\n)\n\ndpred_trapezoidal = [simulation_temp.dpred(np.array([halfspace_conductivity]))]\n\nfor w in on_time_steps_list:\n    full_time_steps = [w] + off_time_steps\n\n    simulation_temp = tdem.simulation.Simulation3DElectricField(\n        mesh,\n        survey=generate_survey(trapezoidal_waveform),\n        sigmaMap=mapping,\n        time_steps=full_time_steps,\n        t0=t0,\n    )\n\n    dpred_trapezoidal.append(simulation_temp.dpred(model))\n\n","type":"content","url":"/fwd-tdem-fundamentals#simulation-for-a-trapezoidal-waveform","position":45},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Results","lvl2":"Part 3: Time-Discretization (on-time)"},"type":"lvl3","url":"/fwd-tdem-fundamentals#results-2","position":46},{"hierarchy":{"lvl1":"Fundamentals of Finite Volume for TDEM Simulations","lvl3":"Results","lvl2":"Part 3: Time-Discretization (on-time)"},"content":"Because all of the on-time step lengths we tested were sufficiently smaller than the piecewise linear segments comprising the triangular waveform, all of the on-time step lengths we tested produced accurate results. For the trapezoidal waveform however, the time-step length needed to be several times smaller than the length of the ramp-off (2.5e-5 s) in order to produce numerically accurate results.\n\nfig = plt.figure(figsize=(12, 6))\n\nax1 = fig.add_axes([0.05, 0.1, 0.4, 0.85])\nax1.loglog(time_channels, -dpred_triangular[0], \"k\", lw=3)\nfor d in dpred_triangular[1:]:\n    ax1.loglog(time_channels, -d, \"-o\", lw=1, markersize=4)\nax1.set_xlim((np.min(time_channels), np.max(time_channels)))\nax1.grid()\nax1.set_xlabel(\"time [s]\")\nax1.set_ylabel(\"-dB/dz [T/s]\")\nax1.set_title(\"Triangular Waveform\")\nax1.legend(\n    [\"Analytic\"] + [\"dt = {} s\".format(x[0]) for x in on_time_steps_list],\n    loc=\"upper right\",\n)\n\nax2 = fig.add_axes([0.55, 0.1, 0.4, 0.85])\nax2.loglog(time_channels, -dpred_trapezoidal[0], \"k\", lw=3)\nfor d in dpred_trapezoidal[1:]:\n    ax2.loglog(time_channels, -d, \"-o\", lw=1, markersize=4)\nax2.set_xlim((np.min(time_channels), np.max(time_channels)))\nax2.grid()\nax2.set_xlabel(\"time [s]\")\nax2.set_ylabel(\"-dB/dz [T/s]\")\nax2.set_title(\"Trapezoidal Waveform\")\nax2.legend(\n    [\"Analytic\"] + [\"dt = {} s\".format(x[0]) for x in on_time_steps_list],\n    loc=\"upper right\",\n)\n\nplt.show()","type":"content","url":"/fwd-tdem-fundamentals#results-2","position":47},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data"},"type":"lvl1","url":"/fwd-utem-3d","position":0},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nMedium-weight notebook\n\nRequires moderate computational resources. Run-times may exceed several minutes and require up to 8 GB of available RAM.\n\nPrerequisite Tutorials\n\n1D Forward Simulation for a Single Sounding\n\nFundamentals of Finite Volume for TDEM Simulations\n\nKeywords: UTEM, forward simulation, large current loop, on-time db/dt data.\n\nSummary: In this tutorial, we present the fundamentals of simulating on-time large-loop TDEM data in 3D for a user-defined waveform. In this case, the data are simulated for a UTEM system. Please work through any prerequisite tutorials before working through this one. Functionality used to simulate the data is imported from the \n\nsimpeg​.electromagnetics​.time​_domain module.\n\nLearning Objectives:\n\nDesigning appropriates meshes for 3D large-loop TDEM simulation.\n\nSimulating TDEM data for user-defined waveforms.\n\nSimulating on-time db/dt data.\n\nPlotting data collected during the on-time.\n\n","type":"content","url":"/fwd-utem-3d","position":1},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Importing Modules"},"type":"lvl2","url":"/fwd-utem-3d#importing-modules","position":2},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Importing Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise. All of the functionality specific to TDEM is imported from \n\nsimpeg​.electromagnetics​.time​_domain.\nWe also import some useful utility functions from \n\nsimpeg.utils.\n\n# SimPEG functionality\nimport simpeg.electromagnetics.time_domain as tdem\nfrom simpeg import maps\nfrom simpeg.utils import plot2Ddata\n\n# discretize functionality\nfrom discretize import TreeMesh\nfrom discretize.utils import mkvc, ndgrid, active_from_xyz\n\n# Common Python functionality\nimport numpy as np\nfrom scipy.spatial import Delaunay\nfrom scipy.interpolate import LinearNDInterpolator\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\n\nmpl.rcParams.update({\"font.size\": 14})\n\nwrite_output = False  # Optional\n\n","type":"content","url":"/fwd-utem-3d#importing-modules","position":3},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define the Topography"},"type":"lvl2","url":"/fwd-utem-3d#define-the-topography","position":4},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define the Topography"},"content":"Surface topography is defined as an (N, 3) \n\nnumpy.ndarray for 3D simulations.\nHere, we create basic topography for the forward simulation. For user-specific simulations, you may load topography from an XYZ file.\n\n# Generate some topography\nx_topo, y_topo = np.meshgrid(\n    np.linspace(-2100, 2100, 141), np.linspace(-2100, 2100, 141)\n)\nz_topo = 400.0 + 200.0 * (1 / np.pi) * (\n    np.arctan((x_topo - 500 * np.sin(np.pi * y_topo / 2800) - 1000.0) / 300.0)\n    - np.arctan((x_topo - 500 * np.sin(np.pi * y_topo / 2800) + 1000.0) / 300.0)\n)\n\n# Turn into a (N, 3) numpy.ndarray\nx_topo, y_topo, z_topo = mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)\ntopo_xyz = np.c_[mkvc(x_topo), mkvc(y_topo), mkvc(z_topo)]\n\n# Plot the topography\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8], projection=\"3d\")\nax.set_zlim([-400, 400])\nax.scatter3D(topo_xyz[:, 0], topo_xyz[:, 1], topo_xyz[:, 2], s=0.25, c=\"b\")\nax.set_box_aspect(aspect=None, zoom=0.85)\nax.set_xlabel(\"X (m)\", labelpad=10)\nax.set_ylabel(\"Y (m)\", labelpad=10)\nax.set_zlabel(\"Z (m)\", labelpad=10)\nax.set_title(\"Topography (Exaggerated z-axis)\", fontsize=16, pad=-20)\nax.view_init(elev=45.0, azim=-125)\n\n","type":"content","url":"/fwd-utem-3d#define-the-topography","position":5},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Defining the (UTEM) Survey"},"type":"lvl2","url":"/fwd-utem-3d#defining-the-utem-survey","position":6},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Defining the (UTEM) Survey"},"content":"The approach for defining TDEM surveys in SimPEG was presented in the \n\n1D Forward Simulation for a Single Sounding tutorial. Just like in the 1D case, we must define and connect the following SimPEG objects:\n\nreceiver\n\nwaveforms\n\nsources\n\nto a survey object. Unlike in the 1D simulation, sources and receivers can be located either above or below the Earth’s surface. For a full list of source types, waveform types and receiver types, please visit API documentation for \n\nsimpeg​.electromagnetics​.time​_domain.\n\nFor this tutorial, we simulate University of Toronto electromagnetic (UTEM) data for a single transmitter loop. Some basic information regarding UTEM survey geometry and its data can be found \n\nhere. The transmitter loop is square with a side length of 1400 m. And the period of the waveform is 1 s. db/dt sensors located within the loop are used to measure 3-component data for a highly-regulated triangular waveform with a 100% duty cycle.\n\n# WAVEFORM PROPERTIES\nperiod = 1.0  # Period\nI_max = 1.0  # Maximum current amplitude\n\n# TRANSMITTER LOOP PROPERTIES\nloop_width = 1400\n\n# RECEIVER LOCATIONS\nds = 125.0\ns_min = -562.5\ns_max = 562.5\nreceiver_height = 1.0\n\n# TIME CHANNELS\ntime_channels = 0.25 * period * 2 ** np.linspace(-7, 0, 8)\n\n","type":"content","url":"/fwd-utem-3d#defining-the-utem-survey","position":7},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Defining the Waveform","lvl2":"Defining the (UTEM) Survey"},"type":"lvl3","url":"/fwd-utem-3d#defining-the-waveform","position":8},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Defining the Waveform","lvl2":"Defining the (UTEM) Survey"},"content":"A waveform object must the must be assigned to every TDEM source object in the survey. The waveform object defines time-dependent current in the source. The same waveform object can be assigned to multiple source objects if they all use the same waveform. However in practice, surveys that collect data for multiple loops simultaneously will use waveforms with different operating frequencies. Scroll down to the Waveforms section of the \n\nsimpeg​.electromagnetics​.static​.time​_domain module to see the different waveforms that can be defined within SimPEG.\n\nHere, we use the \n\nBaseWaveform class to define a custom waveform. Instatiation of this class requires we define a function handle that returns the current at any time between the initial time for the simulation t_0 and the latest time channel t_{max}. Because the waveform uses a 100% duty cycle, the off-time for the waveform is set after the latest time channel.\n\n# Slope of the triangular waveform\nslope = 4 / period\n\n\n# Function handle\ndef wave_fun(t):\n    ta, tb = -0.5 * period, 0.0\n    w = (\n        np.heaviside(ta - t, 0.5) * (slope * t + 3.0 * I_max)\n        + np.heaviside(t - ta, 0.5) * np.heaviside(tb - t, 0.5) * (-slope * t - I_max)\n        + np.heaviside(t - tb, 0.5) * (slope * t - I_max)\n    )\n    return w\n\n\n# Define the waveform\ngeneral_waveform = tdem.sources.RawWaveform(\n    off_time=period / 2, waveform_function=wave_fun\n)\n\nWhere T is the period of the waveform, we plot the waveform from [-3T/4, T/2] as well as the time channels. In fact, this is the range of times [t_0, t_{max}] over which the TDEM simulation is computed. When designing waveforms, the user should be aware that:\n\nThe current is static and equal to I(t_0) = I_0 at times earlier than t_0; i.e. I(t \\leq t_0) = I_0.\n\nWhen I(t_0) \\neq 0, a static problem may need to be solved analytically or numerically to compute the fields at t_0 for the simulation.\n\nAs such, we generally like to define the current waveform and initial time such that I(t_0) = 0 and all fields are 0.\n\nHere, we assume the current at t < -3T/4 has a neglible impact on the simulated data. However, one could define the simulation over a larger range of times if they feel this isn’t the case.\n\nfig = plt.figure(figsize=(8, 4))\n\nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.85])\nplot_times = np.linspace(-3 * period / 4, period / 2.0, 26)\nax1.plot(plot_times, wave_fun(plot_times), \"b\")\nax1.plot(time_channels, wave_fun(time_channels), \"ro\")\nax1.grid()\nax1.set_xlabel(\"Times [s]\")\nax1.set_ylabel(\"Current [A]\")\nax1.set_title(\"Current Waveform\")\n\nplt.show()\n\n","type":"content","url":"/fwd-utem-3d#defining-the-waveform","position":9},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Defining the Source, Receivers and Survey","lvl2":"Defining the (UTEM) Survey"},"type":"lvl3","url":"/fwd-utem-3d#defining-the-source-receivers-and-survey","position":10},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Defining the Source, Receivers and Survey","lvl2":"Defining the (UTEM) Survey"},"content":"We start by defining an interpolation function that will output the elevation for any horizontal position within the topography. Warning: if you load the wire path and receiver locations, do not reassign the elevation by interpolating with the topography function.\n\ntopo_interp = LinearNDInterpolator(np.c_[x_topo, y_topo], z_topo)\n\nNext, we define the nodes for the loop source(s). Sources can be inductive or galvanic. For real-world cases, GPS measurements are used to define the wire path. This is necessary when the analytic primary field of the source loop must be calculated. Here, we define a square source loop with points every 20 m. Our interpolation function is used to assign the elevations.\n\nhalf_width = 0.5 * loop_width\nu = np.arange(-half_width, half_width, 50.0)\nv = half_width * np.ones_like(u)\n\nxtx = np.r_[u, v, -u, -v, -half_width]\nytx = np.r_[-v, u, v, -u, -half_width]\nztx = topo_interp(np.c_[xtx, ytx])\nxyz_loop = np.c_[xtx, ytx, ztx]\n\nHere, we define the receiver locations for each loop source.\n\nreceiver_locations = ndgrid(\n    np.arange(s_min, s_max + 1, ds),\n    np.arange(s_min, s_max + 1, ds),\n)\nreceiver_locations = np.c_[receiver_locations, topo_interp(receiver_locations)]\n\nFor each source, we define the associated receivers list. Separate receivers must be defined for each orientation, however multiple times and locations can be defined within a single receiver object. Both the receivers and waveform are assigned to the source object. The list of sources is then used to define the survey object. We use the \n\nPointMagneticFluxTimeDerivative class to measure 3-component dB/dt data for a triangular waveform. And we use the \n\nLineCurrent to define our wire path.\n\nreceivers_list = [\n    tdem.receivers.PointMagneticFluxTimeDerivative(receiver_locations, time_channels, s)\n    for s in [\"x\", \"y\", \"z\"]\n]\n\n\nsource_list = [\n    tdem.sources.LineCurrent(\n        receivers_list, location=xyz_loop, waveform=general_waveform\n    )\n]\n\nsurvey = tdem.Survey(source_list)\n\nBelow, we plot the source loop and receiver locations.\n\nfig = plt.figure(figsize=(5, 5))\nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.8])\nax1.plot(xyz_loop[:, 0], xyz_loop[:, 1], \"r-o\", lw=1, markersize=2)\nax1.scatter(receiver_locations[:, 0], receiver_locations[:, 1], 8, \"b\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\nax1.set_title(\"Survey Geometry\")\nplt.show(ax1)\n\n","type":"content","url":"/fwd-utem-3d#defining-the-source-receivers-and-survey","position":11},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define Subsurface Structures"},"type":"lvl2","url":"/fwd-utem-3d#define-subsurface-structures","position":12},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define Subsurface Structures"},"content":"Meshes for TDEM simulation depend on both the survey geometry and the Earth’s electrical conductivity. Near controlled sources, EM fields vary rapidly, and smaller cells are needed to model the physics accurately. The propagation and diffusion of EM waves depends on the subsurface conductivity. EM waves propagate and diffuse more slowly in conductive regions. As a result, smaller cells must be used when the overall conductivity of the Earth is higher or when observation times are earlier. As a result, we need to take a step back and consider the full geometry of the geophysical scenario we intend to simulate.\n\nHere, we define the geometries and conductivities of subsurface structures. We then compute the diffusion distance for those structures over the time channels in which we measure data. In this case, we simulate data for a dipping rectangular slab with a side length of 500 m, a thickness of 130 m, and a conductivity of 0.5 S/m. The slab is striking at 0 degrees and dipping at 30 degrees. The host has a conductivity of 0.001 S/m.\n\nair_conductivity = 1e-8\nhost_conductivity = 0.001\nslab_conductivity = 0.5\n\nslab_width = 500.0\nslab_thickness = 130.0\nslab_center = np.c_[0.0, 0.0, z_topo.min() - 225]\nslab_strike = 0.0\nslab_dip = 30.0\n\nhost_diffusion_distance = 1260 * np.sqrt(time_channels / host_conductivity)\nprint(\"HOST: {}\".format(host_diffusion_distance))\nslab_diffusion_distance = 1260 * np.sqrt(time_channels / slab_conductivity)\nprint(\"SLAB: {}\".format(slab_diffusion_distance))\n\n","type":"content","url":"/fwd-utem-3d#define-subsurface-structures","position":13},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Design a (Tree) Mesh"},"type":"lvl2","url":"/fwd-utem-3d#design-a-tree-mesh","position":14},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Design a (Tree) Mesh"},"content":"Standard approach for TDEM: The standard approach presented in the \n\nFundamentals of Finite Volume for TDEM Simulations tutorial is applied here. Because 3D simulations require discretization along three directions, the number of cells in the mesh is proportional h^{-3}; where h is the minimum cell edge length. As a result, we may need to consider limitations in computational resources which are not encountered for problems in lower dimensions.\n\nTutorial mesh: Here, a minimum cell width of 25 m is used within our survey region in order to reasonably discretize the conductive slab. This is a little less than 1/3 of the smallest diffusion distance for our conductive slab. So the error in the slab’s response at the earliest time channel(s) may be a little larger than we would like. Because the host is resistive and its inductive response is small compared to the slab, we can increase the cell size fairly rapidly outside our core region. The largest diffusion distance is ~20,000 m. So the width of the padding region was set to 40,000 m in all directions.\n\ndh = 25.0\nL = 80000.0\nnbc = 2 ** int(np.round(np.log(L / dh) / np.log(2.0)))\nh = [(dh, nbc)]\nmesh = TreeMesh([h, h, h], origin=\"CCC\", diagonal_balance=True)\n\n# Shift vertically to top same as maximum topography\nmesh.origin += np.r_[0.0, 0.0, z_topo.min()]\n\nHere, we use the \n\nrefine_points method to discretize along the wire path. In our case, the source loop’s path has been sufficiently sampled. However if the lengths of individual wire segments are too long relative to the minimum cell size and level of discretization, we may not discrete sufficient along certain portions of the wire.\n\nIn cases where the host is more conductive, we may want to pad out from the loop more gradually, as we would expect significant EM induction near the wire at our observation times. In this case, the host is quite resistive and the induced currents in the host are far away from the wire by our first time channel.\n\n# Number of segments\nn_seg = np.shape(xyz_loop)[0] - 1\n\n# Sampling (points be segment)\nn_pts_per_seg = 20\n\npts = [\n    np.c_[\n        np.linspace(xyz_loop[ii, 0], xyz_loop[ii + 1, 0], n_pts_per_seg),\n        np.linspace(xyz_loop[ii, 1], xyz_loop[ii + 1, 1], n_pts_per_seg),\n        np.linspace(xyz_loop[ii, 2], xyz_loop[ii + 1, 2], n_pts_per_seg),\n    ]\n    for ii in range(n_seg)\n]\n\npts = np.vstack(pts)\n\nmesh.refine_points(pts, level=-1, padding_cells_by_level=[2, 2, 2, 2], finalize=False)\n\nHere, we use the \n\nrefine_bounding_box method to define the discretization in the region our slab lives.\n\npts = ndgrid(\n    np.r_[-600, 600], np.r_[-600, 600], np.r_[z_topo.min() - 400, z_topo.min() + 50]\n)\n\nmesh.refine_bounding_box(pts, -1, padding_cells_by_level=[2, 4, 4], finalize=False)\n\nUsing the \n\nrefine_surface method, we refine the tree mesh where there is significant topography. We do this to a sufficient distance from the survey in order to avoid a large number of unnecessary fine cells in the padding.\n\ninds = (np.abs(topo_xyz[:, 0]) < 1500.0) & (np.abs(topo_xyz[:, 1]) < 1500.0)\n\nmesh.refine_surface(\n    topo_xyz[inds, :], -2, padding_cells_by_level=[1, 2], finalize=False\n)\n\nmesh.finalize()\n\n","type":"content","url":"/fwd-utem-3d#design-a-tree-mesh","position":15},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define the Active Cells"},"type":"lvl2","url":"/fwd-utem-3d#define-the-active-cells","position":16},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define the Active Cells"},"content":"Whereas cells below the Earth’s surface contribute towards the simulated magnetic anomaly, air cells do not.\nThe set of mesh cells used in the forward simulation are referred to as ‘active cells’. Unused cells (air cells) are ‘inactive cells’. Here, the discretize \n\nactive_from_xyz utility function is used to find the indices of the active cells using the mesh and surface topography. The output quantity is a bool array.\n\n# Indices of the active mesh cells from topography (e.g. cells below surface)\nactive_cells = active_from_xyz(mesh, topo_xyz)\n\n# Number of active cells\nn_active = np.sum(active_cells)\n\n","type":"content","url":"/fwd-utem-3d#define-the-active-cells","position":17},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Models and Mappings"},"type":"lvl2","url":"/fwd-utem-3d#models-and-mappings","position":18},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Models and Mappings"},"content":"Here, we define the model that characterizes the Earth’s electrical conductivity/resistivity and the mapping that connects the model to the physical property values used in TDEM simulations. In the Define Subsurface Structures section of this exercise, we described the geophysical scenario as a dipping conductive slab within a more resistive host.\n\n","type":"content","url":"/fwd-utem-3d#models-and-mappings","position":19},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Finding the Cells within the Slab","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-utem-3d#finding-the-cells-within-the-slab","position":20},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Finding the Cells within the Slab","lvl2":"Models and Mappings"},"content":"We start by defining the corner locations for a horizontal slab centered at (0,0,0). An appropriate rotation operation is then applied to those points according to the strike and dip of the slab. Next, we shift the points so the center of the slab is at the specified location. Using Delauny interpolation, we find the indices of the mesh cells that lie inside the convex hull created by the set of rotated and shifted points.\n\n# Horizontal slab centered at (0, 0, 0)\nxyz_slab = ndgrid(\n    np.r_[-slab_width / 2, slab_width / 2],\n    np.r_[-slab_width / 2, slab_width / 2],\n    np.r_[-slab_thickness / 2, slab_thickness / 2],\n)\n\n# y-axis rotation\nTHETA = slab_dip * np.pi / 180\nAy = np.r_[\n    np.c_[np.cos(THETA), 0.0, -np.sin(THETA)],\n    np.c_[0.0, 1.0, 0.0],\n    np.c_[np.sin(THETA), 0.0, np.cos(THETA)],\n]\n\n# z-axis rotation\nPHI = slab_strike * np.pi / 180\nAz = np.r_[\n    np.c_[np.cos(PHI), -np.sin(PHI), 0.0],\n    np.c_[np.sin(PHI), np.cos(PHI), 0.0],\n    np.c_[0.0, 0.0, 1.0],\n]\n\n# Define the rotation matrix\nA = np.dot(Ay, Az)\n\n# Apply the rotation\nxyz_slab = np.dot(xyz_slab, A)\n\n# Shift downward\nxyz_slab = xyz_slab + slab_center\n\ndef indices_from_polygon(poly_pts, xyzc):\n    delaunay_object = Delaunay(poly_pts)  # Make a Delaunay interpolation object\n    k = (\n        delaunay_object.find_simplex(xyzc) >= 0\n    )  # Figure out which RTF data locations are within the Delaunay simplex\n    return k\n\n","type":"content","url":"/fwd-utem-3d#finding-the-cells-within-the-slab","position":21},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Defining the Model","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-utem-3d#defining-the-model","position":22},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Defining the Model","lvl2":"Models and Mappings"},"content":"Here we define our model; i.e. the conductivities on all active cells.\n\n# Define host conductivity on all active cells\nconductivity_model = host_conductivity * np.ones(n_active)\n\n# Assign all cells in slab to slab conductivity\nind_slab = indices_from_polygon(xyz_slab, mesh.cell_centers[active_cells, :])\nconductivity_model[ind_slab] = slab_conductivity\n\n","type":"content","url":"/fwd-utem-3d#defining-the-model","position":23},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Plot the Model","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-utem-3d#plot-the-model","position":24},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Plot the Model","lvl2":"Models and Mappings"},"content":"Here, we plot our conductivity model.\n\n# Generate a mapping to ignore inactice cells in plot\nplotting_map = maps.InjectActiveCells(mesh, active_cells, np.nan)\n\nfig = plt.figure(figsize=(10, 4.5))\n\nnorm = LogNorm(vmin=conductivity_model.min(), vmax=conductivity_model.max())\n\nax1 = fig.add_axes([0.15, 0.15, 0.68, 0.75])\nmesh.plot_slice(\n    plotting_map * conductivity_model,\n    ax=ax1,\n    normal=\"Y\",\n    ind=int(len(mesh.h[1]) / 2),\n    grid=True,\n    pcolor_opts={\"cmap\": mpl.cm.plasma, \"norm\": norm},\n)\nax1.set_title(\"Conductivity Model\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"z (m)\")\nax1.set_xlim([-1600, 1600])\nax1.set_ylim([z_topo.max() - 1600, z_topo.max()])\n\nax2 = fig.add_axes([0.84, 0.15, 0.03, 0.75])\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, cmap=mpl.cm.plasma, norm=norm, orientation=\"vertical\"\n)\ncbar.set_label(r\"$\\sigma$ [S/m]\", rotation=270, labelpad=15, size=16)\n\n","type":"content","url":"/fwd-utem-3d#plot-the-model","position":25},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Mapping from the Model to the Mesh","lvl2":"Models and Mappings"},"type":"lvl3","url":"/fwd-utem-3d#mapping-from-the-model-to-the-mesh","position":26},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Mapping from the Model to the Mesh","lvl2":"Models and Mappings"},"content":"Here, we use the \n\nsimpeg​.maps​.InjectActiveCells mapping. This mapping projects quantities defined on the active cells to the entire mesh, and sets a constant value for all inactive cells. Important: we set all inactive (air) cells to 1e-8 S/m instead of 0. This is done to ensure that the linear system constructed to solve the PDE for the TDEM problem is well-conditioned. If working with resistivity, we would set all inactive (air) cells to 1e8 \\Omega m instead of \\infty.\n\nconductivity_map = maps.InjectActiveCells(mesh, active_cells, air_conductivity)\n\n","type":"content","url":"/fwd-utem-3d#mapping-from-the-model-to-the-mesh","position":27},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Time Discretization"},"type":"lvl2","url":"/fwd-utem-3d#time-discretization","position":28},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Time Discretization"},"content":"Numerical solutions to time-dependent partial differential equations frequently require discretization in both space (i.e. the mesh) and time. The standard approach for defining the time-stepping was covered in the \n\nFundamentals of Finite Volume for TDEM Simulations tutorial.\n\nFor the tutorial example: Where T is the period of the waveform, the time-step length at t < 0 was equal to \\dfrac{T}{60}. Up to the first time channel t_{min}, a step size of \\dfrac{t_{min}}{20} was used. The step length was increased by a factor of 6 each time. This resulted in 4 unique time-step lengths.\n\nn_steps = 20\nmin_dt = time_channels[0] / 20.0\nmin_dt = round(min_dt, 1 - int(np.floor(np.log10(min_dt))) - 1)\n\ntc_min = np.min(time_channels)\ntc_max = np.max(time_channels)\nti = [None, tc_min, 6 * tc_min, 36 * tc_min]\ndt = [period / 60, min_dt, 6 * min_dt, 36 * min_dt]\n\nwave_times = np.arange(-0.75 * period, 0, dt[0])\n\nwave_times = np.r_[wave_times, np.arange(0, ti[1] + dt[1], dt[1])]\nwave_times = np.r_[wave_times, np.arange(wave_times[-1] + dt[2], ti[2] + dt[2], dt[2])]\nwave_times = np.r_[wave_times, np.arange(wave_times[-1] + dt[3], ti[3] + dt[3], dt[3])]\nwave_times = np.r_[\n    wave_times, np.arange(wave_times[-1] + dt[0], tc_max + 2 * dt[0], dt[0])\n]\n\nfig = plt.figure(figsize=(14, 4))\n\nax1 = fig.add_axes([0.1, 0.1, 0.5, 0.85])\nax1.plot(wave_times, wave_fun(wave_times), \"b-o\", markersize=3)\nax1.plot(time_channels, wave_fun(time_channels), \"ro\", markersize=5)\nax1.grid()\nax1.set_xlabel(\"Times [s]\")\nax1.set_ylabel(\"Current [A]\")\nax1.set_title(\"Full Waveform\")\n\nax2 = fig.add_axes([0.7, 0.1, 0.3, 0.85])\nplot_times = np.logspace(np.log10(time_channels.min()), np.log10(time_channels.max()))\nk = wave_times > 0.0\nax2.semilogx(wave_times[k], wave_fun(wave_times[k]), \"b-o\", markersize=3)\nax2.semilogx(time_channels, wave_fun(time_channels), \"ro\", markersize=5)\nax2.grid()\nax2.set_xlabel(\"Times [s]\")\nax2.set_ylabel(\"Current [A]\")\nax2.set_title(\"t>0 Discretization\")\n\nplt.show()\n\n","type":"content","url":"/fwd-utem-3d#time-discretization","position":29},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define the Simulation"},"type":"lvl2","url":"/fwd-utem-3d#define-the-simulation","position":30},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Define the Simulation"},"content":"Here we define the formulation for solving Maxwell’s equations. For the tutorial example:\n\nour source is a line current, and\n\nour receivers are measuring the time-derivative of the magnetic flux density\n\nAs a result, the \n\nSimulation3DElectricField class is best-suited for the forward simulation. This is because line current sources are naturally discretized to mesh edges, and db/dt can be easily obtained from the electric field solution. For different source and receiver types, another simulation class may be better suited.\n\ntime_steps = np.diff(wave_times)  # Time steps\nt0 = wave_times[0]  # Initial time for the simulation\n\nsimulation = tdem.simulation.Simulation3DElectricField(\n    mesh, survey=survey, sigmaMap=conductivity_map\n)\nsimulation.time_steps = time_steps\nsimulation.t0 = t0\n\n","type":"content","url":"/fwd-utem-3d#define-the-simulation","position":31},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Predict Data"},"type":"lvl2","url":"/fwd-utem-3d#predict-data","position":32},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Predict Data"},"content":"Like any other simulation object within SimPEG, we use the \n\ndpred method to predict data for the model provided.\n\ndpred = simulation.dpred(conductivity_model)\n\nThe data predicted in the previous cell are total field data; i.e. they contain both the primary field and the Earth’s response. Because the amplitude of the primary field is generally orders of magnitude larger than the Earth’s response, it can be extremely difficult to interpret the data by analyzing total field data. Here, the numerical primary field is simulated so that we can use it later to remove the primary signal from the simulated data.\n\nWhy not just compute the primary field analytically? Well, the numerical error associated with the primary field can be even larger than the Earth’s response. Removing a numerical primary field simulated on the same mesh effectively “cancels out” these errors. You will see artifacts in any secondary field data that match the shape of your transmitter if the primary field is not removed correctly.\n\nvacuum_model = air_conductivity * np.ones_like(conductivity_model)\ndpred0 = simulation.dpred(vacuum_model)\n\n","type":"content","url":"/fwd-utem-3d#predict-data","position":33},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Ploting Primary-Reduced Data"},"type":"lvl2","url":"/fwd-utem-3d#ploting-primary-reduced-data","position":34},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl2":"Ploting Primary-Reduced Data"},"content":"There are several commonly used conventions for plotting UTEM data; \n\nsee here. One such convention is primary reduced data:100 \\% \\, \\times \\, \\frac{\\vec{b}_{total} - \\vec{b}_0}{\\big | \\, \\vec{b}_0 \\, \\big |}\n\nwhere the secondary field components are normalized by the amplitude of the primary field and multiplied by 100%. We first start by converting the total field db/dt data for the triangular waveform to total b-field data for a square waveform.\n\nn_comp = 3  # Simulated x, y and z components\nn_rx = np.shape(receiver_locations)[0]  # number of receiver locations\nn_times = len(time_channels)  # number of time channels\n\n# Reshape predicted data vectors to arrays and convert to b-field representation\nB = (4 / period) * np.reshape(dpred, (n_comp, n_times, n_rx))\nB0 = (4 / period) * np.reshape(dpred0, (n_comp, n_times, n_rx))\n\nNow we compute the primary reduced data.\n\n# Primary field amplitude\nB0abs = np.sqrt(B0[0, :, :] ** 2 + B0[1, :, :] ** 2 + B0[2, :, :] ** 2)\n\nx_data = 100 * (B[0, :, :] - B0[0, :, :]) / B0abs\ny_data = 100 * (B[1, :, :] - B0[1, :, :]) / B0abs\nz_data = 100 * (B[2, :, :] - B0[2, :, :]) / B0abs\n\ndata_plotting = [x_data, y_data, z_data]\n\n","type":"content","url":"/fwd-utem-3d#ploting-primary-reduced-data","position":35},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Primary Reduced Data Map","lvl2":"Ploting Primary-Reduced Data"},"type":"lvl3","url":"/fwd-utem-3d#primary-reduced-data-map","position":36},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"Primary Reduced Data Map","lvl2":"Ploting Primary-Reduced Data"},"content":"Here, we plot the data maps for the time channel specified.\n\ntime_index = 0  # Index for the time channel being plotted\n\nfig = plt.figure(figsize=(15, 6))\nax1 = [fig.add_axes([0.05 + 0.3 * ii, 0.2, 0.28, 0.75]) for ii in range(0, 3)]\ncax1 = [fig.add_axes([0.05 + 0.3 * ii, 0.05, 0.28, 0.05]) for ii in range(0, 3)]\nnorm1 = 3 * [None]\ncbar1 = 3 * [None]\ncplot1 = 3 * [None]\n\ncomp_list = [\"X\", \"Y\", \"Z\"]\n\nfor ii in range(0, 3):\n    d_temp = data_plotting[ii][time_index, :]\n\n    max_val = np.max(np.abs(d_temp))\n    norm1[ii] = mpl.colors.Normalize(vmin=-max_val, vmax=max_val)\n    levels = np.linspace(-max_val, max_val, 19)\n\n    cplot1[ii] = plot2Ddata(\n        receiver_locations[:, 0:2],\n        d_temp,\n        ax=ax1[ii],\n        nx=200,\n        ny=200,\n        ncontour=60,\n        shade=False,\n        level=True,\n        dataloc=True,\n        levelOpts={\"levels\": levels, \"colors\": \"k\", \"linewidths\": 0.75},\n        contourOpts={\"cmap\": mpl.cm.bwr_r, \"norm\": norm1[ii]},\n    )\n\n    ax1[ii].ticklabel_format(axis=\"both\", scilimits=(0, 3))\n    ax1[ii].set_xlabel(\"Easting (m)\")\n    if ii > 0:\n        ax1[ii].set_ylabel(\"\")\n        ax1[ii].set_yticks([])\n    else:\n        ax1[ii].set_ylabel(\"Northing (m)\")\n    ax1[ii].set_title(\"Primary Reduced ({}-comp)\".format(comp_list[ii]))\n\n    cbar1[ii] = mpl.colorbar.ColorbarBase(\n        cax1[ii], norm=norm1[ii], orientation=\"horizontal\", cmap=mpl.cm.bwr_r\n    )\n    cbar1[ii].set_label(\"%\", labelpad=5, size=12)\n\nplt.show(fig)\n\n","type":"content","url":"/fwd-utem-3d#primary-reduced-data-map","position":37},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"TDEM Profile","lvl2":"Ploting Primary-Reduced Data"},"type":"lvl3","url":"/fwd-utem-3d#tdem-profile","position":38},{"hierarchy":{"lvl1":"3D Forward Simulation for On-Time Large-Loop Data","lvl3":"TDEM Profile","lvl2":"Ploting Primary-Reduced Data"},"content":"Here, we plot the TDEM profile for the Northing position specified.\n\nEW_line_index = 6\n\ny_unique = np.unique(receiver_locations[:, 1])\nlocations_indices = receiver_locations[:, 1] == y_unique[EW_line_index]\n\nfig = plt.figure(figsize=(15, 5))\nax1 = [fig.add_axes([0.05 + 0.3 * ii, 0.2, 0.24, 0.75]) for ii in range(0, 3)]\n\ncomp_list = [\"X\", \"Y\", \"Z\"]\n\nfor ii in range(0, 3):\n    d_temp = data_plotting[ii][:, locations_indices]\n\n    for jj in range(n_times):\n        ax1[ii].plot(\n            receiver_locations[locations_indices, 0],\n            d_temp[jj, :],\n            marker=\"o\",\n            color=[jj / (n_times - 1), 0, 1 - jj / (n_times - 1)],\n            markersize=4,\n            label=\"_nolegend_\",\n        )\n\n    ax1[ii].grid()\n    ax1[ii].ticklabel_format(axis=\"both\", scilimits=(0, 3))\n    ax1[ii].set_xlabel(\"Easting (m)\")\n    ax1[ii].set_ylabel(\"%\")\n    ax1[ii].set_title(\"Primary Reduced ({}-comp)\".format(comp_list[ii]))\n\nplt.show(fig)","type":"content","url":"/fwd-utem-3d#tdem-profile","position":39},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding"},"type":"lvl1","url":"/inv-tdem-1d","position":0},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding"},"content":"Intermediate notebook\n\nThis tutorial focusses on intermediate level functionality within SimPEG. Basic functionality within SimPEG is not discussed in detail, as we assume the user is already familiar.\n\nLight-weight notebook\n\nThis tutorial requires minimal computational resources and can be executed quickly in the background while other computer processes are running.\n\nKeywords: total magnetic intensity, integral formulation, inversion, sparse norm, tensor mesh, tree mesh.\n\nSummary: Here we invert total magnetic intensity data to recover a susceptibility model. We demonstrate two approaches for recovering a susceptibility model:\n\nWeighted least-squares inversion for a tensor mesh\n\nIteratively re-weighted least-squares (IRLS) inversion for a tree mesh\n\nThe weighted least-squares approach is a great introduction to geophysical inversion with SimPEG. One drawback however, is that it recovers smooth structures which may not be representative of the true model. To recover sparse and/or blocky structures, we demonstrate the iteratively re-weighted least-squares approach.\n\nLearning Objectives: Because this tutorial focusses primarily on inversion-related functionality, we urge the reader to become familiar with functionality explained in the \n\n1D Forward Simulation of Time-Domain EM Data for a Single Sounding tutorial before working through this one. For this tutorial, we focus on:\n\nHow to carry out 1D geophysical inversion with SimPEG.\n\nHow to assign appropriate uncertainties to TDEM data.\n\nChoosing suitable parameters for the inversion.\n\nSpecifying directives that are applied throughout the inversion.\n\nWeighted least-squares, sparse-norm and parametric inversion.\n\nAnalyzing inversion outputs.\n\n","type":"content","url":"/inv-tdem-1d","position":1},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Importing Modules"},"type":"lvl2","url":"/inv-tdem-1d#importing-modules","position":2},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Importing Modules"},"content":"Here, we import all of the functionality required to run the notebook for the tutorial exercise.\nAll of the functionality specific to the forward simulation of 1D time domain EM data are imported from the \n\nsimpeg​.electromagnetics​.time​_domain module. Classes required to define the data misfit, regularization, optimization, etc... are imported from elsewhere within SimPEG. We also import some useful utility functions from \n\nsimpeg.utils. To generate the mesh used for the inversion, we use the \n\ndiscretize package.\n\n# SimPEG functionality\nimport simpeg.electromagnetics.time_domain as tdem\nfrom simpeg.utils import plot_1d_layer_model, download, mkvc\nfrom simpeg import (\n    maps,\n    data,\n    data_misfit,\n    regularization,\n    optimization,\n    inverse_problem,\n    inversion,\n    directives,\n)\n\n# discretize functionality\nfrom discretize import TensorMesh\n\n# Basic Python functionality\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport tarfile\n\nmpl.rcParams.update({\"font.size\": 14})\n\n","type":"content","url":"/inv-tdem-1d#importing-modules","position":3},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Download and Extract the Tutorial Data"},"type":"lvl2","url":"/inv-tdem-1d#download-and-extract-the-tutorial-data","position":4},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Download and Extract the Tutorial Data"},"content":"For this tutorial, the frequencies and observed data for 1D sounding are stored within a tar-file. Here, we download and extract the data file.\n\n# URL to assets folder\ndata_source = \"https://github.com/simpeg/user-tutorials/raw/main/assets/08-tdem/inv_tdem_1d_files.tar.gz\"\n\n# download the data\ndownloaded_data = download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ndata_filename = dir_path + \"em1dtm_data.txt\"\n\n","type":"content","url":"/inv-tdem-1d#download-and-extract-the-tutorial-data","position":5},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Load and Plot the Data"},"type":"lvl2","url":"/inv-tdem-1d#load-and-plot-the-data","position":6},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Load and Plot the Data"},"content":"Here we load and plot the 1D sounding data. In this case, we have B-field data for a step-off excitation. The columns of the data file are: times (s) and Bz (T).\n\n# Load data\ndobs = np.loadtxt(str(data_filename), skiprows=1)\n\ntimes = dobs[:, 0]\ndobs = mkvc(dobs[:, -1])\n\nfig = plt.figure(figsize=(5, 5))\nax = fig.add_axes([0.15, 0.15, 0.8, 0.75])\nax.loglog(times, np.abs(dobs), \"k-o\", lw=3)\nax.grid(which=\"both\")\nax.set_xlabel(\"Times (s)\")\nax.set_ylabel(\"|B| (T)\")\nax.set_title(\"Observed Data\")\nplt.show()\n\n","type":"content","url":"/inv-tdem-1d#load-and-plot-the-data","position":7},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Defining the Survey"},"type":"lvl2","url":"/inv-tdem-1d#defining-the-survey","position":8},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Defining the Survey"},"content":"Here, we define the survey geometry. For a comprehensive description of constructing TDEM surveys in SimPEG, see the \n\n1D Forward Simulation of Time-Domain EM Data for a Single Sounding tutorial.\n\nHere, the survey consisted of a circular transmitter loop with a radius of 6 m located 20 m above the Earth’s surface. The receiver measured the vertical component of the secondary magnetic field at a the loop’s centre.\n\n# Source loop geometry\nsource_location = np.array([0.0, 0.0, 1.0])  # (3, ) numpy.array_like\nsource_orientation = \"z\"  # \"x\", \"y\" or \"z\"\nsource_current = 1.0  # maximum on-time current (A)\nsource_radius = 10.0  # source loop radius (m)\n\n# Receiver geometry\nreceiver_location = np.array([0.0, 0.0, 1.0])  # or (N, 3) numpy.ndarray\nreceiver_orientation = \"z\"  # \"x\", \"y\" or \"z\"\n\n# Receiver list\nreceiver_list = []\nreceiver_list.append(\n    tdem.receivers.PointMagneticFluxDensity(\n        receiver_location, times, orientation=receiver_orientation\n    )\n)\n\n# Define the source waveform.\nwaveform = tdem.sources.StepOffWaveform()\n\n# Sources\nsource_list = [\n    tdem.sources.CircularLoop(\n        receiver_list=receiver_list,\n        location=source_location,\n        waveform=waveform,\n        current=source_current,\n        radius=source_radius,\n    )\n]\n\n# Survey\nsurvey = tdem.Survey(source_list)\n\n","type":"content","url":"/inv-tdem-1d#defining-the-survey","position":9},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/inv-tdem-1d#assign-uncertainties","position":10},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define the uncertainties on our data; that is, an estimate of the standard deviation of the noise on our data assuming it is uncorrelated Gaussian with zero mean. An online resource explaining uncertainties and their role in the inversion can be found \n\nhere.\n\nFor off-time TDEM data, a percent uncertainty plus a small floor value is generally applied to all data. Depending on many factors, we may apply a percent uncertainty between 5% and 20%. The floor uncertainty ensure we do not try to overfit late time channels when the signal to noise become sufficiently small. For systems where multiple field directions are measured for the same source, we may not want to apply a uniform percent uncertainty to all data. Doing so may cause the inversion to overfit weaker components. In this case, the uncertainty may be a percent of the amplitude of the secondary field.\n\n# 5% of the absolute value\nuncertainties = 0.05 * np.abs(dobs) * np.ones(np.shape(dobs))\n\n","type":"content","url":"/inv-tdem-1d#assign-uncertainties","position":11},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Defining the Data"},"type":"lvl2","url":"/inv-tdem-1d#defining-the-data","position":12},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Defining the Data"},"content":"The SimPEG \n\nData class is required for inversion and connects the observed data, uncertainties and survey geometry.\n\ndata_object = data.Data(survey, dobs=dobs, standard_deviation=uncertainties)\n\n","type":"content","url":"/inv-tdem-1d#defining-the-data","position":13},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-tdem-1d#weighted-least-squares-inversion","position":14},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the weighted least-squares inversion approach to recover the log-conductivities on a 1D layered Earth. We impose no a-priori information about the number of layers (geological units) or their thicknesses. Instead, we define a large number of layers with exponentially increasing thicknesses. And the depth, thickness and electrical properties of the Earth are inferred from the recovered model.\n\n","type":"content","url":"/inv-tdem-1d#weighted-least-squares-inversion","position":15},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Defining a 1D Layered Earth","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#defining-a-1d-layered-earth","position":16},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Defining a 1D Layered Earth","lvl2":"Weighted Least-Squares Inversion"},"content":"Let us assume we have a reasonable estimate of the regional conductivity within our area of interest. For the earliest time channel and the estimated conductivity, we compute the minimum diffusion distance:d_{min} \\approx 1250 \\sqrt{\\dfrac{t_{min}}{\\sigma}}\n\nThe minimum layer thickness is some fraction of the minimum diffusion distance. Next, we use the latest time channel and the estimated conductivity to compute the maximum diffusion distance:d_{max} \\approx 1250 \\sqrt{\\dfrac{t_{max}}{\\sigma}}\n\nStarting from our minimum layer thickness, we continue to add layers with exponentially increasing thicknesses. We do so until the layers extend to some multiple of the maximum diffusion distance.\n\n# estimated host conductivity (S/m)\nestimated_conductivity = 0.1\n\n# minimum diffusion distance\nd_min = 1250 * np.sqrt(times.min() / estimated_conductivity)\nprint(\"MINIMUM DIFFUSION DISTANCE: {} m\".format(d_min))\n\n# maximum diffusion distance\nd_max = 1250 * np.sqrt(times.max() / estimated_conductivity)\nprint(\"MAXIMUM DIFFUSION DISTANCE: {} m\".format(d_max))\n\ndepth_min = 1  # top layer thickness\ndepth_max = 800.0  # depth to lowest layer\ngeometric_factor = 1.15  # rate of thickness increase\n\n# Increase subsequent layer thicknesses by the geometric factors until\n# it reaches the maximum layer depth.\nlayer_thicknesses = [depth_min]\nwhile np.sum(layer_thicknesses) < depth_max:\n    layer_thicknesses.append(geometric_factor * layer_thicknesses[-1])\n\nn_layers = len(layer_thicknesses) + 1  # Number of layers\n\n","type":"content","url":"/inv-tdem-1d#defining-a-1d-layered-earth","position":17},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Model and Mapping to Layer Conductivities","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#model-and-mapping-to-layer-conductivities","position":18},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Model and Mapping to Layer Conductivities","lvl2":"Weighted Least-Squares Inversion"},"content":"Recall from the \n\n1D Forward Simulation of Time-Domain EM Data for a Single Sounding tutorial that the ‘model’ is not necessarily synonymous with physical property values. And that we need to define a mapping from the model to the set of input parameters required by the forward simulation. When inverting to recover electrical conductivities (or resistivities), it is best to use the log-value, as electrical conductivities of rocks span many order of magnitude.\n\nHere, the model defines the log-conductivity values for a defined set of subsurface layers. And we use the \n\nsimpeg.maps.ExpMap to map from the model parameters to the conductivity values required by the forward simulation.\n\nlog_conductivity_map = maps.ExpMap(nP=n_layers)\n\n","type":"content","url":"/inv-tdem-1d#model-and-mapping-to-layer-conductivities","position":19},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#starting-reference-models","position":20},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting/Reference Models","lvl2":"Weighted Least-Squares Inversion"},"content":"The starting model defines a reasonable starting point for the inversion. Because electromagnetic problems are non-linear, your choice in starting model does have an impact on the recovered model. For DC resistivity inversion, we generally choose our starting model based on apparent resistivities. For the tutorial example, the apparent resistivities were near 1000 \\Omega m. It should be noted that the starting model cannot be vector of zeros, otherwise the inversion will be unable to compute a gradient direction at the first iteration.\n\nThe reference model is used to include a-priori information. The impact of the reference model on the inversion will be discussed in another tutorial. The reference model for basic inversion approaches is either zero or equal to the starting model.\n\nNotice that the length of the starting and reference models is equal to the number of model parameters!!!\n\n# Starting model is log-conductivity values (S/m)\nstarting_conductivity_model = np.log(1e-1 * np.ones(n_layers))\n\n# Reference model is also log-resistivity values (S/m)\nreference_conductivity_model = starting_conductivity_model.copy()\n\n","type":"content","url":"/inv-tdem-1d#starting-reference-models","position":21},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#define-the-forward-simulation","position":22},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Weighted Least-Squares Inversion"},"content":"A simulation object defining the forward problem is required in order to predict data and calculate misfits for recovered models. A comprehensive description of the simulation object for 1D DC resistivity was discussed in the \n\n1D Forward Simulation of Time-Domain EM Data for a Single Sounding tutorial. Here, we use the \n\nSimulation1DLayered which simulates the data according to a 1D Hankel transform solution.\n\nThe layer thicknesses are a static property of the simulation, and we set them using the thicknessess keyword argument. Since our model consists of log-conductivities, we use sigmaMap to set the mapping from the model to the layer conductivities.\n\nsimulation_L2 = tdem.Simulation1DLayered(\n    survey=survey, thicknesses=layer_thicknesses, sigmaMap=log_conductivity_map\n)\n\n","type":"content","url":"/inv-tdem-1d#define-the-forward-simulation","position":23},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#data-misfit","position":24},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the data misfit in the inversion, please visit \n\nthis online resource.\nHere, we use the \n\nL2DataMisfit class to define the data misfit. In this case, the data misfit is the L2 norm of the weighted residual between the observed data and the data predicted for a given model. When instantiating the data misfit object within SimPEG, we must assign an appropriate data object and simulation object as properties.\n\ndmis_L2 = data_misfit.L2DataMisfit(simulation=simulation_L2, data=data_object)\n\n","type":"content","url":"/inv-tdem-1d#data-misfit","position":25},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Regularization","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#regularization","position":26},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Regularization","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of the regularization in the inversion, please visit \n\nthis online resource.\n\nTo define the regularization within SimPEG, we must define a 1D \n\ntensor mesh. Meshes are designed using the \n\ndiscretize package. Whereas layer thicknesses and our model are defined from our top-layer down, tensor meshes are defined from the bottom up. So to define a 1D tensor mesh for the regularization, we:\n\nadd an extra layer to the end of our thicknesses so that the number of cells in the 1D mesh equals the number of model parameters\n\nreverse the order so that the model parameters in the regularization match up with the appropriate cell\n\ndefine the tensor mesh from the cell widths\n\n# Define 1D cell widths\nh = np.r_[layer_thicknesses, layer_thicknesses[-1]]\nh = np.flipud(h)\n\n# Create regularization mesh\nregularization_mesh = TensorMesh([h], \"N\")\nprint(regularization_mesh)\n\nBy default, the regularization acts on the model parameters. In this case, the model parameters are the log-resistivities, not the electric resistivities!!! Here, we use the \n\nWeightedLeastSquares regularization class to constrain the inversion result. Here, length scale along x are used to balance the smallness and smoothness terms; yes, x is smoothness along the vertical direction. And the reference model is only applied to the smallness term. If we wanted to apply the regularization to a function of the model parameters, we would need to set an approprate mapping object using the mapping keyword argument.\n\nreg_L2 = regularization.WeightedLeastSquares(\n    regularization_mesh,\n    length_scale_x=10.0,\n    reference_model=reference_conductivity_model,\n    reference_model_in_smooth=False,\n)\n\n","type":"content","url":"/inv-tdem-1d#regularization","position":27},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Optimization","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#optimization","position":28},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Optimization","lvl2":"Weighted Least-Squares Inversion"},"content":"Here, we use the \n\nInexactGaussNewton class to solve the optimization problem using the inexact Gauss Newton with conjugate gradient solver. Reasonable default values have generally been set for the properties of each optimization class. However, the user may choose to set custom values; e.g. the accuracy tolerance for the conjugate gradient solver or the number of line searches.\n\nopt_L2 = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-tdem-1d#optimization","position":29},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#inverse-problem","position":30},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Weighted Least-Squares Inversion"},"content":"We use the \n\nBaseInvProblem class to fully define the inverse problem that is solved at each beta (trade-off parameter) iteration. The inverse problem requires appropriate data misfit, regularization and optimization objects.\n\ninv_prob_L2 = inverse_problem.BaseInvProblem(dmis_L2, reg_L2, opt_L2)\n\n","type":"content","url":"/inv-tdem-1d#inverse-problem","position":31},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#inversion-directives","position":32},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inversion Directives","lvl2":"Weighted Least-Squares Inversion"},"content":"To understand the role of directives in the inversion, please visit this online resource. Here, we apply common directives for weighted least-squares inversion of gravity data and describe their roles. These are:\n\nUpdatePreconditioner: Apply Jacobi preconditioner when solving optimization problem to reduce the number of conjugate gradient iterations. We set update_every_iteration=True because the ideal preconditioner is model-dependent.\n\nBetaEstimate_ByEig: Compute and set starting trade-off parameter (beta) based on largest eigenvalues.\n\nBetaSchedule: Size reduction of the trade-off parameter at every beta iteration, and the number of Gauss-Newton iterations for each beta. In general, a coolingFactor between 1.5 and 2.5, and coolingRate of 3 works well for TDEM inversion. Cooling beta too quickly will result in portions of the model getting trapped in local minima. And we will not be finding the solution that minimizes the optimization problem if the cooling rate is too small.\n\nTargetMisfit: Terminates the inversion when the data misfit equals the target misfit. A chifact=1 terminates the inversion when the data misfit equals the number of data.\n\nThe directive objects are organized in a list. Upon starting the inversion or updating the recovered model at each iteration, the inversion will call each directive within the list in order. The order of the directives matters, and SimPEG will throw an error if directives are organized into an improper order. Some directives, like the BetaEstimate_ByEig are only used when starting the inversion. Other directives, like UpdatePreconditionner, are used whenever the model is updated.\n\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=5)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=3)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_L2 = [update_jacobi, starting_beta, beta_schedule, target_misfit]\n\n","type":"content","url":"/inv-tdem-1d#inversion-directives","position":33},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#define-and-run-the-inversion","position":34},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Weighted Least-Squares Inversion"},"content":"We define the inversion using the \n\nBaseInversion class. The inversion class must be instantiated with an appropriate inverse problem object and directives list. The run method, along with a starting model, is respondible for running the inversion. The output is a 1D numpy.ndarray containing the recovered model parameters\n\n# Here we combine the inverse problem and the set of directives\ninv_L2 = inversion.BaseInversion(inv_prob_L2, directives_list_L2)\n\n# Run the inversion\nrecovered_model_L2 = inv_L2.run(starting_conductivity_model)\n\n","type":"content","url":"/inv-tdem-1d#define-and-run-the-inversion","position":35},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Inversion Outputs"},"type":"lvl2","url":"/inv-tdem-1d#inversion-outputs","position":36},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Inversion Outputs"},"content":"\n\n","type":"content","url":"/inv-tdem-1d#inversion-outputs","position":37},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit","lvl2":"Inversion Outputs"},"type":"lvl3","url":"/inv-tdem-1d#data-misfit-1","position":38},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit","lvl2":"Inversion Outputs"},"content":"\n\ndpred_L2 = simulation_L2.dpred(recovered_model_L2)\n\nfig = plt.figure(figsize=(5, 5))\nax1 = fig.add_axes([0.15, 0.15, 0.8, 0.75])\nax1.loglog(times, np.abs(dobs), \"k-o\")\nax1.loglog(times, np.abs(dpred_L2), \"b-o\")\nax1.grid(which=\"both\")\nax1.set_xlabel(\"times (s)\")\nax1.set_ylabel(\"Bz (T)\")\nax1.set_title(\"Predicted and Observed Data\")\nax1.legend([\"Observed\", \"L2 Inversion\"], loc=\"upper right\")\nplt.show()\n\n","type":"content","url":"/inv-tdem-1d#data-misfit-1","position":39},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Recovered Model","lvl2":"Inversion Outputs"},"type":"lvl3","url":"/inv-tdem-1d#recovered-model","position":40},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Recovered Model","lvl2":"Inversion Outputs"},"content":"\n\n# Load the true model and layer thicknesses\ntrue_conductivities = np.array([0.1, 1.0, 0.1])\ntrue_layers = np.r_[40.0, 40.0, 160.0]\n\n# Plot true model and recovered model\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_conductivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nx_min, x_max = true_conductivities.min(), true_conductivities.max()\nax1.set_xlim(0.8 * x_min, 1.5 * x_max)\nax1.set_ylim([np.sum(true_layers), 0])\nax1.legend([\"True Model\", \"L2-Model\"])\nplt.show()\n\n","type":"content","url":"/inv-tdem-1d#recovered-model","position":41},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl2","url":"/inv-tdem-1d#iteratively-re-weighted-least-squares-inversion","position":42},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the iteratively reweighted least-squares (IRLS) inversion approach to recover sparse and/or blocky models on the set layers.\n\n","type":"content","url":"/inv-tdem-1d#iteratively-re-weighted-least-squares-inversion","position":43},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#define-the-forward-simulation-1","position":44},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Forward Simulation","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nsimulation_irls = tdem.simulation_1d.Simulation1DLayered(\n    survey=survey,\n    sigmaMap=log_conductivity_map,\n    thicknesses=layer_thicknesses,\n)\n\n","type":"content","url":"/inv-tdem-1d#define-the-forward-simulation-1","position":45},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#define-the-data-misfit","position":46},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define the Data Misfit","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndmis_irls = data_misfit.L2DataMisfit(simulation=simulation_irls, data=data_object)\n\n","type":"content","url":"/inv-tdem-1d#define-the-data-misfit","position":47},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#regularization-1","position":48},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Regularization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we use the \n\nSparse regularization class to constrain the inversion result using an IRLS approach. Here, the scaling constants that balance the smallness and smoothness terms are set directly. Equal emphasis on smallness and smoothness is generally applied by using the inverse square of the smallest cell dimension. The reference model is only applied to the smallness term; which is redundant for the tutorial example since we have set the reference model to an array of zeros. Here, we apply a 1-norm to the smallness term and a 1-norm to first-order smoothness along the x (vertical direction).\n\nreg_irls = regularization.Sparse(\n    regularization_mesh,\n    alpha_s=0.01,\n    alpha_x=1,\n    reference_model_in_smooth=False,\n    norms=[1.0, 1.0],\n)\n\n","type":"content","url":"/inv-tdem-1d#regularization-1","position":49},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Optimization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#optimization-1","position":50},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Optimization","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\nopt_irls = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=30, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-tdem-1d#optimization-1","position":51},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#inverse-problem-1","position":52},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ninv_prob_irls = inverse_problem.BaseInvProblem(dmis_irls, reg_irls, opt_irls)\n\n","type":"content","url":"/inv-tdem-1d#inverse-problem-1","position":53},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#directives","position":54},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Directives","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"Here, we create common directives for IRLS inversion of total magnetic intensity data and describe their roles. In additon to the \n\nUpdateSensitivityWeights, \n\nUpdatePreconditioner and \n\nBetaEstimate_ByEig  (described before), inversion with sparse-norms requires the \n\nUpdateIRLS directive.\n\nYou will notice that we don’t use the \n\nBetaSchedule and \n\nTargetMisfit directives. Here, the beta cooling schedule is set in the \n\nUpdateIRLS directive using the coolingFactor and coolingRate properties. The target misfit for the L2 portion of the IRLS approach is set with the chifact_start property.\n\nsensitivity_weights_irls = directives.UpdateSensitivityWeights(every_iteration=True)\nstarting_beta_irls = directives.BetaEstimate_ByEig(beta0_ratio=1)\nupdate_jacobi_irls = directives.UpdatePreconditioner(update_every_iteration=True)\nupdate_irls = directives.UpdateIRLS(\n    cooling_factor=2,\n    cooling_rate=2,\n    f_min_change=1e-4,\n    max_irls_iterations=40,\n    chifact_start=1.0,\n)\n\ndirectives_list_irls = [\n    update_irls,\n    sensitivity_weights_irls,\n    starting_beta_irls,\n    update_jacobi_irls,\n]\n\n","type":"content","url":"/inv-tdem-1d#directives","position":55},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#define-and-run-the-inversion-1","position":56},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run the Inversion","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\n# Here we combine the inverse problem and the set of directives\ninv_irls = inversion.BaseInversion(inv_prob_irls, directives_list_irls)\n\n# Run the inversion\nrecovered_model_irls = inv_irls.run(starting_conductivity_model)\n\n","type":"content","url":"/inv-tdem-1d#define-and-run-the-inversion-1","position":57},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"type":"lvl3","url":"/inv-tdem-1d#data-misfit-and-recovered-model","position":58},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Iteratively Re-weighted Least-Squares Inversion"},"content":"\n\ndpred_irls = simulation_irls.dpred(recovered_model_irls)\n\nfig = plt.figure(figsize=(5, 5))\nax1 = fig.add_axes([0.15, 0.15, 0.8, 0.75])\nax1.loglog(times, np.abs(dobs), \"k-o\")\nax1.loglog(times, np.abs(dpred_L2), \"b-o\")\nax1.loglog(times, np.abs(dpred_irls), \"r-o\")\nax1.grid(which=\"both\")\nax1.set_xlabel(\"times (s)\")\nax1.set_ylabel(\"Bz (T)\")\nax1.set_title(\"Predicted and Observed Data\")\nax1.legend([\"Observed\", \"L2 Inversion\", \"IRLS Inversion\"], loc=\"upper right\")\nplt.show()\n\n# Plot true model and recovered model\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_conductivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_irls, ax=ax1, color=\"r\"\n)\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nax1.set_xlim(0.8 * x_min, 1.5 * x_max)\nax1.set_ylim([np.sum(true_layers), 0])\nax1.legend([\"True Model\", \"L2 Model\", \"IRLS Model\"])\nplt.show()\n\n","type":"content","url":"/inv-tdem-1d#data-misfit-and-recovered-model","position":59},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Parametric Inversion"},"type":"lvl2","url":"/inv-tdem-1d#parametric-inversion","position":60},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl2":"Parametric Inversion"},"content":"Here, we assume the subsurface is defined by a 3-layered Earth. However, the electrical properties and thicknesses of the layers are unknown. Here, we define our model to include log-conductivities and log-thicknesses. When including quantities that span different scales, it is frequently best to define the model in terms of log values so that each quantity influences the predicted data evenly.\n\n","type":"content","url":"/inv-tdem-1d#parametric-inversion","position":61},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Model and Mapping","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#model-and-mapping","position":62},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Model and Mapping","lvl2":"Parametric Inversion"},"content":"For a 3-layered Earth model, the model consists of 2 log-thicknesses and 3 log-conductivities. Similar to the \n\n1D Forward Simulation of Time Domain EM Data for a Single Sounding tutorial, need a mapping that extract log-thicknesses and log-resistivities from the model, and mappings that convert log-values to property values. For this, we require the \n\nsimpeg.maps.Wires mapping and \n\nsimpeg.maps.ExpMap mapping classes. Note that successive mappings can be chained together using the * operator.\n\n# Wire maps to extract log-thicknesses and log-conductivities\nwire_map = maps.Wires((\"log_thicknesses\", 2), (\"log_resistivity\", 3))\n\n# Maping for layer thicknesses\nlog_thicknesses_map = maps.ExpMap() * wire_map.log_thicknesses\n\n# Mapping for conductivities\nlog_resistivity_map = maps.ExpMap() * wire_map.log_resistivity\n\n","type":"content","url":"/inv-tdem-1d#model-and-mapping","position":63},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting and Reference Model","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#starting-and-reference-model","position":64},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Starting and Reference Model","lvl2":"Parametric Inversion"},"content":"This problem is highly non-linear so it is important to have a reasonable estimate of the true model.\n\nstarting_parametric_model = np.log(np.r_[30.0, 20.0, 20, 0.5, 5])\n\nreference_parametric_model = starting_parametric_model.copy()\n\n","type":"content","url":"/inv-tdem-1d#starting-and-reference-model","position":65},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Forward Simulation","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#forward-simulation","position":66},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Forward Simulation","lvl2":"Parametric Inversion"},"content":"Because the layer thicknesses are part of the model, we define the thicknessesMap. Because we are working in terms of electrical resistivity, we must define the rhoMap.\n\nsimulation_parametric = tdem.simulation_1d.Simulation1DLayered(\n    survey=survey,\n    rhoMap=log_resistivity_map,\n    thicknessesMap=log_thicknesses_map,\n)\n\n","type":"content","url":"/inv-tdem-1d#forward-simulation","position":67},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#data-misfit-2","position":68},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit","lvl2":"Parametric Inversion"},"content":"\n\ndmis_parametric = data_misfit.L2DataMisfit(\n    simulation=simulation_parametric, data=data_object\n)\n\n","type":"content","url":"/inv-tdem-1d#data-misfit-2","position":69},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"(Combo) Regularization","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#id-combo-regularization","position":70},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"(Combo) Regularization","lvl2":"Parametric Inversion"},"content":"We need to define a regularization for each model parameter type. In this case, we have log-thicknesses and log-conductivities. For each model parameter type, we create a 1D \n\ntensor mesh with length equal to the number of parameters. In the mapping keyword argument, we used the wire map that extracts the specific model parameters from the model.\n\nUsing the * operator, separate regularizations can be summed to form a regularization that is also a \n\nComboObjectiveFunction. By setting the multipliers property, we can emphasize the relative contributions of the log-thicknesses and log-conductivities regularizations.\n\nreg_1 = regularization.Smallness(\n    TensorMesh([(np.ones(2))], \"0\"),\n    mapping=wire_map.log_thicknesses,\n    reference_model=reference_parametric_model,\n)\n\nreg_2 = regularization.Smallness(\n    TensorMesh([(np.ones(3))], \"0\"),\n    mapping=wire_map.log_resistivity,\n    reference_model=reference_parametric_model,\n)\n\nreg_parametric = reg_1 + reg_2\nreg_parametric.multipliers = [1.0, 0.1]\n\n","type":"content","url":"/inv-tdem-1d#id-combo-regularization","position":71},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Optimization","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#optimization-2","position":72},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Optimization","lvl2":"Parametric Inversion"},"content":"\n\nopt_parametric = optimization.InexactGaussNewton(\n    maxIter=100, maxIterLS=20, maxIterCG=20, tolCG=1e-3\n)\n\n","type":"content","url":"/inv-tdem-1d#optimization-2","position":73},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#inverse-problem-2","position":74},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Inverse Problem","lvl2":"Parametric Inversion"},"content":"\n\ninv_prob_parametric = inverse_problem.BaseInvProblem(\n    dmis_parametric, reg_parametric, opt_parametric\n)\n\n","type":"content","url":"/inv-tdem-1d#inverse-problem-2","position":75},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Directives","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#directives-1","position":76},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Directives","lvl2":"Parametric Inversion"},"content":"\n\nupdate_jacobi = directives.UpdatePreconditioner(update_every_iteration=True)\nstarting_beta = directives.BetaEstimate_ByEig(beta0_ratio=10)\nbeta_schedule = directives.BetaSchedule(coolingFactor=2.0, coolingRate=3)\ntarget_misfit = directives.TargetMisfit(chifact=1.0)\n\ndirectives_list_parametric = [\n    update_jacobi,\n    starting_beta,\n    beta_schedule,\n    target_misfit,\n]\n\n","type":"content","url":"/inv-tdem-1d#directives-1","position":77},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run Inversion","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#define-and-run-inversion","position":78},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Define and Run Inversion","lvl2":"Parametric Inversion"},"content":"\n\ninv_parametric = inversion.BaseInversion(\n    inv_prob_parametric, directives_list_parametric\n)\nrecovered_model_parametric = inv_parametric.run(starting_parametric_model)\n\n","type":"content","url":"/inv-tdem-1d#define-and-run-inversion","position":79},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Parametric Inversion"},"type":"lvl3","url":"/inv-tdem-1d#data-misfit-and-recovered-model-1","position":80},{"hierarchy":{"lvl1":"1D Inversion for a Single Sounding","lvl3":"Data Misfit and Recovered Model","lvl2":"Parametric Inversion"},"content":"\n\ndpred_parametric = simulation_parametric.dpred(recovered_model_parametric)\n\nfig = plt.figure(figsize=(5, 5))\nax1 = fig.add_axes([0.15, 0.15, 0.8, 0.75])\nax1.loglog(times, np.abs(dobs), \"k-o\")\nax1.loglog(times, np.abs(dpred_L2), \"b-o\")\nax1.loglog(times, np.abs(dpred_irls), \"r-o\")\nax1.loglog(times, np.abs(dpred_parametric), \"g-o\")\nax1.grid(which=\"both\")\nax1.set_xlabel(\"times (s)\")\nax1.set_ylabel(\"Bz (T)\")\nax1.set_title(\"Predicted and Observed Data\")\nax1.legend(\n    [\"Observed\", \"L2 Inversion\", \"IRLS Inversion\", \"Parametric Inversion\"],\n    loc=\"upper right\",\n)\nplt.show()\n\nfig = plt.figure(figsize=(6, 6))\n\nax1 = fig.add_axes([0.2, 0.15, 0.7, 0.7])\nplot_1d_layer_model(true_layers, true_conductivities, ax=ax1, color=\"k\")\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_L2, ax=ax1, color=\"b\"\n)\nplot_1d_layer_model(\n    layer_thicknesses, log_conductivity_map * recovered_model_irls, ax=ax1, color=\"r\"\n)\nplot_1d_layer_model(\n    log_thicknesses_map * recovered_model_parametric,\n    1 / (log_resistivity_map * recovered_model_parametric),\n    ax=ax1,\n    color=\"g\",\n)\nax1.grid()\nax1.set_xlabel(r\"Resistivity ($\\Omega m$)\")\nax1.set_xlim(0.8 * x_min, 2 * x_max)\nax1.set_ylim([np.sum(true_layers), 0])\nax1.legend([\"True Model\", \"L2 Model\", \"IRLS Model\", \"Parametric Model\"])\nplt.show()","type":"content","url":"/inv-tdem-1d#data-misfit-and-recovered-model-1","position":81},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data"},"type":"lvl1","url":"/plot-inv-3-cross-gradient-pf","position":0},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data"},"content":"%matplotlib inline\n\nHere we simultaneously invert gravity and magentic data using cross-gradient\nconstraint. The recovered density and susceptibility models are supposed to have\nstructural similarity. For this tutorial, we focus on the following:- Defining the survey from xyz formatted data\n- Generating a mesh based on survey geometry\n- Including surface topography\n- Defining the inverse problem via combmaps (2 data misfit terms,\n    2 regularization terms, a coupling term and optimization)\n- Specifying directives for the inversion\n- Plotting the recovered model and data misfit\n\nAlthough we consider gravity and magnetic anomaly data in this tutorial,\nthe same approach can be used to invert gradiometry and other types of geophysical data.\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf","position":1},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Import modules"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#import-modules","position":2},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Import modules"},"content":"\n\nimport os\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport tarfile\n\nfrom discretize import TensorMesh\nfrom discretize.utils import active_from_xyz\nfrom simpeg.utils import plot2Ddata\nfrom simpeg.potential_fields import gravity, magnetics\nfrom simpeg import (\n    maps,\n    data,\n    data_misfit,\n    inverse_problem,\n    regularization,\n    optimization,\n    directives,\n    inversion,\n    utils,\n)\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#import-modules","position":3},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define File Names"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#define-file-names","position":4},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define File Names"},"content":"File paths for assets we are loading. To set up the inversion, we require\ntopography and field observations. The true model defined on the whole mesh\nis loaded to compare with the inversion result. These files are stored as a\ntar-file on our google cloud bucket:\n“\n\nhttps://​storage​.googleapis​.com​/simpeg​/doc​-assets​/gravity​.tar​.gz”\n\n# # storage bucket where we have the data\ndata_source = (\n    \"https://storage.googleapis.com/simpeg/doc-assets/cross_gradient_data.tar.gz\"\n)\n\n# # download the data\ndownloaded_data = utils.download(data_source, overwrite=True)\n\n# unzip the tarfile\ntar = tarfile.open(downloaded_data, \"r\")\ntar.extractall()\ntar.close()\n\n# path to the directory containing our data\ndir_path = downloaded_data.split(\".\")[0] + os.path.sep\n\n# files to work with\ntopo_filename = dir_path + \"topo.txt\"\nmodel_filename = dir_path + \"true_model.txt\"\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#define-file-names","position":5},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Load Data and Plot"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#load-data-and-plot","position":6},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Load Data and Plot"},"content":"Here we load and plot synthetic gravity anomaly data. Topography is generally\ndefined as an (N, 3) array. Gravity data is generally defined with 4 columns:\nx, y, z and data.\n\n# Load topography\nxyz_topo = np.loadtxt(topo_filename)\n\n# Load field data\ndobs_grav = np.loadtxt(dir_path + \"gravity_data.obs\")\ndobs_mag = np.loadtxt(dir_path + \"magnetic_data.obs\")\n\n# Define receiver locations and observed data\nreceiver_locations = dobs_grav[:, 0:3]\n\ndobs_grav = dobs_grav[:, -1]\ndobs_mag = dobs_mag[:, -1]\n\n# Plot\nmpl.rcParams.update({\"font.size\": 12})\n\n# gravity data\nfig = plt.figure(figsize=(7, 5))\n\nax1 = fig.add_axes([0.1, 0.1, 0.73, 0.85])\nplot2Ddata(receiver_locations, dobs_grav, ax=ax1, contourOpts={\"cmap\": \"bwr\"})\nax1.set_title(\"Gravity Anomaly\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\n\nax2 = fig.add_axes([0.8, 0.1, 0.03, 0.85])\nnorm = mpl.colors.Normalize(\n    vmin=-np.max(np.abs(dobs_grav)), vmax=np.max(np.abs(dobs_grav))\n)\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.bwr, format=\"%.1e\"\n)\ncbar.set_label(\"$mgal$\", rotation=270, labelpad=15, size=12)\n\n# magnetic data\nfig = plt.figure(figsize=(7, 5))\nax1 = fig.add_axes([0.1, 0.1, 0.73, 0.85])\nplot2Ddata(receiver_locations, dobs_mag, ax=ax1, contourOpts={\"cmap\": \"bwr\"})\nax1.set_title(\"Magnetic Anomaly\")\nax1.set_xlabel(\"x (m)\")\nax1.set_ylabel(\"y (m)\")\n\nax2 = fig.add_axes([0.8, 0.1, 0.03, 0.85])\nnorm = mpl.colors.Normalize(\n    vmin=-np.max(np.abs(dobs_mag)), vmax=np.max(np.abs(dobs_mag))\n)\ncbar = mpl.colorbar.ColorbarBase(\n    ax2, norm=norm, orientation=\"vertical\", cmap=mpl.cm.bwr, format=\"%.1e\"\n)\ncbar.set_label(\"$nT$\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#load-data-and-plot","position":7},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Assign Uncertainties"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#assign-uncertainties","position":8},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Assign Uncertainties"},"content":"Inversion with SimPEG requires that we define standard deviation on our data.\nThis represents our estimate of the noise in our data. For gravity inversion,\na constant floor value is generally applied to all data. For this tutorial,\nthe standard deviation on each datum will be 1% of the maximum observed\ngravity anomaly value. For magnetic inversion, the same strategy is performed.\n\nmaximum_anomaly_grav = np.max(np.abs(dobs_grav))\nuncertainties_grav = 0.01 * maximum_anomaly_grav * np.ones(np.shape(dobs_grav))\n\nmaximum_anomaly_mag = np.max(np.abs(dobs_mag))\nuncertainties_mag = 0.01 * maximum_anomaly_mag * np.ones(np.shape(dobs_mag))\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#assign-uncertainties","position":9},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Defining the Survey"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#defining-the-survey","position":10},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Defining the Survey"},"content":"Here, we define survey that will be used for this tutorial. Gravity\nsurveys are simple to create. The user only needs an (N, 3) array to define\nthe xyz locations of the observation locations. From this, the user can\ndefine the receivers and the source field.\n\n# Define the receivers. The data consist of vertical gravity anomaly measurements.\n# The set of receivers must be defined as a list.\nreceiver_grav = gravity.receivers.Point(receiver_locations, components=\"gz\")\n\n# Define the source field and survey for gravity data\nsource_field_grav = gravity.sources.SourceField(receiver_list=[receiver_grav])\nsurvey_grav = gravity.survey.Survey(source_field_grav)\n\n\n# Define the component(s) of the field we want to simulate as a list of strings.\n# Here we simulation total magnetic intensity data.\ncomponents = [\"tmi\"]\n\n# Use the observation locations and components to define the receivers. To\n# simulate data, the receivers must be defined as a list.\nreceiver_mag = magnetics.receivers.Point(receiver_locations, components=components)\n\n# Define the inducing field H0 = (intensity [nT], inclination [deg], declination [deg])\ninclination = 90\ndeclination = 0\nstrength = 50000\n\n# Define the source field and survey for gravity data\nsource_field_mag = magnetics.sources.UniformBackgroundField(\n    receiver_list=[receiver_mag],\n    amplitude=strength,\n    declination=declination,\n    inclination=inclination,\n)\nsurvey_mag = magnetics.survey.Survey(source_field_mag)\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#defining-the-survey","position":11},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Defining the Data"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#defining-the-data","position":12},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Defining the Data"},"content":"Here is where we define the data that are inverted. The data are defined by\nthe survey, the observation values and the standard deviation.\n\ndata_object_grav = data.Data(\n    survey_grav, dobs=dobs_grav, standard_deviation=uncertainties_grav\n)\ndata_object_mag = data.Data(\n    survey_mag, dobs=dobs_mag, standard_deviation=uncertainties_mag\n)\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#defining-the-data","position":13},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Defining a Tensor Mesh"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#defining-a-tensor-mesh","position":14},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Defining a Tensor Mesh"},"content":"Here, we create the tensor mesh that will be used to invert gravity anomaly\ndata. If desired, we could define an OcTree mesh.\n\ndh = 5.0\nhx = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhy = [(dh, 5, -1.3), (dh, 40), (dh, 5, 1.3)]\nhz = [(dh, 5, -1.3), (dh, 15)]\nmesh = TensorMesh([hx, hy, hz], \"CCN\")\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#defining-a-tensor-mesh","position":15},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Starting/Reference Model and Mapping on Tensor Mesh"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#starting-reference-model-and-mapping-on-tensor-mesh","position":16},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Starting/Reference Model and Mapping on Tensor Mesh"},"content":"Here, we create starting and/or reference models for the inversion as\nwell as the mapping from the model space to the active cells. Starting and\nreference models can be a constant background value or contain a-priori\nstructures. Here, the backgrounds are 1e-6 g/cc and 1e-6 SI for density and\nsusceptibility models, respectively. Note that the background values could\nbe different for density and susceptibility models.\n\n# Define density contrast values for each unit in g/cc.\nbackground_dens, background_susc = 1e-6, 1e-6\n\n# Find the indicies of the active cells in forward model (ones below surface)\nind_active = active_from_xyz(mesh, xyz_topo)\n\n# Define mapping from model to active cells\nnC = int(ind_active.sum())\nmodel_map = maps.IdentityMap(nP=nC)  # model consists of a value for each active cell\n\n# Create Wires Map that maps from stacked models to individual model components\n# m1 refers to density model, m2 refers to susceptibility\nwires = maps.Wires((\"density\", nC), (\"susceptibility\", nC))\n\n# Define and plot starting model\nstarting_model = np.r_[background_dens * np.ones(nC), background_susc * np.ones(nC)]\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#starting-reference-model-and-mapping-on-tensor-mesh","position":17},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define the Physics"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#define-the-physics","position":18},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define the Physics"},"content":"Here, we define the physics of the gravity and magnetic problems by using the simulation\nclass.\n\nsimulation_grav = gravity.simulation.Simulation3DIntegral(\n    survey=survey_grav,\n    mesh=mesh,\n    rhoMap=wires.density,\n    active_cells=ind_active,\n    engine=\"choclo\",\n)\n\nsimulation_mag = magnetics.simulation.Simulation3DIntegral(\n    survey=survey_mag,\n    mesh=mesh,\n    model_type=\"scalar\",\n    chiMap=wires.susceptibility,\n    active_cells=ind_active,\n    engine=\"choclo\",\n)\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#define-the-physics","position":19},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define the Inverse Problem"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#define-the-inverse-problem","position":20},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define the Inverse Problem"},"content":"The inverse problem is defined by 4 things:1) Data Misfit: a measure of how well our recovered model explains the field data\n2) Regularization: constraints placed on the recovered model and a priori information\n3) Coupling: a connection of two different physical property models\n4) Optimization: the numerical approach used to solve the inverse problem\n\n# Define the data misfit. Here the data misfit is the L2 norm of the weighted\n# residual between the observed data and the data predicted for a given model.\n# Within the data misfit, the residual between predicted and observed data are\n# normalized by the data's standard deviation.\ndmis_grav = data_misfit.L2DataMisfit(data=data_object_grav, simulation=simulation_grav)\ndmis_mag = data_misfit.L2DataMisfit(data=data_object_mag, simulation=simulation_mag)\n\n# Define the regularization (model objective function).\nreg_grav = regularization.WeightedLeastSquares(\n    mesh, active_cells=ind_active, mapping=wires.density\n)\nreg_mag = regularization.WeightedLeastSquares(\n    mesh, active_cells=ind_active, mapping=wires.susceptibility\n)\n\n# Define the coupling term to connect two different physical property models\nlamda = 2e12  # weight for coupling term\ncross_grad = regularization.CrossGradient(mesh, wires, active_cells=ind_active)\n\n# combo\ndmis = dmis_grav + dmis_mag\nreg = reg_grav + reg_mag + lamda * cross_grad\n\n# Define how the optimization problem is solved. Here we will use a projected\n# Gauss-Newton approach that employs the conjugate gradient solver.\nopt = optimization.ProjectedGNCG(\n    maxIter=10,\n    lower=-2.0,\n    upper=2.0,\n    maxIterLS=20,\n    maxIterCG=100,\n    tolCG=1e-3,\n    tolX=1e-3,\n)\n\n# Here we define the inverse problem that is to be solved\ninv_prob = inverse_problem.BaseInvProblem(dmis, reg, opt)\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#define-the-inverse-problem","position":21},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define Inversion Directives"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#define-inversion-directives","position":22},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Define Inversion Directives"},"content":"Here we define any directiveas that are carried out during the inversion. This\nincludes the cooling schedule for the trade-off parameter (beta), stopping\ncriteria for the inversion and saving inversion results at each iteration.\n\n# Defining a starting value for the trade-off parameter (beta) between the data\n# misfit and the regularization.\nstarting_beta = directives.PairedBetaEstimate_ByEig(beta0_ratio=1e0)\n# starting_beta.n_pw_iter = 10\n\n# Defining the fractional decrease in beta and the number of Gauss-Newton solves\n# for each beta value.\nbeta_schedule = directives.PairedBetaSchedule(cooling_factor=5, cooling_rate=1)\n\n# Options for outputting recovered models and predicted data for each beta.\nsave_iteration = directives.SimilarityMeasureSaveOutputEveryIteration(save_txt=False)\n\njoint_inv_dir = directives.SimilarityMeasureInversionDirective()\n\nstopping = directives.MovingAndMultiTargetStopping(tol=1e-6)\n\nsensitivity_weights = directives.UpdateSensitivityWeights(every_iteration=False)\n\n# Updating the preconditionner if it is model dependent.\nupdate_jacobi = directives.UpdatePreconditioner()\n\n\n# The directives are defined as a list.\ndirectives_list = [\n    joint_inv_dir,\n    sensitivity_weights,\n    stopping,\n    starting_beta,\n    beta_schedule,\n    save_iteration,\n    update_jacobi,\n]\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#define-inversion-directives","position":23},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Running the Inversion"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#running-the-inversion","position":24},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Running the Inversion"},"content":"To define the inversion object, we need to define the inversion problem and\nthe set of directives. We can then run the inversion.\n\n# Here we combine the inverse problem and the set of directives\ninv = inversion.BaseInversion(inv_prob, directives_list)\n\n# Run inversion\nrecovered_model = inv.run(starting_model)\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#running-the-inversion","position":25},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Plotting True Model and Recovered Model"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#plotting-true-model-and-recovered-model","position":26},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Plotting True Model and Recovered Model"},"content":"\n\n# Load the true model (was defined on the whole mesh) and extract only the\n# values on active cells.\n\ntrue_model_dens = np.loadtxt(dir_path + \"true_model_dens.txt\")\ntrue_model_dens[~ind_active] = np.nan\n\ntrue_model_susc = np.loadtxt(dir_path + \"true_model_susc.txt\")\ntrue_model_susc[~ind_active] = np.nan\n\n# Plot True Model\nfig = plt.figure(figsize=(9, 8))\nax1 = plt.subplot(211)\n\n(im,) = mesh.plot_slice(true_model_dens, normal=\"Y\", ax=ax1, grid=True)\nax1.set_title(\"True density model slice at y = 0 m\")\ncbar = plt.colorbar(im, format=\"%.1e\")\ncbar.set_label(\"g/cc\", rotation=270, labelpad=15, size=12)\n\nax2 = plt.subplot(212)\n(im,) = mesh.plot_slice(\n    true_model_susc, normal=\"Y\", ax=ax2, grid=True, pcolor_opts={\"cmap\": \"inferno\"}\n)\n\nax2.set_title(\"True susceptibility model slice at y = 0 m\")\ncbar = plt.colorbar(im, format=\"%.1e\")\ncbar.set_label(\"SI\", rotation=270, labelpad=15, size=12)\nplt.tight_layout()\nplt.show()\n\n# Plot Recovered Model\nm_dens_joint, m_susc_joint = wires * recovered_model\nplotting_map = maps.InjectActiveCells(mesh, ind_active, np.nan)\n\nfig = plt.figure(figsize=(9, 8))\nax1 = plt.subplot(211)\n(im,) = mesh.plot_slice(\n    plotting_map * m_dens_joint,\n    normal=\"Y\",\n    ax=ax1,\n    clim=(-0.04, 0.03),\n)\nax1.set_title(\"Density model slice at y = 0 m\")\ncbar = plt.colorbar(im)\ncbar.set_label(\"g/cc\", rotation=270, labelpad=15, size=12)\n\nax2 = plt.subplot(212)\n(im,) = mesh.plot_slice(\n    plotting_map * m_susc_joint, normal=\"Y\", ax=ax2, pcolor_opts={\"cmap\": \"inferno\"}\n)\nax2.set_title(\"Susceptibility model slice at y = 0 m\")\ncbar = plt.colorbar(im)\ncbar.set_label(\"SI\", rotation=270, labelpad=15, size=12)\n\nplt.tight_layout()\nplt.show()\n\n","type":"content","url":"/plot-inv-3-cross-gradient-pf#plotting-true-model-and-recovered-model","position":27},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Comparing jointly and separatly recovered models"},"type":"lvl2","url":"/plot-inv-3-cross-gradient-pf#comparing-jointly-and-separatly-recovered-models","position":28},{"hierarchy":{"lvl1":"Cross-gradient Joint Inversion of Gravity and Magnetic Anomaly Data","lvl2":"Comparing jointly and separatly recovered models"},"content":"\n\n# Normalized Cross Gradient of Jointly Recovered Susceptibility and Density Models\nncg = cross_grad.calculate_cross_gradient(recovered_model, normalized=True)\n\nfig = plt.figure(figsize=(9, 4))\nax = plt.subplot(111)\n(im,) = mesh.plot_slice(\n    plotting_map * ncg,\n    normal=\"Y\",\n    ax=ax,\n    grid=True,\n)\nax.set_title(\"Normalized cross gradient for joint inversion slice at y = 0 m\")\ncbar = plt.colorbar(im, format=\"%.1e\")\ncbar.set_label(\"|cross grad|\", rotation=270, labelpad=15, size=12)\nplt.show()\n\n# Normalized Cross Gradient of Separately Recovered Susceptibility and Density Models\nm_dens_single = np.loadtxt(dir_path + \"single_model_dens.txt\")\nm_susc_single = np.loadtxt(dir_path + \"single_model_susc.txt\")\nm_separate = np.r_[m_dens_single[ind_active], m_susc_single[ind_active]]\n\nncg_single = cross_grad.calculate_cross_gradient(m_separate, normalized=True)\n\nfig = plt.figure(figsize=(9, 4))\nax = plt.subplot(111)\n(im,) = mesh.plot_slice(\n    plotting_map * ncg_single,\n    normal=\"Y\",\n    ax=ax,\n    grid=True,\n)\nax.set_title(\"Normalized cross gradient for separate inversion slice at y = 0 m\")\ncbar = plt.colorbar(im, format=\"%.1e\")\ncbar.set_label(\"|cross grad|\", rotation=270, labelpad=15, size=12)\n\nplt.show()\n\n\n# Cross Plots Recovered Susceptibility and Density Models\nfig = plt.figure(figsize=(14, 5))\nax0 = plt.subplot(121)\nax0.scatter(\n    plotting_map * m_dens_joint, plotting_map * m_susc_joint, s=4, c=\"black\", alpha=0.1\n)\n\nax0.set_xlabel(\"Density\", size=12)\nax0.set_ylabel(\"Susceptibility\", size=12)\nax0.tick_params(labelsize=12)\nax0.set_title(\"Joint inversion\")\n\nax1 = plt.subplot(122)\nax1.scatter(m_dens_single, m_susc_single, s=4, c=\"black\", alpha=0.1)\n\nax1.set_xlabel(\"Density\", size=12)\nax1.set_ylabel(\"Susceptibility\", size=12)\nax1.tick_params(labelsize=12)\nax1.set_title(\"Separate inversion\")\n\nplt.show()","type":"content","url":"/plot-inv-3-cross-gradient-pf#comparing-jointly-and-separatly-recovered-models","position":29},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information"},"type":"lvl1","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial","position":0},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information"},"content":"%matplotlib inline\n\nThis tutorial shows through a joint inversion of Gravity and Magnetic data on an\nOctree mesh how to use the PGI framework introduced in Astic & Oldenburg (2019)\nand Astic et al. (2021) to include petrophysical information into geophysical\ninversions for mutli-physics inversion.\n\nThibaut Astic, Douglas W. Oldenburg,\nA framework for petrophysically and geologically guided geophysical inversion\nusing a dynamic Gaussian mixture model prior, Geophysical Journal International,\nVolume 219, Issue 3, December 2019, Pages 1989–2012, DOI:\n10.1093/gji/ggz389 <https://doi.org/10.1093/gji/ggz389>_.\n\nThibaut Astic, Lindsey J. Heagy, Douglas W Oldenburg,\nPetrophysically and geologically guided multi-physics inversion using a dynamic\nGaussian mixture model, Geophysical Journal International,\nVolume 224, Issue 1, January 2021, Pages 40-68, DOI: 10.1093/gji/ggaa378 <https://doi.org/10.1093/gji/ggaa378>_.\n\n","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial","position":1},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Import modules"},"type":"lvl2","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#import-modules","position":2},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Import modules"},"content":"\n\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport simpeg.potential_fields as pf\nfrom simpeg import (\n    data_misfit,\n    directives,\n    inverse_problem,\n    inversion,\n    maps,\n    optimization,\n    regularization,\n    utils,\n)\nfrom simpeg.utils import io_utils\n\n","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#import-modules","position":3},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Setup"},"type":"lvl2","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#setup","position":4},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Setup"},"content":"\n\n# Load Mesh\nmesh_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/mesh_tutorial.ubc\"\n)\nmesh = TreeMesh.read_UBC(mesh_file)\n\n# Load True geological model for comparison with inversion result\ntrue_geology_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/geology_true.mod\"\n)\ntrue_geology = mesh.read_model_UBC(true_geology_file)\n\n# Plot true geology model\nfig, ax = plt.subplots(1, 4, figsize=(20, 4))\nticksize, labelsize = 14, 16\nfor _, axx in enumerate(ax):\n    axx.set_aspect(1)\n    axx.tick_params(labelsize=ticksize)\nmesh.plot_slice(\n    true_geology,\n    normal=\"X\",\n    ax=ax[0],\n    ind=-17,\n    clim=[0, 2],\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\nmesh.plot_slice(\n    true_geology,\n    normal=\"Y\",\n    ax=ax[1],\n    clim=[0, 2],\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\ngeoplot = mesh.plot_slice(\n    true_geology,\n    normal=\"Z\",\n    ax=ax[2],\n    clim=[0, 2],\n    ind=-10,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\ngeocb = plt.colorbar(geoplot[0], cax=ax[3], ticks=[0, 1, 2])\ngeocb.set_label(\n    \"True geology model\\n(classification/density/mag. susc.)\", fontsize=labelsize\n)\ngeocb.set_ticklabels(\n    [\"BCKGRD (0 g/cc; 0 SI)\", \"PK (-0.8 g/cc; 5e-3 SI)\", \"VK (-0.2 g/cc; 2e-2 SI)\"]\n)\ngeocb.ax.tick_params(labelsize=ticksize)\nax[3].set_aspect(10)\nplt.show()\n\n# Load geophysical data\ndata_grav_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/gravity_data.obs\"\n)\ndata_grav = io_utils.read_grav3d_ubc(data_grav_file)\ndata_mag_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/magnetic_data.obs\"\n)\ndata_mag = io_utils.read_mag3d_ubc(data_mag_file)\n\n# plot data and mesh\nfig, ax = plt.subplots(2, 2, figsize=(15, 10))\nax = ax.reshape(-1)\nplt.gca().set_aspect(\"equal\")\nplt.gca().set_xlim(\n    [\n        data_mag.survey.receiver_locations[:, 0].min(),\n        data_mag.survey.receiver_locations[:, 0].max(),\n    ],\n)\nplt.gca().set_ylim(\n    [\n        data_mag.survey.receiver_locations[:, 1].min(),\n        data_mag.survey.receiver_locations[:, 1].max(),\n    ],\n)\nmesh.plot_slice(\n    np.ones(mesh.nC),\n    normal=\"Z\",\n    ind=int(-10),\n    grid=True,\n    pcolor_opts={\"cmap\": \"Greys\"},\n    ax=ax[0],\n)\nmm = utils.plot2Ddata(\n    data_grav.survey.receiver_locations,\n    -data_grav.dobs,\n    ax=ax[0],\n    level=True,\n    nx=20,\n    ny=20,\n    dataloc=True,\n    ncontour=12,\n    shade=True,\n    contourOpts={\"cmap\": \"Blues_r\", \"alpha\": 0.8},\n    levelOpts={\"colors\": \"k\", \"linewidths\": 0.5, \"linestyles\": \"dashed\"},\n)\nax[0].set_aspect(1)\nax[0].set_title(\n    \"Gravity data values and locations,\\nwith mesh and geology overlays\", fontsize=16\n)\nplt.colorbar(mm[0], cax=ax[2], orientation=\"horizontal\")\nax[2].set_aspect(0.05)\nax[2].set_title(\"mGal\", fontsize=16)\nmesh.plot_slice(\n    np.ones(mesh.nC),\n    normal=\"Z\",\n    ind=int(-10),\n    grid=True,\n    pcolor_opts={\"cmap\": \"Greys\"},\n    ax=ax[1],\n)\nmm = utils.plot2Ddata(\n    data_mag.survey.receiver_locations,\n    data_mag.dobs,\n    ax=ax[1],\n    level=True,\n    nx=20,\n    ny=20,\n    dataloc=True,\n    ncontour=11,\n    shade=True,\n    contourOpts={\"cmap\": \"Reds\", \"alpha\": 0.8},\n    levelOpts={\"colors\": \"k\", \"linewidths\": 0.5, \"linestyles\": \"dashed\"},\n)\nax[1].set_aspect(1)\nax[1].set_title(\n    \"Magnetic data values and locations,\\nwith mesh and geology overlays\", fontsize=16\n)\nplt.colorbar(mm[0], cax=ax[3], orientation=\"horizontal\")\nax[3].set_aspect(0.05)\nax[3].set_title(\"nT\", fontsize=16)\n# overlay true geology model for comparison\nindz = -9\nindslicezplot = mesh.gridCC[:, 2] == mesh.cell_centers_z[indz]\nfor i in range(2):\n    utils.plot2Ddata(\n        mesh.gridCC[indslicezplot][:, [0, 1]],\n        true_geology[indslicezplot],\n        nx=200,\n        ny=200,\n        contourOpts={\"alpha\": 0},\n        clim=[0, 2],\n        ax=ax[i],\n        level=True,\n        ncontour=2,\n        levelOpts={\"colors\": \"k\", \"linewidths\": 2, \"linestyles\": \"--\"},\n        method=\"nearest\",\n    )\nplt.subplots_adjust(hspace=-0.25, wspace=0.1)\nplt.show()\n\n# Load Topo\ntopo_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/CDED_Lake_warp.xyz\"\n)\ntopo = np.genfromtxt(topo_file, skip_header=1)\n# find the active cells\nactv = active_from_xyz(mesh, topo, \"CC\")\n# Create active map to go from reduce set to full\nndv = np.nan\nactvMap = maps.InjectActiveCells(mesh, actv, ndv)\nnactv = int(actv.sum())\n\n# Create simulations and data misfits\n# Wires mapping\nwires = maps.Wires((\"den\", actvMap.nP), (\"sus\", actvMap.nP))\ngravmap = actvMap * wires.den\nmagmap = actvMap * wires.sus\nidenMap = maps.IdentityMap(nP=nactv)\n# Grav problem\nsimulation_grav = pf.gravity.simulation.Simulation3DIntegral(\n    survey=data_grav.survey,\n    mesh=mesh,\n    rhoMap=wires.den,\n    active_cells=actv,\n    engine=\"choclo\",\n)\ndmis_grav = data_misfit.L2DataMisfit(data=data_grav, simulation=simulation_grav)\n# Mag problem\nsimulation_mag = pf.magnetics.simulation.Simulation3DIntegral(\n    survey=data_mag.survey,\n    mesh=mesh,\n    chiMap=wires.sus,\n    active_cells=actv,\n    engine=\"choclo\",\n)\ndmis_mag = data_misfit.L2DataMisfit(data=data_mag, simulation=simulation_mag)\n\n","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#setup","position":5},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Create a joint Data Misfit"},"type":"lvl2","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#create-a-joint-data-misfit","position":6},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Create a joint Data Misfit"},"content":"\n\n# Joint data misfit\ndmis = 0.5 * dmis_grav + 0.5 * dmis_mag\n\n# initial model\nm0 = np.r_[-1e-4 * np.ones(actvMap.nP), 1e-4 * np.ones(actvMap.nP)]\n\n","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#create-a-joint-data-misfit","position":7},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Inversion with full petrophysical information"},"type":"lvl2","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#inversion-with-full-petrophysical-information","position":8},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Inversion with full petrophysical information"},"content":"\n\n","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#inversion-with-full-petrophysical-information","position":9},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Create and plot a petrophysical GMM with full information"},"type":"lvl2","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#create-and-plot-a-petrophysical-gmm-with-full-information","position":10},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Create and plot a petrophysical GMM with full information"},"content":"The GMM is our representation of the petrophysical and geological information.\nHere, we focus on the petrophysical aspect, with the means and covariances of\nthe physical properties of each rock unit.\nTo generate the data above, the PK unit was populated with a density contrast\nof -0.8 g/cc and a magnetic susceptibility of 0.005 SI. The properties of the\nHK unit were set at -0.2 g/cc and 0.02 SI. The covariances matrices are set\nso that we assume petrophysical noise levels of around 0.05 g/cc and 0.001 SI\nfor both unit. Finally the background unit is set at null contrasts (0 g/cc\n0 SI) with a petrophysical noise level of half of the above.\n\ngmmref = utils.WeightedGaussianMixture(\n    n_components=3,  # number of rock units: bckgrd, PK, HK\n    mesh=mesh,  # inversion mesh\n    actv=actv,  # actv cells\n    covariance_type=\"diag\",  # diagonal covariances\n)\n# required: initialization with fit\n# fake random samples, size of the mesh, number of physical properties: 2 (density and mag.susc)\nrng = np.random.default_rng(seed=518936)\ngmmref.fit(rng.normal(size=(nactv, 2)))\n# set parameters manually\n# set phys. prop means for each unit\ngmmref.means_ = np.c_[\n    [0.0, 0.0],  # BCKGRD density contrast and mag. susc\n    [-0.8, 0.005],  # PK\n    [-0.2, 0.02],  # HK\n].T\n# set phys. prop covariances for each unit\ngmmref.covariances_ = np.array(\n    [[6e-04, 3.175e-07], [2.4e-03, 1.5e-06], [2.4e-03, 1.5e-06]]\n)\n# important after setting cov. manually: compute precision matrices and cholesky\ngmmref.compute_clusters_precisions()\n# set global proportions; low-impact as long as not 0 or 1 (total=1)\ngmmref.weights_ = np.r_[0.9, 0.075, 0.025]\n\n# Plot the 2D GMM\nax = gmmref.plot_pdf(flag2d=True)\nax[0].set_xlabel(\"Density contrast [g/cc]\")\nax[0].set_ylim([0, 5])\nax[2].set_ylabel(\"magnetic Susceptibility [SI]\")\nax[2].set_xlim([0, 100])\nplt.show()\n\n","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#create-and-plot-a-petrophysical-gmm-with-full-information","position":11},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Create PGI regularization"},"type":"lvl2","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#create-pgi-regularization","position":12},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Create PGI regularization"},"content":"\n\n# Sensitivity weighting\nwr_grav = np.sum(simulation_grav.G**2.0, axis=0) ** 0.5 / (mesh.cell_volumes[actv])\nwr_grav = wr_grav / np.max(wr_grav)\n\nwr_mag = np.sum(simulation_mag.G**2.0, axis=0) ** 0.5 / (mesh.cell_volumes[actv])\nwr_mag = wr_mag / np.max(wr_mag)\n\n# create joint PGI regularization with smoothness\nreg = regularization.PGI(\n    gmmref=gmmref,\n    mesh=mesh,\n    wiresmap=wires,\n    maplist=[idenMap, idenMap],\n    active_cells=actv,\n    alpha_pgi=1.0,\n    alpha_x=1.0,\n    alpha_y=1.0,\n    alpha_z=1.0,\n    alpha_xx=0.0,\n    alpha_yy=0.0,\n    alpha_zz=0.0,\n    # use the classification of the initial model (here, all background unit)\n    # as initial reference model\n    reference_model=utils.mkvc(\n        gmmref.means_[gmmref.predict(m0.reshape(actvMap.nP, -1))]\n    ),\n    weights_list=[wr_grav, wr_mag],  # weights each phys. prop. by correct sensW\n)\n\n","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#create-pgi-regularization","position":13},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Inverse problem with full petrophysical information"},"type":"lvl2","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#inverse-problem-with-full-petrophysical-information","position":14},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","lvl2":"Inverse problem with full petrophysical information"},"content":"\n\n# Directives\n# Add directives to the inversion\n# ratio to use for each phys prop. smoothness in each direction;\n# roughly the ratio of the order of magnitude of each phys. prop.\nalpha0_ratio = np.r_[\n    1e-4 * np.ones(len(reg.objfcts[1].objfcts[1:])),\n    1e-4 * 100.0 * np.ones(len(reg.objfcts[2].objfcts[1:])),\n]\nAlphas = directives.AlphasSmoothEstimate_ByEig(alpha0_ratio=alpha0_ratio, verbose=True)\n# initialize beta and beta/alpha_pgi schedule\nbeta = directives.BetaEstimate_ByEig(beta0_ratio=1e-2)\nbetaIt = directives.PGI_BetaAlphaSchedule(\n    verbose=True,\n    coolingFactor=2.0,\n    tolerance=0.2,\n    progress=0.2,\n)\n# geophy. and petro. target misfits\ntargets = directives.MultiTargetMisfits(\n    verbose=True,\n)\n# add learned mref in smooth once stable\nMrefInSmooth = directives.PGI_AddMrefInSmooth(\n    wait_till_stable=True,\n    verbose=True,\n)\n# update the parameters in smallness (L2-approx of PGI)\nupdate_smallness = directives.PGI_UpdateParameters(\n    update_gmm=False  # keep GMM model fixed\n)\n# pre-conditioner\nupdate_Jacobi = directives.UpdatePreconditioner()\n# iteratively balance the scaling of the data misfits\nscaling_init = directives.ScalingMultipleDataMisfits_ByEig(chi0_ratio=[1.0, 100.0])\nscale_schedule = directives.JointScalingSchedule(verbose=True)\n\n# Create inverse problem\n# Optimization\n# set lower and upper bounds\nlowerbound = np.r_[-2.0 * np.ones(actvMap.nP), 0.0 * np.ones(actvMap.nP)]\nupperbound = np.r_[0.0 * np.ones(actvMap.nP), 1e-1 * np.ones(actvMap.nP)]\nopt = optimization.ProjectedGNCG(\n    maxIter=30,\n    lower=lowerbound,\n    upper=upperbound,\n    maxIterLS=20,\n    maxIterCG=100,\n    tolCG=1e-4,\n)\n# create inverse problem\ninvProb = inverse_problem.BaseInvProblem(dmis, reg, opt)\ninv = inversion.BaseInversion(\n    invProb,\n    # directives: evaluate alphas (and data misfits scales) before beta\n    directiveList=[\n        Alphas,\n        scaling_init,\n        beta,\n        update_smallness,\n        targets,\n        scale_schedule,\n        betaIt,\n        MrefInSmooth,\n        update_Jacobi,\n    ],\n)\n\n# invert\npgi_model = inv.run(m0)\n\n# Extract the results\ndensity_model = gravmap * pgi_model\nmagsus_model = magmap * pgi_model\nquasi_geology_model = actvMap * reg.objfcts[0].compute_quasi_geology_model()\n\n# Plot the result with full petrophysical information\nfig, ax = plt.subplots(3, 4, figsize=(15, 10))\nfor _, axx in enumerate(ax):\n    for _, axxx in enumerate(axx):\n        axxx.set_aspect(1)\n        axxx.tick_params(labelsize=ticksize)\n\nindx = 15\nindy = 17\nindz = -9\n# geology model\nmesh.plot_slice(\n    quasi_geology_model,\n    normal=\"X\",\n    ax=ax[0, 0],\n    clim=[0, 2],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\nmesh.plot_slice(\n    quasi_geology_model,\n    normal=\"Y\",\n    ax=ax[0, 1],\n    clim=[0, 2],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\ngeoplot = mesh.plot_slice(\n    quasi_geology_model,\n    normal=\"Z\",\n    ax=ax[0, 2],\n    clim=[0, 2],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\ngeocb = plt.colorbar(geoplot[0], cax=ax[0, 3], ticks=[0, 1, 2])\ngeocb.set_ticklabels([\"BCK\", \"PK\", \"VK\"])\ngeocb.set_label(\"Quasi-Geology model\\n(Rock units classification)\", fontsize=16)\nax[0, 3].set_aspect(10)\n\n# gravity model\nmesh.plot_slice(\n    density_model,\n    normal=\"X\",\n    ax=ax[1, 0],\n    clim=[-1, 0],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\nmesh.plot_slice(\n    density_model,\n    normal=\"Y\",\n    ax=ax[1, 1],\n    clim=[-1, 0],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\ndenplot = mesh.plot_slice(\n    density_model,\n    normal=\"Z\",\n    ax=ax[1, 2],\n    clim=[-1, 0],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\ndencb = plt.colorbar(denplot[0], cax=ax[1, 3])\ndencb.set_label(\"Density contrast\\nmodel (g/cc)\", fontsize=16)\nax[1, 3].set_aspect(10)\n\n# magnetic model\nmesh.plot_slice(\n    magsus_model,\n    normal=\"X\",\n    ax=ax[2, 0],\n    clim=[0, 0.025],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nmesh.plot_slice(\n    magsus_model,\n    normal=\"Y\",\n    ax=ax[2, 1],\n    clim=[0, 0.025],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nsusplot = mesh.plot_slice(\n    magsus_model,\n    normal=\"Z\",\n    ax=ax[2, 2],\n    clim=[0, 0.025],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nsuscb = plt.colorbar(susplot[0], cax=ax[2, 3])\nsuscb.set_label(\"Magnetic susceptibility\\nmodel (SI)\", fontsize=16)\nax[2, 3].set_aspect(10)\n\n# overlay true geology model for comparison\nindslicexplot = mesh.gridCC[:, 0] == mesh.cell_centers_x[indx]\nindsliceyplot = mesh.gridCC[:, 1] == mesh.cell_centers_y[indy]\nindslicezplot = mesh.gridCC[:, 2] == mesh.cell_centers_z[indz]\nfor i in range(3):\n    for j, (plane, indd) in enumerate(\n        zip([[1, 2], [0, 2], [0, 1]], [indslicexplot, indsliceyplot, indslicezplot])\n    ):\n        utils.plot2Ddata(\n            mesh.gridCC[indd][:, plane],\n            true_geology[indd],\n            nx=100,\n            ny=100,\n            contourOpts={\"alpha\": 0},\n            clim=[0, 2],\n            ax=ax[i, j],\n            level=True,\n            ncontour=2,\n            levelOpts={\"colors\": \"grey\", \"linewidths\": 2, \"linestyles\": \"--\"},\n            method=\"nearest\",\n        )\n\n# plot the locations of the cross-sections\nfor i in range(3):\n    ax[i, 0].plot(\n        mesh.cell_centers_y[indy] * np.ones(2), [-300, 500], c=\"k\", linestyle=\"dotted\"\n    )\n    ax[i, 0].plot(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n        mesh.cell_centers_z[indz] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 0].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n    )\n\n    ax[i, 1].plot(\n        mesh.cell_centers_x[indx] * np.ones(2), [-300, 500], c=\"k\", linestyle=\"dotted\"\n    )\n    ax[i, 1].plot(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n        mesh.cell_centers_z[indz] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 1].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n    )\n\n    ax[i, 2].plot(\n        mesh.cell_centers_x[indx] * np.ones(2),\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 2].plot(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n        mesh.cell_centers_y[indy] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 2].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n    )\n    ax[i, 2].set_ylim(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n    )\n\nplt.tight_layout()\nplt.show()\n\n# Plot the 2D GMM\nfig = plt.figure(figsize=(10, 10))\nax0 = plt.subplot2grid((4, 4), (3, 1), colspan=3)\nax1 = plt.subplot2grid((4, 4), (0, 1), colspan=3, rowspan=3)\nax2 = plt.subplot2grid((4, 4), (0, 0), rowspan=3)\nax = [ax0, ax1, ax2]\nreg.objfcts[0].gmm.plot_pdf(flag2d=True, ax=ax, padding=0.5)\nax[0].set_xlabel(\"Density contrast [g/cc]\")\nax[0].set_ylim([0, 5])\nax[2].set_xlim([0, 50])\nax[2].set_ylabel(\"magnetic Susceptibility [SI]\")\nax[1].scatter(\n    density_model[actv],\n    magsus_model[actv],\n    c=quasi_geology_model[actv],\n    cmap=\"inferno_r\",\n    edgecolors=\"k\",\n    label=\"recovered PGI model\",\n    alpha=0.5,\n)\nax[1].legend()\nax[0].hist(density_model[actv], density=True, bins=50)\nax[2].hist(magsus_model[actv], density=True, bins=50, orientation=\"horizontal\")\nplt.show()","type":"content","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial#inverse-problem-with-full-petrophysical-information","position":15},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information"},"type":"lvl1","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial","position":0},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information"},"content":"%matplotlib inline\n\nThis tutorial shows through a joint inversion of Gravity and Magnetic data on an\nOctree mesh how to use the PGI framework introduced in Astic & Oldenburg (2019)\nand Astic et al. (2021) to make geologic assumptions and learn a suitable\npetrophysical distribution when no quantitative petrophysical information is\navailable.\n\nThibaut Astic, Douglas W. Oldenburg,\nA framework for petrophysically and geologically guided geophysical inversion\nusing a dynamic Gaussian mixture model prior, Geophysical Journal International,\nVolume 219, Issue 3, December 2019, Pages 1989–2012, DOI:\n10.1093/gji/ggz389 <https://doi.org/10.1093/gji/ggz389>_.\n\nThibaut Astic, Lindsey J. Heagy, Douglas W Oldenburg,\nPetrophysically and geologically guided multi-physics inversion using a dynamic\nGaussian mixture model, Geophysical Journal International,\nVolume 224, Issue 1, January 2021, Pages 40-68, DOI: 10.1093/gji/ggaa378 <https://doi.org/10.1093/gji/ggaa378>_.\n\n","type":"content","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial","position":1},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Import modules"},"type":"lvl2","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#import-modules","position":2},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Import modules"},"content":"\n\nfrom discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport simpeg.potential_fields as pf\nfrom simpeg import (\n    data_misfit,\n    directives,\n    inverse_problem,\n    inversion,\n    maps,\n    optimization,\n    regularization,\n    utils,\n)\nfrom simpeg.utils import io_utils\n\n","type":"content","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#import-modules","position":3},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Setup"},"type":"lvl2","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#setup","position":4},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Setup"},"content":"\n\n# Load Mesh\nmesh_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/mesh_tutorial.ubc\"\n)\nmesh = TreeMesh.read_UBC(mesh_file)\n\n# Load True geological model for comparison with inversion result\ntrue_geology_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/geology_true.mod\"\n)\ntrue_geology = mesh.read_model_UBC(true_geology_file)\n\n# Plot true geology model\nfig, ax = plt.subplots(1, 4, figsize=(20, 4))\nticksize, labelsize = 14, 16\nfor _, axx in enumerate(ax):\n    axx.set_aspect(1)\n    axx.tick_params(labelsize=ticksize)\nmesh.plot_slice(\n    true_geology,\n    normal=\"X\",\n    ax=ax[0],\n    ind=-17,\n    clim=[0, 2],\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\nmesh.plot_slice(\n    true_geology,\n    normal=\"Y\",\n    ax=ax[1],\n    clim=[0, 2],\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\ngeoplot = mesh.plot_slice(\n    true_geology,\n    normal=\"Z\",\n    ax=ax[2],\n    clim=[0, 2],\n    ind=-10,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\ngeocb = plt.colorbar(geoplot[0], cax=ax[3], ticks=[0, 1, 2])\ngeocb.set_label(\n    \"True geology model\\n(classification/density/mag. susc.)\", fontsize=labelsize\n)\ngeocb.set_ticklabels(\n    [\"BCKGRD (0 g/cc; 0 SI)\", \"PK (-0.8 g/cc; 5e-3 SI)\", \"VK (-0.2 g/cc; 2e-2 SI)\"]\n)\ngeocb.ax.tick_params(labelsize=ticksize)\nax[3].set_aspect(10)\nplt.show()\n\n# Load geophysical data\ndata_grav_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/gravity_data.obs\"\n)\ndata_grav = io_utils.read_grav3d_ubc(data_grav_file)\ndata_mag_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/magnetic_data.obs\"\n)\ndata_mag = io_utils.read_mag3d_ubc(data_mag_file)\n\n# plot data and mesh\nfig, ax = plt.subplots(2, 2, figsize=(15, 10))\nax = ax.reshape(-1)\nplt.gca().set_aspect(\"equal\")\nplt.gca().set_xlim(\n    [\n        data_mag.survey.receiver_locations[:, 0].min(),\n        data_mag.survey.receiver_locations[:, 0].max(),\n    ],\n)\nplt.gca().set_ylim(\n    [\n        data_mag.survey.receiver_locations[:, 1].min(),\n        data_mag.survey.receiver_locations[:, 1].max(),\n    ]\n)\nmesh.plot_slice(\n    np.ones(mesh.nC),\n    normal=\"Z\",\n    ind=int(-10),\n    grid=True,\n    pcolor_opts={\"cmap\": \"Greys\"},\n    ax=ax[0],\n)\nmm = utils.plot2Ddata(\n    data_grav.survey.receiver_locations,\n    -data_grav.dobs,\n    ax=ax[0],\n    level=True,\n    nx=20,\n    ny=20,\n    dataloc=True,\n    ncontour=12,\n    shade=True,\n    contourOpts={\"cmap\": \"Blues_r\", \"alpha\": 0.8},\n    levelOpts={\"colors\": \"k\", \"linewidths\": 0.5, \"linestyles\": \"dashed\"},\n)\nax[0].set_aspect(1)\nax[0].set_title(\n    \"Gravity data values and locations,\\nwith mesh and geology overlays\", fontsize=16\n)\nplt.colorbar(mm[0], cax=ax[2], orientation=\"horizontal\")\nax[2].set_aspect(0.05)\nax[2].set_title(\"mGal\", fontsize=16)\nmesh.plot_slice(\n    np.ones(mesh.nC),\n    normal=\"Z\",\n    ind=int(-10),\n    grid=True,\n    pcolor_opts={\"cmap\": \"Greys\"},\n    ax=ax[1],\n)\nmm = utils.plot2Ddata(\n    data_mag.survey.receiver_locations,\n    data_mag.dobs,\n    ax=ax[1],\n    level=True,\n    nx=20,\n    ny=20,\n    dataloc=True,\n    ncontour=11,\n    shade=True,\n    contourOpts={\"cmap\": \"Reds\", \"alpha\": 0.8},\n    levelOpts={\"colors\": \"k\", \"linewidths\": 0.5, \"linestyles\": \"dashed\"},\n)\nax[1].set_aspect(1)\nax[1].set_title(\n    \"Magnetic data values and locations,\\nwith mesh and geology overlays\", fontsize=16\n)\nplt.colorbar(mm[0], cax=ax[3], orientation=\"horizontal\")\nax[3].set_aspect(0.05)\nax[3].set_title(\"nT\", fontsize=16)\n# overlay true geology model for comparison\nindz = -9\nindslicezplot = mesh.gridCC[:, 2] == mesh.cell_centers_z[indz]\nfor i in range(2):\n    utils.plot2Ddata(\n        mesh.gridCC[indslicezplot][:, [0, 1]],\n        true_geology[indslicezplot],\n        nx=200,\n        ny=200,\n        contourOpts={\"alpha\": 0},\n        clim=[0, 2],\n        ax=ax[i],\n        level=True,\n        ncontour=2,\n        levelOpts={\"colors\": \"k\", \"linewidths\": 2, \"linestyles\": \"--\"},\n        method=\"nearest\",\n    )\nplt.subplots_adjust(hspace=-0.25, wspace=0.1)\nplt.show()\n\n# Load Topo\ntopo_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/CDED_Lake_warp.xyz\"\n)\ntopo = np.genfromtxt(topo_file, skip_header=1)\n# find the active cells\nactv = active_from_xyz(mesh, topo, \"CC\")\n# Create active map to go from reduce set to full\nndv = np.nan\nactvMap = maps.InjectActiveCells(mesh, actv, ndv)\nnactv = int(actv.sum())\n\n# Create simulations and data misfits\n# Wires mapping\nwires = maps.Wires((\"den\", actvMap.nP), (\"sus\", actvMap.nP))\ngravmap = actvMap * wires.den\nmagmap = actvMap * wires.sus\nidenMap = maps.IdentityMap(nP=nactv)\n# Grav problem\nsimulation_grav = pf.gravity.simulation.Simulation3DIntegral(\n    survey=data_grav.survey,\n    mesh=mesh,\n    rhoMap=wires.den,\n    active_cells=actv,\n    engine=\"choclo\",\n)\ndmis_grav = data_misfit.L2DataMisfit(data=data_grav, simulation=simulation_grav)\n# Mag problem\nsimulation_mag = pf.magnetics.simulation.Simulation3DIntegral(\n    survey=data_mag.survey,\n    mesh=mesh,\n    chiMap=wires.sus,\n    active_cells=actv,\n    engine=\"choclo\",\n)\ndmis_mag = data_misfit.L2DataMisfit(data=data_mag, simulation=simulation_mag)\n\nCreate a joint Data Misfit\n\n# Joint data misfit\ndmis = 0.5 * dmis_grav + 0.5 * dmis_mag\n\n# initial model\nm0 = np.r_[-1e-4 * np.ones(actvMap.nP), 1e-4 * np.ones(actvMap.nP)]\n\n","type":"content","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#setup","position":5},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Inversion with no petrophysical information about the means"},"type":"lvl2","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#inversion-with-no-petrophysical-information-about-the-means","position":6},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Inversion with no petrophysical information about the means"},"content":"In this scenario, we do not know the true petrophysical signature of each rock\nunit. We thus make geologic assumptions to design a coupling term and perform\na multi-physics inversion. in addition to a neutral background, we assume that\none rock unit is only less dense, and the third one is only magnetic. As we\ndo not know their mean petrophysical values. We start with an initial guess\n(-1 g/cc) for the updatable mean density-contrast value of the less dense unit\n(with a fixed susceptibility of 0 SI). The magnetic-contrasting unit’s updatable\nsusceptibility is initialized at a value of 0.1 SI (with a fixed 0 g/cc density\ncontrast). We then let the algorithm learn a suitable set of means under the set\nconstrained (fixed or updatable value), through the kappa argument, denoting our\nconfidences in each initial mean value (high confidence: fixed value; low\nconfidence: updatable value).\n\n","type":"content","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#inversion-with-no-petrophysical-information-about-the-means","position":7},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Create a petrophysical GMM initial guess"},"type":"lvl2","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#create-a-petrophysical-gmm-initial-guess","position":8},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Create a petrophysical GMM initial guess"},"content":"The GMM is our representation of the petrophysical and geological information.\nHere, we focus on the petrophysical aspect, with the means and covariances of\nthe physical properties of each rock unit.\nTo generate the data above, the PK unit was populated with a density contrast\nof -0.8 g/cc and a magnetic susceptibility of 0.005 SI. The properties of the\nHK unit were set at -0.2 g/cc and 0.02 SI. But here, we assume we\ndo not have this information. Thus, we start with initial guess for the means\nand confidences kappa such that one unit is only less dense and one unit is only\nmagnetic, both embedded in a neutral background. The covariances matrices are set\nso that we assume petrophysical noise levels of around 0.05 g/cc and 0.001 SI\nfor both unit. The background unit is set at a fixed null contrasts (0 g/cc\n0 SI) with a petrophysical noise level of half of the above.\n\ngmmref = utils.WeightedGaussianMixture(\n    n_components=3,  # number of rock units: bckgrd, PK, HK\n    mesh=mesh,  # inversion mesh\n    actv=actv,  # actv cells\n    covariance_type=\"diag\",  # diagonal covariances\n)\n# required: initialization with fit\n# fake random samples, size of the mesh\n# number of physical properties: 2 (density and mag.susc)\nrng = np.random.default_rng(seed=518936)\ngmmref.fit(rng.normal(size=(nactv, 2)))\n# set parameters manually\n# set phys. prop means for each unit\ngmmref.means_ = np.c_[\n    [0.0, 0.0],  # BCKGRD density contrast and mag. susc\n    [-1, 0.0],  # PK\n    [0, 0.1],  # HK\n].T\n# set phys. prop covariances for each unit\ngmmref.covariances_ = np.array(\n    [[6e-04, 3.175e-07], [2.4e-03, 1.5e-06], [2.4e-03, 1.5e-06]]\n)\n# important after setting cov. manually: compute precision matrices and cholesky\ngmmref.compute_clusters_precisions()\n# set global proportions; low-impact as long as not 0 or 1 (total=1)\ngmmref.weights_ = np.r_[0.9, 0.075, 0.025]\n\n# Plot the 2D GMM\nax = gmmref.plot_pdf(flag2d=True, plotting_precision=250)\nax[0].set_xlabel(\"Density contrast [g/cc]\")\nax[0].set_ylim([0, 5])\nax[2].set_ylabel(\"magnetic Susceptibility [SI]\")\nax[2].set_xlim([0, 100])\nplt.show()\n\n","type":"content","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#create-a-petrophysical-gmm-initial-guess","position":9},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Inverse problem with no mean information"},"type":"lvl2","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#inverse-problem-with-no-mean-information","position":10},{"hierarchy":{"lvl1":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","lvl2":"Inverse problem with no mean information"},"content":"\n\n# Create PGI regularization\n# Sensitivity weighting\nwr_grav = np.sum(simulation_grav.G**2.0, axis=0) ** 0.5 / (mesh.cell_volumes[actv])\nwr_grav = wr_grav / np.max(wr_grav)\n\nwr_mag = np.sum(simulation_mag.G**2.0, axis=0) ** 0.5 / (mesh.cell_volumes[actv])\nwr_mag = wr_mag / np.max(wr_mag)\n\n# create joint PGI regularization with smoothness\nreg = regularization.PGI(\n    gmmref=gmmref,\n    mesh=mesh,\n    wiresmap=wires,\n    maplist=[idenMap, idenMap],\n    active_cells=actv,\n    alpha_pgi=1.0,\n    alpha_x=1.0,\n    alpha_y=1.0,\n    alpha_z=1.0,\n    alpha_xx=0.0,\n    alpha_yy=0.0,\n    alpha_zz=0.0,\n    # use the classification of the initial model (here, all background unit)\n    # as initial reference model\n    reference_model=utils.mkvc(\n        gmmref.means_[gmmref.predict(m0.reshape(actvMap.nP, -1))]\n    ),\n    weights_list=[wr_grav, wr_mag],  # weights each phys. prop. by correct sensW\n)\n\n# Directives\n# Add directives to the inversion\n# ratio to use for each phys prop. smoothness in each direction:\n# roughly the ratio of range of each phys. prop.\nalpha0_ratio = np.r_[\n    1e-2 * np.ones(len(reg.objfcts[1].objfcts[1:])),\n    1e-2 * 100.0 * np.ones(len(reg.objfcts[2].objfcts[1:])),\n]\nAlphas = directives.AlphasSmoothEstimate_ByEig(alpha0_ratio=alpha0_ratio, verbose=True)\n# initialize beta and beta/alpha_s schedule\nbeta = directives.BetaEstimate_ByEig(beta0_ratio=1e-4)\nbetaIt = directives.PGI_BetaAlphaSchedule(\n    verbose=True,\n    coolingFactor=2.0,\n    tolerance=0.2,\n    progress=0.2,\n)\n# geophy. and petro. target misfits\ntargets = directives.MultiTargetMisfits(\n    verbose=True,\n    chiSmall=0.5,  # ask for twice as much clustering (target value is /2)\n)\n# add learned mref in smooth once stable\nMrefInSmooth = directives.PGI_AddMrefInSmooth(\n    wait_till_stable=True,\n    verbose=True,\n)\n# update the parameters in smallness (L2-approx of PGI)\nupdate_smallness = directives.PGI_UpdateParameters(\n    update_gmm=True,  # update the GMM each iteration\n    kappa=np.c_[  # confidences in each mean phys. prop. of each cluster\n        1e10\n        * np.ones(\n            2\n        ),  # fixed background at 0 density, 0 mag. susc. (high confidences of 1e10)\n        [\n            0,\n            1e10,\n        ],  # density-contrasting cluster: updatable density mean, fixed mag. susc.\n        [\n            1e10,\n            0,\n        ],  # magnetic-contrasting cluster: fixed density mean, updatable mag. susc.\n    ].T,\n)\n# pre-conditioner\nupdate_Jacobi = directives.UpdatePreconditioner()\n# iteratively balance the scaling of the data misfits\nscaling_init = directives.ScalingMultipleDataMisfits_ByEig(chi0_ratio=[1.0, 100.0])\nscale_schedule = directives.JointScalingSchedule(verbose=True)\n\n# Create inverse problem\n# Optimization\n# set lower and upper bounds\nlowerbound = np.r_[-2.0 * np.ones(actvMap.nP), 0.0 * np.ones(actvMap.nP)]\nupperbound = np.r_[0.0 * np.ones(actvMap.nP), 1e-1 * np.ones(actvMap.nP)]\nopt = optimization.ProjectedGNCG(\n    maxIter=30,\n    lower=lowerbound,\n    upper=upperbound,\n    maxIterLS=20,\n    maxIterCG=100,\n    tolCG=1e-4,\n)\n# create inverse problem\ninvProb = inverse_problem.BaseInvProblem(dmis, reg, opt)\ninv = inversion.BaseInversion(\n    invProb,\n    # directives: evaluate alphas (and data misfits scales) before beta\n    directiveList=[\n        Alphas,\n        scaling_init,\n        beta,\n        update_smallness,\n        targets,\n        scale_schedule,\n        betaIt,\n        MrefInSmooth,\n        update_Jacobi,\n    ],\n)\n# Invert\npgi_model_no_info = inv.run(m0)\n\n\n# Plot the result with full petrophysical information\ndensity_model_no_info = gravmap * pgi_model_no_info\nmagsus_model_no_info = magmap * pgi_model_no_info\nlearned_gmm = reg.objfcts[0].gmm\nquasi_geology_model_no_info = actvMap * reg.objfcts[0].compute_quasi_geology_model()\n\nfig, ax = plt.subplots(3, 4, figsize=(15, 10))\nfor _, axx in enumerate(ax):\n    for _, axxx in enumerate(axx):\n        axxx.set_aspect(1)\n        axxx.tick_params(labelsize=ticksize)\n\nindx = 15\nindy = 17\nindz = -9\n# geology model\nmesh.plot_slice(\n    quasi_geology_model_no_info,\n    normal=\"X\",\n    ax=ax[0, 0],\n    clim=[0, 2],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\nmesh.plot_slice(\n    quasi_geology_model_no_info,\n    normal=\"Y\",\n    ax=ax[0, 1],\n    clim=[0, 2],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\ngeoplot = mesh.plot_slice(\n    quasi_geology_model_no_info,\n    normal=\"Z\",\n    ax=ax[0, 2],\n    clim=[0, 2],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\ngeocb = plt.colorbar(geoplot[0], cax=ax[0, 3], ticks=[0, 1, 2])\ngeocb.set_ticklabels([\"BCK\", \"PK\", \"VK\"])\ngeocb.set_label(\"Quasi-Geology model\\n(Rock units classification)\", fontsize=16)\nax[0, 3].set_aspect(10)\n\n# gravity model\nmesh.plot_slice(\n    density_model_no_info,\n    normal=\"X\",\n    ax=ax[1, 0],\n    clim=[-1, 0],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\nmesh.plot_slice(\n    density_model_no_info,\n    normal=\"Y\",\n    ax=ax[1, 1],\n    clim=[-1, 0],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\ndenplot = mesh.plot_slice(\n    density_model_no_info,\n    normal=\"Z\",\n    ax=ax[1, 2],\n    clim=[-1, 0],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\ndencb = plt.colorbar(denplot[0], cax=ax[1, 3])\ndencb.set_label(\"Density contrast\\nmodel (g/cc)\", fontsize=16)\nax[1, 3].set_aspect(10)\n\n# magnetic model\nmesh.plot_slice(\n    magsus_model_no_info,\n    normal=\"X\",\n    ax=ax[2, 0],\n    clim=[0, 0.025],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nmesh.plot_slice(\n    magsus_model_no_info,\n    normal=\"Y\",\n    ax=ax[2, 1],\n    clim=[0, 0.025],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nsusplot = mesh.plot_slice(\n    magsus_model_no_info,\n    normal=\"Z\",\n    ax=ax[2, 2],\n    clim=[0, 0.025],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nsuscb = plt.colorbar(susplot[0], cax=ax[2, 3])\nsuscb.set_label(\"Magnetic susceptibility\\nmodel (SI)\", fontsize=16)\nax[2, 3].set_aspect(10)\n\n# overlay true geology model for comparison\nindslicexplot = mesh.gridCC[:, 0] == mesh.cell_centers_x[indx]\nindsliceyplot = mesh.gridCC[:, 1] == mesh.cell_centers_y[indy]\nindslicezplot = mesh.gridCC[:, 2] == mesh.cell_centers_z[indz]\nfor i in range(3):\n    for j, (plane, indd) in enumerate(\n        zip([[1, 2], [0, 2], [0, 1]], [indslicexplot, indsliceyplot, indslicezplot])\n    ):\n        utils.plot2Ddata(\n            mesh.gridCC[indd][:, plane],\n            true_geology[indd],\n            nx=100,\n            ny=100,\n            contourOpts={\"alpha\": 0},\n            clim=[0, 2],\n            ax=ax[i, j],\n            level=True,\n            ncontour=2,\n            levelOpts={\"colors\": \"grey\", \"linewidths\": 2, \"linestyles\": \"--\"},\n            method=\"nearest\",\n        )\n\n# plot the locations of the cross-sections\nfor i in range(3):\n    ax[i, 0].plot(\n        mesh.cell_centers_y[indy] * np.ones(2), [-300, 500], c=\"k\", linestyle=\"dotted\"\n    )\n    ax[i, 0].plot(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n        mesh.cell_centers_z[indz] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 0].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n    )\n\n    ax[i, 1].plot(\n        mesh.cell_centers_x[indx] * np.ones(2), [-300, 500], c=\"k\", linestyle=\"dotted\"\n    )\n    ax[i, 1].plot(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n        mesh.cell_centers_z[indz] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 1].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n    )\n\n    ax[i, 2].plot(\n        mesh.cell_centers_x[indx] * np.ones(2),\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 2].plot(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n        mesh.cell_centers_y[indy] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 2].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n    )\n    ax[i, 2].set_ylim(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n    )\n\nplt.tight_layout()\nplt.show()\n\n# Plot the learned 2D GMM\nfig = plt.figure(figsize=(10, 10))\nax0 = plt.subplot2grid((4, 4), (3, 1), colspan=3)\nax1 = plt.subplot2grid((4, 4), (0, 1), colspan=3, rowspan=3)\nax2 = plt.subplot2grid((4, 4), (0, 0), rowspan=3)\nax = [ax0, ax1, ax2]\nlearned_gmm.plot_pdf(flag2d=True, ax=ax, padding=1, plotting_precision=100)\nax[0].set_xlabel(\"Density contrast [g/cc]\")\nax[0].set_ylim([0, 5])\nax[2].set_xlim([0, 50])\nax[2].set_ylabel(\"magnetic Susceptibility [SI]\")\nax[1].scatter(\n    density_model_no_info[actv],\n    magsus_model_no_info[actv],\n    c=quasi_geology_model_no_info[actv],\n    cmap=\"inferno_r\",\n    edgecolors=\"k\",\n    label=\"recovered PGI model\",\n    alpha=0.5,\n)\nax[0].hist(density_model_no_info[actv], density=True, bins=50)\nax[2].hist(magsus_model_no_info[actv], density=True, bins=50, orientation=\"horizontal\")\nax[1].scatter(\n    [0, -0.8, -0.02],\n    [0, 0.005, 0.02],\n    label=\"True petrophysical means\",\n    cmap=\"inferno_r\",\n    c=[0, 1, 2],\n    marker=\"v\",\n    edgecolors=\"k\",\n    s=200,\n)\nax[1].legend()\nplt.show()","type":"content","url":"/plot-inv-2-joint-pf-pgi-no-info-tutorial#inverse-problem-with-no-mean-information","position":11},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally"},"type":"lvl1","url":"/build-website","position":0},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally"},"content":"Here, we provide instructions for setting up an appropriate Python environment and building the SimPEG user tutorials website locally with \n\nMyST.","type":"content","url":"/build-website","position":1},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl2":"Step 1: Cloning the GitHub Repository"},"type":"lvl2","url":"/build-website#step-1-cloning-the-github-repository","position":2},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl2":"Step 1: Cloning the GitHub Repository"},"content":"The URL for the SimPEG user tutorials GitHub repository is: \n\nhttps://​github​.com​/simpeg​/user​-tutorials/. If using the Git Bash shell:git clone https://github.com/simpeg/user-tutorials\ncd user-tutorials","type":"content","url":"/build-website#step-1-cloning-the-github-repository","position":3},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl2":"Step 2: Setting Up a Python Environment"},"type":"lvl2","url":"/build-website#step-2-setting-up-a-python-environment","position":4},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl2":"Step 2: Setting Up a Python Environment"},"content":"The Jupyter notebooks containing the tutorials are maintained to run properly using the \n\nlatest release of SimPEG.\nNotebooks may not run correctly if SimPEG is being imported from an earlier release or development branch.\nThe \n\nmystmd and \n\nnodejs are also required to build the website locally.\n\nWe advise building a Python environment from the environment.yml file in the root directory of the repository.\nTo create the simpeg-user-tutorials environment using conda:conda env create -f environment.yml\n\nOnce built, you can activate using:conda activate simpeg-user-tutorials","type":"content","url":"/build-website#step-2-setting-up-a-python-environment","position":5},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl2":"Step 3: Build and Execution Commands"},"type":"lvl2","url":"/build-website#step-3-build-and-execution-commands","position":6},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl2":"Step 3: Build and Execution Commands"},"content":"The SimPEG user tutorials are a collection of \n\nJupyter Notebook (and \n\nMarkdown) files,\nwhich \n\nMyST builds into a website. Here, we describe the commands that contributors should be familiar with.\n\nImportant\n\nThe tutorial notebooks, including their states, are tracked by GitHub. When the SimPEG user tutorials repository was cloned, all notebooks had been run and saved. Therefore, you do not need to rerun all of the notebooks prior to building the website!","type":"content","url":"/build-website#step-3-build-and-execution-commands","position":7},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Locally Build and Serve Website","lvl2":"Step 3: Build and Execution Commands"},"type":"lvl3","url":"/build-website#locally-build-and-serve-website","position":8},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Locally Build and Serve Website","lvl2":"Step 3: Build and Execution Commands"},"content":"The following command will build the website and serve it locally.\nThis will allow you to preview the website and observe any changes to notebooks on the fly.\nTo locally build and serve the website:\nthe website:myst start\n\nNext, follow the instructions prompted by the command to launch the local build in your brower.","type":"content","url":"/build-website#locally-build-and-serve-website","position":9},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Build Only","lvl2":"Step 3: Build and Execution Commands"},"type":"lvl3","url":"/build-website#build-only","position":10},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Build Only","lvl2":"Step 3: Build and Execution Commands"},"content":"The following command will build the website and store the HTML files in\na new _build folder:myst build --html","type":"content","url":"/build-website#build-only","position":11},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Clean Cached Builds","lvl2":"Step 3: Build and Execution Commands"},"type":"lvl3","url":"/build-website#clean-cached-builds","position":12},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Clean Cached Builds","lvl2":"Step 3: Build and Execution Commands"},"content":"myst clean --all","type":"content","url":"/build-website#clean-cached-builds","position":13},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Rerunning Notebooks","lvl2":"Step 3: Build and Execution Commands"},"type":"lvl3","url":"/build-website#rerunning-notebooks","position":14},{"hierarchy":{"lvl1":"Building the User Tutorials Website Locally","lvl3":"Rerunning Notebooks","lvl2":"Step 3: Build and Execution Commands"},"content":"When making alterations and rerunning notebooks, we typically do so by launching Jupyter Notebooks:jupyter notebook\n\nHowever, we can rerun a notebook and overwrite its output cells in place using nbconvert.\nTo rerun a single notebook, use:jupyter nbconvert --to notebook --execute --inplace notebook.ipynb\n\nWe may also want to rerun all notebooks in the repository.\nTo rerun all notebooks, use:jupyter nbconvert --to notebook --execute --inplace notebooks/**/*.ipynb\n\nDanger\n\nRerunning all notebooks is a computationally intensive task. Some notebooks\nrequire significant amount of memory to allocate large sensitivity matrices.\n\nImportant\n\nIf you are using bash as your shell, make sure to run shopt -s globstar to enable the globstar feature that allows the use of ** for\nfilename expansion.","type":"content","url":"/build-website#rerunning-notebooks","position":15},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements"},"type":"lvl1","url":"/formatting","position":0},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements"},"content":"To ensure quality and consistency, the \n\nJupyter Notebooks follow a structured template. The contents of each notebooks are to be parsed sensibly into a set of sections. Sufficient explanation and links to API documentation are requested when presenting functionality. Each section within a tutorial contains a combination of \n\nMarkdown and coding cells. Our notebooks use the functionality in \n\nMyST Parser to augment the contents of Markdown cells. Before moving forward, we advise the contributor to:\n\nBe familiar with the structure and formatting that is used by most forward simulation and inversion tutorials. E.g. \n\n3D Forward Simulation of Gravity Anomaly Data and \n\n3D Inversion of Gravity Anomaly Data.\n\nRefer to the Markdown syntax used by \n\nMyST Parser.\n\nRefer to the \n\nstyle guide for coding cells.","type":"content","url":"/formatting","position":1},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Notebook Introduction"},"type":"lvl2","url":"/formatting#notebook-introduction","position":2},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Notebook Introduction"},"content":"Every tutorial notebook requires an introduction section. The Markdown cells required for the introduction are described below.","type":"content","url":"/formatting#notebook-introduction","position":3},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 1: Title Cell","lvl2":"Notebook Introduction"},"type":"lvl3","url":"/formatting#cell-1-title-cell","position":4},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 1: Title Cell","lvl2":"Notebook Introduction"},"content":"The first cell contains the title and the author for the tutorial. It is formatted as follows.\nThe title is in quotations. You will need to add yourself as an author in the myst.yml file in the root directory of the repository.---\ntitle: \"My Notebook Title In Quotes\"\nauthors:\n  - id: devincowan\n---","type":"content","url":"/formatting#cell-1-title-cell","position":5},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 2: Tutorial Difficulty","lvl2":"Notebook Introduction"},"type":"lvl3","url":"/formatting#cell-2-tutorial-difficulty","position":6},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 2: Tutorial Difficulty","lvl2":"Notebook Introduction"},"content":"Here, we indicate whether the notebook contains introductory, intermediate or advanced content. The author should choose\nfrom one of the following \n\nMyST admonitions, which is rendered when the webpage is built.:::{admonition} Introductory notebook\n:class: hint\nThis tutorial teaches basic functionality within SimPEG and is a good\nentry point for new users.\n::::::{admonition} Intermediate notebook\n:class: caution\nThis tutorial focusses on intermediate level functionality within SimPEG.\nBasic functionality within SimPEG is not discussed in detail, as we assume\nthe user is already familiar.\n::::::{admonition} Advanced notebook\n:class: danger\nThis tutorial focusses on advanced functionality within SimPEG. Basic and\nintermediate level functionality are not discussed in detail, as we assume\nthe user is already an experienced SimPEG user.\n:::","type":"content","url":"/formatting#cell-2-tutorial-difficulty","position":7},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 3: Computational Requirements","lvl2":"Notebook Introduction"},"type":"lvl3","url":"/formatting#cell-3-computational-requirements","position":8},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 3: Computational Requirements","lvl2":"Notebook Introduction"},"content":"Here, we specify the computational requirements to run the notebook. Whereas some notebooks can be run easily on laptop computers, some notebook may need to be exported as Python files and run using cluster computing. The author should choose from one of the following \n\nMyST admonitions, which is rendered when the webpage is built.:::{admonition} Light-weight notebook\n:class: hint\nThis tutorial requires minimal computational resources and can be executed\nquickly in the background while other computer processes are running.\n::::::{admonition} Medium-weight notebook\n:class: caution\nRequires moderate computational resources. Run-times may exceed several\nminutes and require up to 8 GB of available RAM.\n::::::{admonition} Computationally intensive notebook\n:class: danger\nThe computational resources required to execute this notebook exceed those\nprovided by standard laptop computers. To execute the notebook, please deploy\nto a cluster computing environment.\n:::","type":"content","url":"/formatting#cell-3-computational-requirements","position":9},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 4: Keywords, Summary and Learning Objectives","lvl2":"Notebook Introduction"},"type":"lvl3","url":"/formatting#cell-4-keywords-summary-and-learning-objectives","position":10},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 4: Keywords, Summary and Learning Objectives","lvl2":"Notebook Introduction"},"content":"In this cell, the contributor must provide a set of relevant keywords. E.g.**Keywords:** gravity inversion, sparse-norm inversion, integral formulation, tree mesh.\n\nNext, the contributor should provide a summary of the tutorial. The summary should be roughly one paragraph. If your tutorial focusses on particular functionality within SimPEG, please link to the API documentation. Also, link to tutorials you feel the reader should have already worked through. E.g.**Summary:** Here we invert gravity anomaly data to recover a density contrast model.\nWe demonstrate two approaches for recovering a density contrast model:\n\n1. Weighted least-squares inversion for a tensor mesh\n2. Iteratively re-weighted least-squares (IRLS) inversion for a tree mesh\n\nThe *weighted least-squares* approach is a great introduction to geophysical inversion\nwith SimPEG. One drawback however, is that it recovers smooth structures which may not\nbe representative of the true model. To recover sparse and/or blocky structures, we\nalso demonstrate the *iteratively re-weighted least-squares* approach. Because this\ntutorial focusses primarily on inversion-related functionality, we urge the reader to\nbecome familiar with functionality explained in the [3D Forward Simulation of Gravity\nAnomaly Data](fwd_gravity_anomaly_3d.ipynb) tutorial before working through this one.\n\nFinally, we request that the contributor provide learning objectives using a bullet list. E.g.**Learning Objectives:**\n\n- How geophysical inversion is carried out using SimPEG.\n- How to assign appropriate uncertainties to gravity anomaly data.\n- How to design a suitable mesh for gravity inversion when using the integral formulation.\n- How to choose and set parameters for the inversion.\n- How to define directives that are applied and updated throughout the inversion.\n- How to applying the sensitivity weighting generally used in 3D gravity inversion.\n- How to invert data using weighted least-squares and sparse-norm regularization.\n- How to analyse inversion results.","type":"content","url":"/formatting#cell-4-keywords-summary-and-learning-objectives","position":11},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Import Functionality"},"type":"lvl2","url":"/formatting#import-functionality","position":12},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Import Functionality"},"content":"Following the introduction section, the contributor must import all functionality used by the tutorial and briefly explain the functionality that is most important.","type":"content","url":"/formatting#import-functionality","position":13},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 1: Header and Summary","lvl2":"Import Functionality"},"type":"lvl3","url":"/formatting#cell-1-header-and-summary","position":14},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 1: Header and Summary","lvl2":"Import Functionality"},"content":"This Markdown cell uses the heading Import Modules. For functionality that relates\ndirectly to the purpose of the tutorial, some context and a link to API documentation\nshould be provided. E.g.## Import Modules\n\nHere, we import all of the functionality required to run the notebook for the tutorial\nexercise. All of the functionality specific to simulating gravity data are imported from\n[simpeg.potential_fields.gravity](xref:simpeg#simpeg.potential_fields.gravity). We also\nimport some useful utility functions from [simpeg.utils](xref:simpeg#simpeg.utils).\nTo simulate gravity data, we need to define our problem geometry on a numerical grid\n(or mesh). To generate the mesh, we used the\n[discretize](https://discretize.simpeg.xyz/en/main) package.","type":"content","url":"/formatting#cell-1-header-and-summary","position":15},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 2: Code Cell","lvl2":"Import Functionality"},"type":"lvl3","url":"/formatting#cell-2-code-cell","position":16},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Cell 2: Code Cell","lvl2":"Import Functionality"},"content":"The coding cell where functionality is imported should be organized. E.g.# SimPEG functionality\nfrom simpeg.potential_fields import gravity\nfrom simpeg.utils import plot2Ddata, model_builder\nfrom simpeg import maps\n\n# discretize functionality\nfrom discretize import TensorMesh\nfrom discretize.utils import mkvc, active_from_xyz\n\n# Common Python functionality\nimport numpy as np\nfrom scipy.interpolate import LinearNDInterpolator\nimport matplotlib as mpl\n\nmpl.rcParams.update({\"font.size\": 14})\nimport matplotlib.pyplot as plt\nimport os","type":"content","url":"/formatting#cell-2-code-cell","position":17},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Tutorial Sections (and Subsections)"},"type":"lvl2","url":"/formatting#tutorial-sections-and-subsections","position":18},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Tutorial Sections (and Subsections)"},"content":"Each section (or subsection) is constructed using a combination of Markdown and code cells. The structure and formatting of these are discussed below.","type":"content","url":"/formatting#tutorial-sections-and-subsections","position":19},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Header and Summary","lvl2":"Tutorial Sections (and Subsections)"},"type":"lvl3","url":"/formatting#header-and-summary","position":20},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Header and Summary","lvl2":"Tutorial Sections (and Subsections)"},"content":"Each section (or subsection) begins with a Markdown cell containing the header and a summary.\nHere, the contributor must:\n\nsummarize what is being done in the section\n\ndescribe any new functionality that is being introduced\n\nprovide links to all relevant API documentation\n\ndescribe the choices for hyperparameter values used in the tutorial\n\nE.g.## Define the Survey\n\nSurveys within SimPEG generally require the user to create and connect three\ntypes of objects:\n\n- [receivers](xref:simpeg#simpeg.potential_fields.gravity.receivers.Point):\nwhich define the locations of field measurements and type of data being measured.\n- [sources](xref:simpeg#simpeg.potential_fields.gravity.sources.SourceField):\nthe passive or active sources responsible for generating geophysical responses,\nand their associated receivers.\n- [survey](xref:simpeg#simpeg.potential_fields.gravity.survey.Survey): the object\nwhich stores and organizes all of the sources and receivers.\n\nHere, we define the survey that will be used for the forward simulation. Gravity\nsurveys are simple to create. The user only needs an (N, 3)\n[numpy.ndarray](xref:numpy#numpy.ndarray) to define the xyz locations of the\nobservation locations, and a list of field components\nwhich are to be measured. For the tutorial simulation, the receivers are located\n5 m above the surface topography and spaced 10 m apart.\n\nIf something has been thoroughly explained in an introductory tutorial, you can avoid repetition by linking to that tutorial.\nHowever, the choice in values used in your tutorial should always be stated. E.g.## Assign Uncertainties\n\nApproaches for applying reasonable uncertainties to normalized voltage and apparent\nresistivity data were presented in the [2.5D Inversion](inv_dcr_2d.ipynb) tutorial.\nHere, we apply uncertainties of 1e-7 V/A + 10 % to the normalized voltage data being\ninverted.","type":"content","url":"/formatting#header-and-summary","position":21},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Code Block Cells","lvl2":"Tutorial Sections (and Subsections)"},"type":"lvl3","url":"/formatting#code-block-cells","position":22},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Code Block Cells","lvl2":"Tutorial Sections (and Subsections)"},"content":"Code blocks must follow the \n\nstyle required by SimPEG.\nPlease provide comments when defining new objects. This is especially important when exposing the reader to new functionality.\nAvoid lengthy code blocks that can be better parsed into multiple cells. Markdown cells can also be added between code cells\nto provide additional explanation to the reader.# Define the component(s) of the field we want to simulate as strings within\n# a list. Here we simulate only the vertical component of the gravity anomaly.\ncomponents = [\"gz\"]\n\n# Use the observation locations and components to define receivers for the entire survey\n# in one step. The set of receivers, even if it's only 1, are organized within a list.\nreceiver_list = gravity.receivers.Point(receiver_locations, components=components)\nreceiver_list = [receiver_list]\n\n# Defining the source. For gravity surveys, we simply need to specific the list of\n# receivers associated with the source field.\nsource_field = gravity.sources.SourceField(receiver_list=receiver_list)\n\n# Defining the survey.\nsurvey = gravity.survey.Survey(source_field)","type":"content","url":"/formatting#code-block-cells","position":23},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Plotting Requirements","lvl2":"Tutorial Sections (and Subsections)"},"type":"lvl3","url":"/formatting#plotting-requirements","position":24},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl3":"Plotting Requirements","lvl2":"Tutorial Sections (and Subsections)"},"content":"The contributor is required to plot data, models and other quantities that are best understood visually.\nDue to its widespread use, figures should be generated using \n\nmatplotlib package.\nWhen generating a figure, please ensure:\n\nthe figure renders at an appropriate size when building the website\n\nthe code used to generate the figure is compact whenever possible\n\nthe text and features within the plot are legible","type":"content","url":"/formatting#plotting-requirements","position":25},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Check Style of Notebooks"},"type":"lvl2","url":"/formatting#check-style-of-notebooks","position":26},{"hierarchy":{"lvl1":"Tutorial Structure and Formatting Requirements","lvl2":"Check Style of Notebooks"},"content":"We can check the code style of our notebooks using \n\nruff.\nSimply run the following command to check the style of the notebooks:ruff check notebooks\n\nYou can run the following that the notebooks are correctly formatted:ruff format --check notebooks\n\nAnd run this to autoformat them:ruff format --fix notebooks\n\nAlternatively, you can use the targets we have in the Makefile, like make check and make format. Read more information about the available targets\nby running make help.","type":"content","url":"/formatting#check-style-of-notebooks","position":27},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests"},"type":"lvl1","url":"/pull-request","position":0},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests"},"content":"Here, we describe the pull request and review process for bring new tutorial notebooks into the SimPEG user tutorials repository.","type":"content","url":"/pull-request","position":1},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests","lvl2":"Requirements Checklist"},"type":"lvl2","url":"/pull-request#requirements-checklist","position":2},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests","lvl2":"Requirements Checklist"},"content":"The following is a useful checklist for determining whether the tutorial notebook has satisfied formatting and structure requirements:\n\nGeneral:\n\nNotebook is compatible with latest SimPEG release\n\nNo deprecated functions and/or input arguments are being used\n\nCoding cells linted according to the \n\nstyle guides.\n\nThe introduction is complete:\n\nTitle and author added to notebook\n\nAdmonitions for notebook difficulty and computational resources have been added\n\nKeywords list has been added\n\nSummary paragraph describing the tutorial has been added\n\nLearning objectives have been listed\n\nHyperlinks to other tutorial notebooks added if necessary\n\nFor sections and subsections:\n\nA header and short summary of what is being done\n\nLinks to API documentation added for all classes and functions that are used\n\nNewly introduced functionality is explained, or links are provided to relevant materials\n\nThe approach taken when choosing hyperparameter values is explained. The use of ad hoc values without explanation is discouraged\n\nAll figures are legible and rendered appropriately","type":"content","url":"/pull-request#requirements-checklist","position":3},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests","lvl2":"Stages of a Pull Request"},"type":"lvl2","url":"/pull-request#stages-of-a-pull-request","position":4},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests","lvl2":"Stages of a Pull Request"},"content":"When you are ready to submit your tutorial notebook review, you will make a\nGitHub pull request (PR). If your pull request is not ready for a final review,\nbut you would like feedback, please mark it as a draft pull request. Once you\nfeel the pull request is ready for a final review, you can convert the draft PR to\nan open PR by selecting the Ready for review button at the bottom of the page.\n\nOnce a pull request is in open status and you are ready for review, please\nping dccowan and santisoler in a github comment to\nrequest a review. At minimum for a PR to be eligible to merge, we look for\n\nStructure and formatting requirements are observed.\n\nThe notebooks runs properly using the latest release of SimPEG.\n\nAll reviewer comments (if any) have been addressed.\n\nA developer approves the PR.\n\nAfter all these steps are satisfied, a @simpeg/simpeg-admin will merge your\npull request into the main branch (feel free to ping one of us on Github).\n\nThis being said, all SimPEG developers and admins are essentially volunteers\nproviding their time for the benefit of the community. This does mean that\nit might take some time for us to get your PR.","type":"content","url":"/pull-request#stages-of-a-pull-request","position":5},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests","lvl2":"Merging a Pull Request"},"type":"lvl2","url":"/pull-request#merging-a-pull-request","position":6},{"hierarchy":{"lvl1":"Review Process and GitHub Pull Requests","lvl2":"Merging a Pull Request"},"content":"The @simpeg/simpeg-admin will merge a Pull Request to the main branch\nusing the Squash and Merge <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-commits>_\nstrategy: all commits made to the PR branch will be squashed to a single\ncommit that will be added to main.\n\nSimPEG admins will ensure that the commit message is descriptive and\ncomprehensive. Contributors can help by providing a descriptive and\ncomprehensive PR description of the changes that were applied and the reasons\nbehind them. This will be greatly appreciated.","type":"content","url":"/pull-request#merging-a-pull-request","position":7},{"hierarchy":{"lvl1":"Contributing to User Tutorials"},"type":"lvl1","url":"/contributing-index","position":0},{"hierarchy":{"lvl1":"Contributing to User Tutorials"},"content":"We greatly appreciate efforts made by the SimPEG community to improve available tutorial material.\nThis includes:\n\nimproving the content within preexisting tutorials, and\n\nadding a new tutorials\n\nHowever, tutorials must adhere to specific guidelines in order to ensure a high level of quality and consistency.\nSome of the things we would like to avoid are:\n\ntutorials created for the purpose of self promotion\n\ntutorials that focuss primarily on functionality that is not part of SimPEG\n\ntutorials with limited applicability; i.e. the focus of the tutorial is too specific\n\nIf you aren’t sure if your tutorial will be a good fit, please \n\nstart an issue so we can discuss it. For those interested in contributing to SimPEG User Tutorials, please follow the instructions provided.","type":"content","url":"/contributing-index","position":1},{"hierarchy":{"lvl1":"Contributing to User Tutorials","lvl2":"Steps for Adding a Tutorial"},"type":"lvl2","url":"/contributing-index#steps-for-adding-a-tutorial","position":2},{"hierarchy":{"lvl1":"Contributing to User Tutorials","lvl2":"Steps for Adding a Tutorial"},"content":"As explained on the \n\nSimPEG user tutorials landing page, the SimPEG user tutorials are a library of [Jupyter Notebooks][\n\njupyter.org] that have been published as a website using [MyST][\n\nmystmd.org]. To add a tutorial notebook to the project, you will need to complete the following steps:\n\nStep 1: Building the User Tutorials Website Locally\n\nFirst, you will need all of the functionality required to run the existing tutorial notebooks and build the website locally with [MyST][\n\nmystmd.org].\nInstructions for creating an appropriate Python environment and building the website locally are found on the \n\nBuilding the User Tutorials Website Locally page.\n\nStep 2: Creating a Tutorial Notebook\n\nJupyter notebooks that contain tutorials must adhere to specific structure and formatting requirements.\nThese are provided on the \n\nTutorial Structure and Formatting Requirements page.\n\nStep 3: Review Process and GitHub Pull Requests\n\nAny proposed changes to SimPEG user tutorials must be submitted for a review as a GitHub pull request.\nPlease visit our \n\nReview Process and GitHub Pull Requests page.","type":"content","url":"/contributing-index#steps-for-adding-a-tutorial","position":3},{"hierarchy":{"lvl1":"Direct Current Resistivity"},"type":"lvl1","url":"/dcr-index","position":0},{"hierarchy":{"lvl1":"Direct Current Resistivity"},"content":"Direct current resistivity data are simulated using functionality within the SimPEG.electromagnetics.static.resistivity module. Here, we provide a multitude of introductory and indermediate level tutorials for forward simulation and inversion of direct current resistivity data. Links to each tutorial can be accessed below or from the left-side menu.\n\n\n\nSchematic illustrating the physics of the DC/IP method (\n\nimage source)","type":"content","url":"/dcr-index","position":1},{"hierarchy":{"lvl1":"Direct Current Resistivity","lvl2":"Tutorial Notebooks"},"type":"lvl2","url":"/dcr-index#tutorial-notebooks","position":2},{"hierarchy":{"lvl1":"Direct Current Resistivity","lvl2":"Tutorial Notebooks"},"content":"1D Forward Simulation for a Single Sounding ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n2.5D Forward Simulation ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n3D Forward Simulation ({\\color{orange}Intermediate}, {\\color{orange}Moderate})\n\n\n1D Inversion for a Single Sounding ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n\n\n2.5D DC Resistivity Inversion ({\\color{orange}Intermediate}, {\\color{orange}Moderate})\n\n\n3D DC Resistivity Inversion ({\\color{orange}Intermediate}, {\\color{orange}Moderate})\n","type":"content","url":"/dcr-index#tutorial-notebooks","position":3},{"hierarchy":{"lvl1":"Frequency-Domain Electromagnetics"},"type":"lvl1","url":"/fdem-index","position":0},{"hierarchy":{"lvl1":"Frequency-Domain Electromagnetics"},"content":"In this chapter, we publish code comparisons and validations for frequency-domain electromagnetic modeling packages.\nIn SimPEG, the SimPEG.electromagnetics.frequency_domain module is used for modeling frequency-domain data.\n\n\n\nSchematic illustrating the physics of the FEM method for an inductive source.","type":"content","url":"/fdem-index","position":1},{"hierarchy":{"lvl1":"Frequency-Domain Electromagnetics","lvl2":"Tutorial Notebooks"},"type":"lvl2","url":"/fdem-index#tutorial-notebooks","position":2},{"hierarchy":{"lvl1":"Frequency-Domain Electromagnetics","lvl2":"Tutorial Notebooks"},"content":"1D Forward Simulation for a Single Sounding ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n1D Inversion for a Single Sounding ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n","type":"content","url":"/fdem-index#tutorial-notebooks","position":3},{"hierarchy":{"lvl1":"Gravity"},"type":"lvl1","url":"/gravity-index","position":0},{"hierarchy":{"lvl1":"Gravity"},"content":"Gravity anomaly and gravity gradiometry data are simulated using functionality within the SimPEG.potential_fields.gravity module. Here, we provide a multitude of introductory and indermediate level tutorials for forward simulation and inversion of gravity anomaly and gravity gradiometry data. Links to each tutorial can be accessed below or from the left-side menu.\n\n\n\nEarth’s gravity anomalies (\n\nimage source)","type":"content","url":"/gravity-index","position":1},{"hierarchy":{"lvl1":"Gravity","lvl2":"Tutorial Notebooks"},"type":"lvl2","url":"/gravity-index#tutorial-notebooks","position":2},{"hierarchy":{"lvl1":"Gravity","lvl2":"Tutorial Notebooks"},"content":"3D Forward Simulation of Gravity Anomaly Data ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n3D Forward Simulation of Gravity Gradiometry Data ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n3D Inversion of Gravity Anomaly Data ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n\n\nCompare weighting strategy with Inversion of surface Gravity Anomaly Data ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n","type":"content","url":"/gravity-index#tutorial-notebooks","position":3},{"hierarchy":{"lvl1":"Induced Polarization"},"type":"lvl1","url":"/ip-index","position":0},{"hierarchy":{"lvl1":"Induced Polarization"},"content":"Induced polarization data are simulated using functionality within the SimPEG.electromagnetics.static.induced_polarization module. Here, we provide a multitude of introductory and indermediate level tutorials for forward simulation and inversion of induced polarization data. Links to each tutorial can be accessed below or from the left-side menu.\n\n\n\nSchematic illustrating the physics of the DC/IP method (\n\nimage source)","type":"content","url":"/ip-index","position":1},{"hierarchy":{"lvl1":"Induced Polarization","lvl2":"Tutorial Notebooks"},"type":"lvl2","url":"/ip-index#tutorial-notebooks","position":2},{"hierarchy":{"lvl1":"Induced Polarization","lvl2":"Tutorial Notebooks"},"content":"2.5D Forward Simulation ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n\n\n3D Forward Simulation ({\\color{orange}Intermediate}, {\\color{orange}Moderate})\n\n\n2.5D Inversion ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n\n\n3D Inversion ({\\color{orange}Intermediate}, {\\color{orange}Moderate})\n","type":"content","url":"/ip-index#tutorial-notebooks","position":3},{"hierarchy":{"lvl1":"Magnetics"},"type":"lvl1","url":"/magnetics-index","position":0},{"hierarchy":{"lvl1":"Magnetics"},"content":"In this chapter, we publish code comparisons and validations for magnetics and magnetic gradiometry modeling packages.\nIn SimPEG, the SimPEG.potential_fields.magnetics module is used for modeling magnetics and gradiometry data.\n\n\n\nGlobal scale magnetic anomalies over Africa (\n\nimage source)","type":"content","url":"/magnetics-index","position":1},{"hierarchy":{"lvl1":"Magnetics","lvl2":"Tutorial Notebooks"},"type":"lvl2","url":"/magnetics-index#tutorial-notebooks","position":2},{"hierarchy":{"lvl1":"Magnetics","lvl2":"Tutorial Notebooks"},"content":"3D Forward Simulation of Total Magnetic Intensity Data ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n3D Forward Simulation of Magnetic Gradiometry Data ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n3D Inversion of TMI Data to Recover a Susceptibility Model ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n","type":"content","url":"/magnetics-index#tutorial-notebooks","position":3},{"hierarchy":{"lvl1":"Time-Domain Electromagnetics"},"type":"lvl1","url":"/tdem-index","position":0},{"hierarchy":{"lvl1":"Time-Domain Electromagnetics"},"content":"In this chapter, we publish code comparisons and validations for time-domain electromagnetic modeling packages.\nIn SimPEG, the\n\n\nsimpeg.electromagnetics.time_domain\nmodule is used for modeling time-domain data.\n\n\n\nSchematic illustrating the physics of the TEM method for an inductive source.","type":"content","url":"/tdem-index","position":1},{"hierarchy":{"lvl1":"Time-Domain Electromagnetics","lvl2":"Tutorial Notebooks"},"type":"lvl2","url":"/tdem-index#tutorial-notebooks","position":2},{"hierarchy":{"lvl1":"Time-Domain Electromagnetics","lvl2":"Tutorial Notebooks"},"content":"1D Forward Simulation for a Single Sounding ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\nFundamentals of Finite Volume for TDEM Simulations ({\\color{green}Introductory}, {\\color{green}Lightweight})\n\n\n3D Forward Simulation for On-Time Large-Loop Data ({\\color{orange}Intermediate}, {\\color{orange}Moderate})\n\n\n1D Inversion for a Single Sounding ({\\color{orange}Intermediate}, {\\color{green}Lightweight})\n","type":"content","url":"/tdem-index#tutorial-notebooks","position":3}]}