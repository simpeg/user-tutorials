{"version":2,"kind":"Notebook","sha256":"a77dbf50df4db79dcd435f494629c9a0767db35c3265f80c4100882c8dcc634f","slug":"plot-inv-2-joint-pf-pgi-no-info-tutorial","location":"/notebooks/12-pgi-inversion/plot_inv_2_joint_pf_pgi_no_info_tutorial.ipynb","dependencies":[],"frontmatter":{"title":"Joint PGI of Gravity + Magnetic on an Octree mesh without petrophysical information","authors":[{"id":"devincowan","nameParsed":{"literal":"Devin Cowan","given":"Devin","family":"Cowan"},"name":"Devin Cowan","orcid":"0000-0002-0089-402X","roles":["Writing – original draft","Writing – review & editing","Software"],"affiliations":["ubc"]}],"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true},"code":{"id":"MIT","url":"https://opensource.org/licenses/MIT","name":"MIT License","free":true,"osi":true}},"github":"https://github.com/simpeg/user-tutorials","subject":"SimPEG User Tutorials","keywords":["geophysics","inversions","python","open-source"],"affiliations":[{"id":"ubc","name":"University of British Columbia","department":"Department of Earth, Ocean and Atmospheric Sciences","address":"2020 – 2207 Main Mall","city":"Vancouver","state":"British Columbia","postal_code":"V6T 1Z4","country":"Canada","isni":"0000 0001 2288 9830","ror":"https://ror.org/03rmrcq20","phone":"604 822 2449"},{"id":"kobold","name":"Kobold Metals"}],"numbering":{"title":{"offset":1}},"source_url":"https://github.com/simpeg/user-tutorials/blob/main/notebooks/12-pgi-inversion/plot_inv_2_joint_pf_pgi_no_info_tutorial.ipynb","edit_url":"https://github.com/simpeg/user-tutorials/edit/main/notebooks/12-pgi-inversion/plot_inv_2_joint_pf_pgi_no_info_tutorial.ipynb","exports":[{"format":"ipynb","filename":"plot_inv_2_joint_pf_pgi_no_info_tutorial.ipynb","url":"/user-tutorials/build/plot_inv_2_joint_pf_-70c9d601e124a47ddf1c1169a32d42bd.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","data":{"collapsed":false,"execution":{"iopub.execute_input":"2025-05-23T18:02:47.261780Z","iopub.status.busy":"2025-05-23T18:02:47.261313Z","iopub.status.idle":"2025-05-23T18:02:47.866922Z","shell.execute_reply":"2025-05-23T18:02:47.866372Z"},"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"%matplotlib inline","key":"NhCJenGkGD"},{"type":"output","id":"nYeJxwUY1aG1bJbkYqvhX","data":[],"key":"NMh6H2AtB0"}],"key":"tJZGEpSrfr"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"This tutorial shows through a joint inversion of Gravity and Magnetic data on an\nOctree mesh how to use the PGI framework introduced in Astic & Oldenburg (2019)\nand Astic et al. (2021) to make geologic assumptions and learn a suitable\npetrophysical distribution when no quantitative petrophysical information is\navailable.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"T8lJJShRAg"}],"key":"r0AcRmoH28"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Thibaut Astic, Douglas W. Oldenburg,\nA framework for petrophysically and geologically guided geophysical inversion\nusing a dynamic Gaussian mixture model prior, Geophysical Journal International,\nVolume 219, Issue 3, December 2019, Pages 1989–2012, DOI:\n","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"iWA4L6Af7y"},{"type":"inlineCode","value":"10.1093/gji/ggz389 <https://doi.org/10.1093/gji/ggz389>","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"tjur1E72uy"},{"type":"text","value":"_.","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"HZThipodYq"}],"key":"WA7trGJrka"},{"type":"paragraph","position":{"start":{"line":14,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Thibaut Astic, Lindsey J. Heagy, Douglas W Oldenburg,\nPetrophysically and geologically guided multi-physics inversion using a dynamic\nGaussian mixture model, Geophysical Journal International,\nVolume 224, Issue 1, January 2021, Pages 40-68, DOI: ","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"J2sjWPdB0E"},{"type":"inlineCode","value":"10.1093/gji/ggaa378 <https://doi.org/10.1093/gji/ggaa378>","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"CoMpXj9kX3"},{"type":"text","value":"_.","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"HZSgv8mNX0"}],"key":"FP18sr21Ny"}],"key":"VMIBX9AUsk"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Import modules","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"QXNVZH6SPi"}],"identifier":"import-modules","label":"Import modules","html_id":"import-modules","implicit":true,"key":"ZdsSJDfKqN"}],"key":"qBr2xkgrWp"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"execution":{"iopub.execute_input":"2025-05-23T18:02:47.870499Z","iopub.status.busy":"2025-05-23T18:02:47.870216Z","iopub.status.idle":"2025-05-23T18:02:49.063463Z","shell.execute_reply":"2025-05-23T18:02:49.062540Z"},"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"from discretize import TreeMesh\nfrom discretize.utils import active_from_xyz\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport simpeg.potential_fields as pf\nfrom simpeg import (\n    data_misfit,\n    directives,\n    inverse_problem,\n    inversion,\n    maps,\n    optimization,\n    regularization,\n    utils,\n)\nfrom simpeg.utils import io_utils","key":"vvaDHBER2w"},{"type":"output","id":"i1arZufQ0oh0G6UIsuY-S","data":[],"key":"MVf7zbz84w"}],"key":"M5FaSuViPv"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Setup","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"mEwiSnNgHB"}],"identifier":"setup","label":"Setup","html_id":"setup","implicit":true,"key":"gDxkUxEDqB"}],"key":"I5LSm0UW9p"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"execution":{"iopub.execute_input":"2025-05-23T18:02:49.067759Z","iopub.status.busy":"2025-05-23T18:02:49.067265Z","iopub.status.idle":"2025-05-23T18:02:57.650881Z","shell.execute_reply":"2025-05-23T18:02:57.649809Z"},"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# Load Mesh\nmesh_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/mesh_tutorial.ubc\"\n)\nmesh = TreeMesh.read_UBC(mesh_file)\n\n# Load True geological model for comparison with inversion result\ntrue_geology_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/geology_true.mod\"\n)\ntrue_geology = mesh.read_model_UBC(true_geology_file)\n\n# Plot true geology model\nfig, ax = plt.subplots(1, 4, figsize=(20, 4))\nticksize, labelsize = 14, 16\nfor _, axx in enumerate(ax):\n    axx.set_aspect(1)\n    axx.tick_params(labelsize=ticksize)\nmesh.plot_slice(\n    true_geology,\n    normal=\"X\",\n    ax=ax[0],\n    ind=-17,\n    clim=[0, 2],\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\nmesh.plot_slice(\n    true_geology,\n    normal=\"Y\",\n    ax=ax[1],\n    clim=[0, 2],\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\ngeoplot = mesh.plot_slice(\n    true_geology,\n    normal=\"Z\",\n    ax=ax[2],\n    clim=[0, 2],\n    ind=-10,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n    grid=True,\n)\ngeocb = plt.colorbar(geoplot[0], cax=ax[3], ticks=[0, 1, 2])\ngeocb.set_label(\n    \"True geology model\\n(classification/density/mag. susc.)\", fontsize=labelsize\n)\ngeocb.set_ticklabels(\n    [\"BCKGRD (0 g/cc; 0 SI)\", \"PK (-0.8 g/cc; 5e-3 SI)\", \"VK (-0.2 g/cc; 2e-2 SI)\"]\n)\ngeocb.ax.tick_params(labelsize=ticksize)\nax[3].set_aspect(10)\nplt.show()\n\n# Load geophysical data\ndata_grav_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/gravity_data.obs\"\n)\ndata_grav = io_utils.read_grav3d_ubc(data_grav_file)\ndata_mag_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/magnetic_data.obs\"\n)\ndata_mag = io_utils.read_mag3d_ubc(data_mag_file)\n\n# plot data and mesh\nfig, ax = plt.subplots(2, 2, figsize=(15, 10))\nax = ax.reshape(-1)\nplt.gca().set_aspect(\"equal\")\nplt.gca().set_xlim(\n    [\n        data_mag.survey.receiver_locations[:, 0].min(),\n        data_mag.survey.receiver_locations[:, 0].max(),\n    ],\n)\nplt.gca().set_ylim(\n    [\n        data_mag.survey.receiver_locations[:, 1].min(),\n        data_mag.survey.receiver_locations[:, 1].max(),\n    ]\n)\nmesh.plot_slice(\n    np.ones(mesh.nC),\n    normal=\"Z\",\n    ind=int(-10),\n    grid=True,\n    pcolor_opts={\"cmap\": \"Greys\"},\n    ax=ax[0],\n)\nmm = utils.plot2Ddata(\n    data_grav.survey.receiver_locations,\n    -data_grav.dobs,\n    ax=ax[0],\n    level=True,\n    nx=20,\n    ny=20,\n    dataloc=True,\n    ncontour=12,\n    shade=True,\n    contourOpts={\"cmap\": \"Blues_r\", \"alpha\": 0.8},\n    levelOpts={\"colors\": \"k\", \"linewidths\": 0.5, \"linestyles\": \"dashed\"},\n)\nax[0].set_aspect(1)\nax[0].set_title(\n    \"Gravity data values and locations,\\nwith mesh and geology overlays\", fontsize=16\n)\nplt.colorbar(mm[0], cax=ax[2], orientation=\"horizontal\")\nax[2].set_aspect(0.05)\nax[2].set_title(\"mGal\", fontsize=16)\nmesh.plot_slice(\n    np.ones(mesh.nC),\n    normal=\"Z\",\n    ind=int(-10),\n    grid=True,\n    pcolor_opts={\"cmap\": \"Greys\"},\n    ax=ax[1],\n)\nmm = utils.plot2Ddata(\n    data_mag.survey.receiver_locations,\n    data_mag.dobs,\n    ax=ax[1],\n    level=True,\n    nx=20,\n    ny=20,\n    dataloc=True,\n    ncontour=11,\n    shade=True,\n    contourOpts={\"cmap\": \"Reds\", \"alpha\": 0.8},\n    levelOpts={\"colors\": \"k\", \"linewidths\": 0.5, \"linestyles\": \"dashed\"},\n)\nax[1].set_aspect(1)\nax[1].set_title(\n    \"Magnetic data values and locations,\\nwith mesh and geology overlays\", fontsize=16\n)\nplt.colorbar(mm[0], cax=ax[3], orientation=\"horizontal\")\nax[3].set_aspect(0.05)\nax[3].set_title(\"nT\", fontsize=16)\n# overlay true geology model for comparison\nindz = -9\nindslicezplot = mesh.gridCC[:, 2] == mesh.cell_centers_z[indz]\nfor i in range(2):\n    utils.plot2Ddata(\n        mesh.gridCC[indslicezplot][:, [0, 1]],\n        true_geology[indslicezplot],\n        nx=200,\n        ny=200,\n        contourOpts={\"alpha\": 0},\n        clim=[0, 2],\n        ax=ax[i],\n        level=True,\n        ncontour=2,\n        levelOpts={\"colors\": \"k\", \"linewidths\": 2, \"linestyles\": \"--\"},\n        method=\"nearest\",\n    )\nplt.subplots_adjust(hspace=-0.25, wspace=0.1)\nplt.show()\n\n# Load Topo\ntopo_file = io_utils.download(\n    \"https://storage.googleapis.com/simpeg/pgi_tutorial_assets/CDED_Lake_warp.xyz\"\n)\ntopo = np.genfromtxt(topo_file, skip_header=1)\n# find the active cells\nactv = active_from_xyz(mesh, topo, \"CC\")\n# Create active map to go from reduce set to full\nndv = np.nan\nactvMap = maps.InjectActiveCells(mesh, actv, ndv)\nnactv = int(actv.sum())\n\n# Create simulations and data misfits\n# Wires mapping\nwires = maps.Wires((\"den\", actvMap.nP), (\"sus\", actvMap.nP))\ngravmap = actvMap * wires.den\nmagmap = actvMap * wires.sus\nidenMap = maps.IdentityMap(nP=nactv)\n# Grav problem\nsimulation_grav = pf.gravity.simulation.Simulation3DIntegral(\n    survey=data_grav.survey,\n    mesh=mesh,\n    rhoMap=wires.den,\n    active_cells=actv,\n    engine=\"choclo\",\n)\ndmis_grav = data_misfit.L2DataMisfit(data=data_grav, simulation=simulation_grav)\n# Mag problem\nsimulation_mag = pf.magnetics.simulation.Simulation3DIntegral(\n    survey=data_mag.survey,\n    mesh=mesh,\n    chiMap=wires.sus,\n    active_cells=actv,\n    engine=\"choclo\",\n)\ndmis_mag = data_misfit.L2DataMisfit(data=data_mag, simulation=simulation_mag)","key":"U3ZPBZqSMn"},{"type":"output","id":"RzHCKOqNyRkHz1W32KfAc","data":[{"name":"stdout","output_type":"stream","text":"file already exists, new file is called /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/mesh_tutorial.ubc\nDownloading https://storage.googleapis.com/simpeg/pgi_tutorial_assets/mesh_tutorial.ubc\n   saved to: /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/mesh_tutorial.ubc\nDownload completed!\n"},{"name":"stdout","output_type":"stream","text":"file already exists, new file is called /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/geology_true.mod\nDownloading https://storage.googleapis.com/simpeg/pgi_tutorial_assets/geology_true.mod\n   saved to: /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/geology_true.mod\nDownload completed!\n"},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"c1d5e0d84d41f1406075fadfee3ee34f","path":"/user-tutorials/build/c1d5e0d84d41f1406075fadfee3ee34f.png"},"text/plain":{"content":"<Figure size 2000x400 with 4 Axes>","content_type":"text/plain"}}},{"name":"stdout","output_type":"stream","text":"file already exists, new file is called /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/gravity_data.obs\nDownloading https://storage.googleapis.com/simpeg/pgi_tutorial_assets/gravity_data.obs\n   saved to: /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/gravity_data.obs\nDownload completed!\nfile already exists, new file is called /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/magnetic_data.obs\nDownloading https://storage.googleapis.com/simpeg/pgi_tutorial_assets/magnetic_data.obs\n"},{"name":"stdout","output_type":"stream","text":"   saved to: /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/magnetic_data.obs\nDownload completed!\n"},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"a42c757f04992a5e8eb0e43c4f2ef7c4","path":"/user-tutorials/build/a42c757f04992a5e8eb0e43c4f2ef7c4.png"},"text/plain":{"content":"<Figure size 1500x1000 with 4 Axes>","content_type":"text/plain"}}},{"name":"stdout","output_type":"stream","text":"file already exists, new file is called /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/CDED_Lake_warp.xyz\nDownloading https://storage.googleapis.com/simpeg/pgi_tutorial_assets/CDED_Lake_warp.xyz\n"},{"name":"stdout","output_type":"stream","text":"   saved to: /home/ssoler/git/user-tutorials/notebooks/12-pgi-inversion/CDED_Lake_warp.xyz\nDownload completed!\n"}],"key":"gkaY2BwJHj"}],"key":"YrHWHibKzs"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Create a joint Data Misfit","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"phIRfm4Yny"}],"key":"t7O6Ausit8"}],"key":"DGtE0Bhbi7"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"execution":{"iopub.execute_input":"2025-05-23T18:02:57.654879Z","iopub.status.busy":"2025-05-23T18:02:57.654624Z","iopub.status.idle":"2025-05-23T18:02:57.659265Z","shell.execute_reply":"2025-05-23T18:02:57.658680Z"},"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# Joint data misfit\ndmis = 0.5 * dmis_grav + 0.5 * dmis_mag\n\n# initial model\nm0 = np.r_[-1e-4 * np.ones(actvMap.nP), 1e-4 * np.ones(actvMap.nP)]","key":"lDya37u3QC"},{"type":"output","id":"nrAsxynKUOgU4UcJQ3Ywy","data":[],"key":"rdx77NwSDd"}],"key":"R8ZH8Jt8rv"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Inversion with no petrophysical information about the means","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"uo1QyBh43L"}],"identifier":"inversion-with-no-petrophysical-information-about-the-means","label":"Inversion with no petrophysical information about the means","html_id":"inversion-with-no-petrophysical-information-about-the-means","implicit":true,"key":"iu46LTopDR"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"In this scenario, we do not know the true petrophysical signature of each rock\nunit. We thus make geologic assumptions to design a coupling term and perform\na multi-physics inversion. in addition to a neutral background, we assume that\none rock unit is only less dense, and the third one is only magnetic. As we\ndo not know their mean petrophysical values. We start with an initial guess\n(-1 g/cc) for the updatable mean density-contrast value of the less dense unit\n(with a fixed susceptibility of 0 SI). The magnetic-contrasting unit’s updatable\nsusceptibility is initialized at a value of 0.1 SI (with a fixed 0 g/cc density\ncontrast). We then let the algorithm learn a suitable set of means under the set\nconstrained (fixed or updatable value), through the kappa argument, denoting our\nconfidences in each initial mean value (high confidence: fixed value; low\nconfidence: updatable value).","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"UK9A7OWLH2"}],"key":"pBPtCAVtvD"}],"key":"d6Cq1nd4eN"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Create a petrophysical GMM initial guess","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"YkI5a2Kh3W"}],"identifier":"create-a-petrophysical-gmm-initial-guess","label":"Create a petrophysical GMM initial guess","html_id":"create-a-petrophysical-gmm-initial-guess","implicit":true,"key":"ZwPiho8Wun"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"The GMM is our representation of the petrophysical and geological information.\nHere, we focus on the petrophysical aspect, with the means and covariances of\nthe physical properties of each rock unit.\nTo generate the data above, the PK unit was populated with a density contrast\nof -0.8 g/cc and a magnetic susceptibility of 0.005 SI. The properties of the\nHK unit were set at -0.2 g/cc and 0.02 SI. But here, we assume we\ndo not have this information. Thus, we start with initial guess for the means\nand confidences kappa such that one unit is only less dense and one unit is only\nmagnetic, both embedded in a neutral background. The covariances matrices are set\nso that we assume petrophysical noise levels of around 0.05 g/cc and 0.001 SI\nfor both unit. The background unit is set at a fixed null contrasts (0 g/cc\n0 SI) with a petrophysical noise level of half of the above.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"v0WurxnRCN"}],"key":"sAaXu8uDFP"}],"key":"ogH5hdtUtR"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"execution":{"iopub.execute_input":"2025-05-23T18:02:57.662620Z","iopub.status.busy":"2025-05-23T18:02:57.662381Z","iopub.status.idle":"2025-05-23T18:02:59.897692Z","shell.execute_reply":"2025-05-23T18:02:59.896916Z"},"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"gmmref = utils.WeightedGaussianMixture(\n    n_components=3,  # number of rock units: bckgrd, PK, HK\n    mesh=mesh,  # inversion mesh\n    actv=actv,  # actv cells\n    covariance_type=\"diag\",  # diagonal covariances\n)\n# required: initialization with fit\n# fake random samples, size of the mesh\n# number of physical properties: 2 (density and mag.susc)\nrng = np.random.default_rng(seed=518936)\ngmmref.fit(rng.normal(size=(nactv, 2)))\n# set parameters manually\n# set phys. prop means for each unit\ngmmref.means_ = np.c_[\n    [0.0, 0.0],  # BCKGRD density contrast and mag. susc\n    [-1, 0.0],  # PK\n    [0, 0.1],  # HK\n].T\n# set phys. prop covariances for each unit\ngmmref.covariances_ = np.array(\n    [[6e-04, 3.175e-07], [2.4e-03, 1.5e-06], [2.4e-03, 1.5e-06]]\n)\n# important after setting cov. manually: compute precision matrices and cholesky\ngmmref.compute_clusters_precisions()\n# set global proportions; low-impact as long as not 0 or 1 (total=1)\ngmmref.weights_ = np.r_[0.9, 0.075, 0.025]\n\n# Plot the 2D GMM\nax = gmmref.plot_pdf(flag2d=True, plotting_precision=250)\nax[0].set_xlabel(\"Density contrast [g/cc]\")\nax[0].set_ylim([0, 5])\nax[2].set_ylabel(\"magnetic Susceptibility [SI]\")\nax[2].set_xlim([0, 100])\nplt.show()","key":"QTh1Tyw51L"},{"type":"output","id":"SAyCIhciwaD60mT-6PaTn","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"1270df2167da2cf7757c52bbf6bafd8f","path":"/user-tutorials/build/1270df2167da2cf7757c52bbf6bafd8f.png"},"text/plain":{"content":"<Figure size 1000x1000 with 4 Axes>","content_type":"text/plain"}}}],"key":"SGoW5CCf0g"}],"key":"cc55va3wk2"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Inverse problem with no mean information","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"Yn2jInqLmY"}],"identifier":"inverse-problem-with-no-mean-information","label":"Inverse problem with no mean information","html_id":"inverse-problem-with-no-mean-information","implicit":true,"key":"GkPKeQG5rn"}],"key":"nRoUAHBpSE"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"execution":{"iopub.execute_input":"2025-05-23T18:02:59.900954Z","iopub.status.busy":"2025-05-23T18:02:59.900741Z","iopub.status.idle":"2025-05-23T18:04:28.912202Z","shell.execute_reply":"2025-05-23T18:04:28.911534Z"},"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# Create PGI regularization\n# Sensitivity weighting\nwr_grav = np.sum(simulation_grav.G**2.0, axis=0) ** 0.5 / (mesh.cell_volumes[actv])\nwr_grav = wr_grav / np.max(wr_grav)\n\nwr_mag = np.sum(simulation_mag.G**2.0, axis=0) ** 0.5 / (mesh.cell_volumes[actv])\nwr_mag = wr_mag / np.max(wr_mag)\n\n# create joint PGI regularization with smoothness\nreg = regularization.PGI(\n    gmmref=gmmref,\n    mesh=mesh,\n    wiresmap=wires,\n    maplist=[idenMap, idenMap],\n    active_cells=actv,\n    alpha_pgi=1.0,\n    alpha_x=1.0,\n    alpha_y=1.0,\n    alpha_z=1.0,\n    alpha_xx=0.0,\n    alpha_yy=0.0,\n    alpha_zz=0.0,\n    # use the classification of the initial model (here, all background unit)\n    # as initial reference model\n    reference_model=utils.mkvc(\n        gmmref.means_[gmmref.predict(m0.reshape(actvMap.nP, -1))]\n    ),\n    weights_list=[wr_grav, wr_mag],  # weights each phys. prop. by correct sensW\n)\n\n# Directives\n# Add directives to the inversion\n# ratio to use for each phys prop. smoothness in each direction:\n# roughly the ratio of range of each phys. prop.\nalpha0_ratio = np.r_[\n    1e-2 * np.ones(len(reg.objfcts[1].objfcts[1:])),\n    1e-2 * 100.0 * np.ones(len(reg.objfcts[2].objfcts[1:])),\n]\nAlphas = directives.AlphasSmoothEstimate_ByEig(alpha0_ratio=alpha0_ratio, verbose=True)\n# initialize beta and beta/alpha_s schedule\nbeta = directives.BetaEstimate_ByEig(beta0_ratio=1e-4)\nbetaIt = directives.PGI_BetaAlphaSchedule(\n    verbose=True,\n    coolingFactor=2.0,\n    tolerance=0.2,\n    progress=0.2,\n)\n# geophy. and petro. target misfits\ntargets = directives.MultiTargetMisfits(\n    verbose=True,\n    chiSmall=0.5,  # ask for twice as much clustering (target value is /2)\n)\n# add learned mref in smooth once stable\nMrefInSmooth = directives.PGI_AddMrefInSmooth(\n    wait_till_stable=True,\n    verbose=True,\n)\n# update the parameters in smallness (L2-approx of PGI)\nupdate_smallness = directives.PGI_UpdateParameters(\n    update_gmm=True,  # update the GMM each iteration\n    kappa=np.c_[  # confidences in each mean phys. prop. of each cluster\n        1e10\n        * np.ones(\n            2\n        ),  # fixed background at 0 density, 0 mag. susc. (high confidences of 1e10)\n        [\n            0,\n            1e10,\n        ],  # density-contrasting cluster: updatable density mean, fixed mag. susc.\n        [\n            1e10,\n            0,\n        ],  # magnetic-contrasting cluster: fixed density mean, updatable mag. susc.\n    ].T,\n)\n# pre-conditioner\nupdate_Jacobi = directives.UpdatePreconditioner()\n# iteratively balance the scaling of the data misfits\nscaling_init = directives.ScalingMultipleDataMisfits_ByEig(chi0_ratio=[1.0, 100.0])\nscale_schedule = directives.JointScalingSchedule(verbose=True)\n\n# Create inverse problem\n# Optimization\n# set lower and upper bounds\nlowerbound = np.r_[-2.0 * np.ones(actvMap.nP), 0.0 * np.ones(actvMap.nP)]\nupperbound = np.r_[0.0 * np.ones(actvMap.nP), 1e-1 * np.ones(actvMap.nP)]\nopt = optimization.ProjectedGNCG(\n    maxIter=30,\n    lower=lowerbound,\n    upper=upperbound,\n    maxIterLS=20,\n    maxIterCG=100,\n    tolCG=1e-4,\n)\n# create inverse problem\ninvProb = inverse_problem.BaseInvProblem(dmis, reg, opt)\ninv = inversion.BaseInversion(\n    invProb,\n    # directives: evaluate alphas (and data misfits scales) before beta\n    directiveList=[\n        Alphas,\n        scaling_init,\n        beta,\n        update_smallness,\n        targets,\n        scale_schedule,\n        betaIt,\n        MrefInSmooth,\n        update_Jacobi,\n    ],\n)\n# Invert\npgi_model_no_info = inv.run(m0)\n\n\n# Plot the result with full petrophysical information\ndensity_model_no_info = gravmap * pgi_model_no_info\nmagsus_model_no_info = magmap * pgi_model_no_info\nlearned_gmm = reg.objfcts[0].gmm\nquasi_geology_model_no_info = actvMap * reg.objfcts[0].compute_quasi_geology_model()\n\nfig, ax = plt.subplots(3, 4, figsize=(15, 10))\nfor _, axx in enumerate(ax):\n    for _, axxx in enumerate(axx):\n        axxx.set_aspect(1)\n        axxx.tick_params(labelsize=ticksize)\n\nindx = 15\nindy = 17\nindz = -9\n# geology model\nmesh.plot_slice(\n    quasi_geology_model_no_info,\n    normal=\"X\",\n    ax=ax[0, 0],\n    clim=[0, 2],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\nmesh.plot_slice(\n    quasi_geology_model_no_info,\n    normal=\"Y\",\n    ax=ax[0, 1],\n    clim=[0, 2],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\ngeoplot = mesh.plot_slice(\n    quasi_geology_model_no_info,\n    normal=\"Z\",\n    ax=ax[0, 2],\n    clim=[0, 2],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"inferno_r\"},\n)\ngeocb = plt.colorbar(geoplot[0], cax=ax[0, 3], ticks=[0, 1, 2])\ngeocb.set_ticklabels([\"BCK\", \"PK\", \"VK\"])\ngeocb.set_label(\"Quasi-Geology model\\n(Rock units classification)\", fontsize=16)\nax[0, 3].set_aspect(10)\n\n# gravity model\nmesh.plot_slice(\n    density_model_no_info,\n    normal=\"X\",\n    ax=ax[1, 0],\n    clim=[-1, 0],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\nmesh.plot_slice(\n    density_model_no_info,\n    normal=\"Y\",\n    ax=ax[1, 1],\n    clim=[-1, 0],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\ndenplot = mesh.plot_slice(\n    density_model_no_info,\n    normal=\"Z\",\n    ax=ax[1, 2],\n    clim=[-1, 0],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"Blues_r\"},\n)\ndencb = plt.colorbar(denplot[0], cax=ax[1, 3])\ndencb.set_label(\"Density contrast\\nmodel (g/cc)\", fontsize=16)\nax[1, 3].set_aspect(10)\n\n# magnetic model\nmesh.plot_slice(\n    magsus_model_no_info,\n    normal=\"X\",\n    ax=ax[2, 0],\n    clim=[0, 0.025],\n    ind=indx,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nmesh.plot_slice(\n    magsus_model_no_info,\n    normal=\"Y\",\n    ax=ax[2, 1],\n    clim=[0, 0.025],\n    ind=indy,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nsusplot = mesh.plot_slice(\n    magsus_model_no_info,\n    normal=\"Z\",\n    ax=ax[2, 2],\n    clim=[0, 0.025],\n    ind=indz,\n    pcolor_opts={\"cmap\": \"Reds\"},\n)\nsuscb = plt.colorbar(susplot[0], cax=ax[2, 3])\nsuscb.set_label(\"Magnetic susceptibility\\nmodel (SI)\", fontsize=16)\nax[2, 3].set_aspect(10)\n\n# overlay true geology model for comparison\nindslicexplot = mesh.gridCC[:, 0] == mesh.cell_centers_x[indx]\nindsliceyplot = mesh.gridCC[:, 1] == mesh.cell_centers_y[indy]\nindslicezplot = mesh.gridCC[:, 2] == mesh.cell_centers_z[indz]\nfor i in range(3):\n    for j, (plane, indd) in enumerate(\n        zip([[1, 2], [0, 2], [0, 1]], [indslicexplot, indsliceyplot, indslicezplot])\n    ):\n        utils.plot2Ddata(\n            mesh.gridCC[indd][:, plane],\n            true_geology[indd],\n            nx=100,\n            ny=100,\n            contourOpts={\"alpha\": 0},\n            clim=[0, 2],\n            ax=ax[i, j],\n            level=True,\n            ncontour=2,\n            levelOpts={\"colors\": \"grey\", \"linewidths\": 2, \"linestyles\": \"--\"},\n            method=\"nearest\",\n        )\n\n# plot the locations of the cross-sections\nfor i in range(3):\n    ax[i, 0].plot(\n        mesh.cell_centers_y[indy] * np.ones(2), [-300, 500], c=\"k\", linestyle=\"dotted\"\n    )\n    ax[i, 0].plot(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n        mesh.cell_centers_z[indz] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 0].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n    )\n\n    ax[i, 1].plot(\n        mesh.cell_centers_x[indx] * np.ones(2), [-300, 500], c=\"k\", linestyle=\"dotted\"\n    )\n    ax[i, 1].plot(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n        mesh.cell_centers_z[indz] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 1].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n    )\n\n    ax[i, 2].plot(\n        mesh.cell_centers_x[indx] * np.ones(2),\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 2].plot(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n        mesh.cell_centers_y[indy] * np.ones(2),\n        c=\"k\",\n        linestyle=\"dotted\",\n    )\n    ax[i, 2].set_xlim(\n        [\n            data_mag.survey.receiver_locations[:, 0].min(),\n            data_mag.survey.receiver_locations[:, 0].max(),\n        ],\n    )\n    ax[i, 2].set_ylim(\n        [\n            data_mag.survey.receiver_locations[:, 1].min(),\n            data_mag.survey.receiver_locations[:, 1].max(),\n        ],\n    )\n\nplt.tight_layout()\nplt.show()\n\n# Plot the learned 2D GMM\nfig = plt.figure(figsize=(10, 10))\nax0 = plt.subplot2grid((4, 4), (3, 1), colspan=3)\nax1 = plt.subplot2grid((4, 4), (0, 1), colspan=3, rowspan=3)\nax2 = plt.subplot2grid((4, 4), (0, 0), rowspan=3)\nax = [ax0, ax1, ax2]\nlearned_gmm.plot_pdf(flag2d=True, ax=ax, padding=1, plotting_precision=100)\nax[0].set_xlabel(\"Density contrast [g/cc]\")\nax[0].set_ylim([0, 5])\nax[2].set_xlim([0, 50])\nax[2].set_ylabel(\"magnetic Susceptibility [SI]\")\nax[1].scatter(\n    density_model_no_info[actv],\n    magsus_model_no_info[actv],\n    c=quasi_geology_model_no_info[actv],\n    cmap=\"inferno_r\",\n    edgecolors=\"k\",\n    label=\"recovered PGI model\",\n    alpha=0.5,\n)\nax[0].hist(density_model_no_info[actv], density=True, bins=50)\nax[2].hist(magsus_model_no_info[actv], density=True, bins=50, orientation=\"horizontal\")\nax[1].scatter(\n    [0, -0.8, -0.02],\n    [0, 0.005, 0.02],\n    label=\"True petrophysical means\",\n    cmap=\"inferno_r\",\n    c=[0, 1, 2],\n    marker=\"v\",\n    edgecolors=\"k\",\n    s=200,\n)\nax[1].legend()\nplt.show()","key":"ksQYhzxQdJ"},{"type":"output","id":"A6dLt64ktWYQ5UCUN8BAb","data":[{"name":"stdout","output_type":"stream","text":"\nRunning inversion with SimPEG v0.24.0\n\n                    simpeg.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.\n                    ***Done using the default solver Pardiso and no solver_opts.***\n                    \n"},{"name":"stdout","output_type":"stream","text":"Alpha scales: [np.float64(7660874.184294957), np.float64(0.0), np.float64(5073966.905923588), np.float64(0.0), np.float64(10755946.585578023), np.float64(0.0), np.float64(901080732.7168696), np.float64(0.0), np.float64(651184740.4106032), np.float64(0.0), np.float64(1695952133.7691708), np.float64(0.0)]\n"},{"name":"stdout","output_type":"stream","text":"<class 'simpeg.regularization.pgi.PGIsmallness'>\nInitial data misfit scales:  [0.97501981 0.02498019]\nmodel has any nan: 0\n=============================== Projected GNCG ===============================\n  #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   \n-----------------------------------------------------------------------------\nx0 has any nan: 0\n"},{"name":"stdout","output_type":"stream","text":"   0  1.38e-08  4.25e+06  9.99e+04  4.25e+06    2.17e+02      0              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 446636.5 (target 576.0 [False]); 126029.0 (target 576.0 [False]) | smallness misfit: 136498.4 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [446636.5 126029. ]; minimum progress targets: [3470231.3  572697.8]\nmref changed in  4686  places\n"},{"name":"stdout","output_type":"stream","text":"   1  1.38e-08  4.39e+05  2.02e+09  4.39e+05    2.11e+01      0              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 210204.3 (target 576.0 [False]); 61540.9 (target 576.0 [False]) | smallness misfit: 119214.1 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [210204.3  61540.9]; minimum progress targets: [357309.2 100823.2]\nmref changed in  2555  places\n"},{"name":"stdout","output_type":"stream","text":"   2  1.38e-08  2.06e+05  4.72e+09  2.07e+05    2.10e+01      0              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 88482.6 (target 576.0 [False]); 11937.2 (target 576.0 [False]) | smallness misfit: 93333.4 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [88482.6 11937.2]; minimum progress targets: [168163.4  49232.7]\nmref changed in  1101  places\n"},{"name":"stdout","output_type":"stream","text":"   3  1.38e-08  8.66e+04  4.94e+09  8.66e+04    2.02e+01      0   Skip BFGS  \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 5187.1 (target 576.0 [False]); 490.5 (target 576.0 [True]) | smallness misfit: 70235.5 (target: 11719.0 [False])\nUpdating scaling for data misfits by  1.1742880694019584\nNew scales: [0.97864821 0.02135179]\nBeta cooling evaluation: progress: [5187.1  490.5]; minimum progress targets: [70786.1  9549.8]\nmref changed in  585  places\n"},{"name":"stdout","output_type":"stream","text":"   4  1.38e-08  5.09e+03  5.14e+09  5.16e+03    1.87e+01      0   Skip BFGS  \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 177.4 (target 576.0 [True]); 68.8 (target 576.0 [True]) | smallness misfit: 63591.2 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [177.4  68.8]; minimum progress targets: [4149.6  691.2]\nWarming alpha_pgi to favor clustering:  5.811394880185052\nmref changed in  157  places\n"},{"name":"stdout","output_type":"stream","text":"   5  1.38e-08  1.75e+02  5.61e+09  2.53e+02    1.99e+01      0   Skip BFGS  \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 166.4 (target 576.0 [True]); 42.3 (target 576.0 [True]) | smallness misfit: 58842.6 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [166.4  42.3]; minimum progress targets: [691.2 691.2]\nWarming alpha_pgi to favor clustering:  49.58099161234084\nmref changed in  14  places\n"},{"name":"stdout","output_type":"stream","text":"   6  1.38e-08  1.64e+02  8.51e+09  2.81e+02    3.81e+01      0   Skip BFGS  \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 157.3 (target 576.0 [True]); 223.1 (target 576.0 [True]) | smallness misfit: 45846.5 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [157.3 223.1]; minimum progress targets: [691.2 691.2]\nWarming alpha_pgi to favor clustering:  154.79167783274733\nmref changed in  18  places\n"},{"name":"stdout","output_type":"stream","text":"   7  1.38e-08  1.59e+02  1.41e+10  3.53e+02    2.02e+01      0              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 164.2 (target 576.0 [True]); 140.5 (target 576.0 [True]) | smallness misfit: 37206.4 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [164.2 140.5]; minimum progress targets: [691.2 691.2]\nWarming alpha_pgi to favor clustering:  588.8006720308646\nmref changed in  1  places\n"},{"name":"stdout","output_type":"stream","text":"   8  1.38e-08  1.64e+02  3.20e+10  6.06e+02    1.73e+01      1              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 177.0 (target 576.0 [True]); 321.8 (target 576.0 [True]) | smallness misfit: 17587.1 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [177.  321.8]; minimum progress targets: [691.2 691.2]\nWarming alpha_pgi to favor clustering:  1485.008396242765\nmref changed in  0  places\nAdd mref to Smoothness. Changes in mref happened in 0.0 % of the cells\n"},{"name":"stdout","output_type":"stream","text":"   9  1.38e-08  1.80e+02  4.37e+10  7.84e+02    2.25e+01      0              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 249.9 (target 576.0 [True]); 856.0 (target 576.0 [False]) | smallness misfit: 12697.4 (target: 11719.0 [False])\nUpdating scaling for data misfits by  2.3051366054747797\nNew scales: [0.95211561 0.04788439]\nBeta cooling evaluation: progress: [249.9 856. ]; minimum progress targets: [691.2 691.2]\nDecreasing beta to counter data misfit increase.\nmref changed in  0  places\n"},{"name":"stdout","output_type":"stream","text":"  10  6.91e-09  2.79e+02  3.39e+10  5.13e+02    2.94e+01      0              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 186.0 (target 576.0 [True]); 229.4 (target 576.0 [True]) | smallness misfit: 12420.1 (target: 11719.0 [False])\nBeta cooling evaluation: progress: [186.  229.4]; minimum progress targets: [691.2 691.2]\nWarming alpha_pgi to favor clustering:  4163.436201016231\nmref changed in  0  places\nAdd mref to Smoothness. Changes in mref happened in 0.0 % of the cells\n"},{"name":"stdout","output_type":"stream","text":"  11  6.91e-09  1.88e+02  9.37e+10  8.35e+02    2.76e+01      0              \n"},{"name":"stderr","output_type":"stream","text":"/t40array/ssoler/miniforge3/envs/simpeg-user-tutorials/lib/python3.12/site-packages/sklearn/base.py:474: FutureWarning: `BaseEstimator._validate_data` is deprecated in 1.6 and will be removed in 1.7. Use `sklearn.utils.validation.validate_data` instead. This function becomes public and is part of the scikit-learn developer API.\n  warnings.warn(\n"},{"name":"stdout","output_type":"stream","text":"geophys. misfits: 298.4 (target 576.0 [True]); 554.8 (target 576.0 [True]) | smallness misfit: 10773.2 (target: 11719.0 [True])\nAll targets have been reached\nBeta cooling evaluation: progress: [298.4 554.8]; minimum progress targets: [691.2 691.2]\nWarming alpha_pgi to favor clustering:  6179.66475005224\nmref changed in  0  places\nAdd mref to Smoothness. Changes in mref happened in 0.0 % of the cells\n------------------------- STOP! -------------------------\n1 : |fc-fOld| = 0.0000e+00 <= tolF*(1+|f0|) = 4.2473e+05\n"},{"name":"stdout","output_type":"stream","text":"0 : |xc-x_last| = 7.3188e-01 <= tolX*(1+|x0|) = 1.0153e-01\n0 : |proj(x-g)-x|    = 2.7320e+01 <= tolG          = 1.0000e-01\n0 : |proj(x-g)-x|    = 2.7320e+01 <= 1e3*eps       = 1.0000e-02\n0 : maxIter   =      30    <= iter          =     12\n------------------------- DONE! -------------------------\n"},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"e33abf5acccb23a70fa3bd1ad7293385","path":"/user-tutorials/build/e33abf5acccb23a70fa3bd1ad7293385.png"},"text/plain":{"content":"<Figure size 1500x1000 with 12 Axes>","content_type":"text/plain"}}},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"3dd0fe73b42dbc23a834a1ea0ef45889","path":"/user-tutorials/build/3dd0fe73b42dbc23a834a1ea0ef45889.png"},"text/plain":{"content":"<Figure size 1000x1000 with 4 Axes>","content_type":"text/plain"}}}],"key":"LVnZKV5Vfe"}],"key":"iWqus5zyeo"}],"key":"sFk9dATt1r"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Joint PGI of Gravity + Magnetic on an Octree mesh using full petrophysical information","url":"/plot-inv-1-joint-pf-pgi-full-info-tutorial","group":"PGI Inversion"},"next":{"title":"Contributing to User Tutorials","url":"/contributing-index","group":"PGI Inversion"}}},"domain":"http://localhost:3000"}